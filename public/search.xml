<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Problems_Python]]></title>
    <url>%2F2018%2F09%2F22%2FProblems-Python%2F</url>
    <content type="text"><![CDATA[Problems of Python1. PyCharm:AttributeError: module ‘pip’ has no attribute ‘main’ 解决步骤 打开/Applications/PyCharm.app/Contents/helpers/packaging_tool.py 修改do_install和do_uninstall 123456789101112131415161718192021222324252627282930313233343536373839原来：def do_install(pkgs): try: import pip except ImportError: error_no_pip() return pip.main(['install'] + pkgs)def do_uninstall(pkgs): try: import pip except ImportError: error_no_pip() return pip.main(['uninstall', '-y'] + pkgs)修改后def do_install(pkgs): try: #import pip try: from pip._internal import main except Exception: from pip import main except ImportError: error_no_pip() return main(['install'] + pkgs)def do_uninstall(pkgs): try: #import pip try: from pip._internal import main except Exception: from pip import main except ImportError: error_no_pip() return main(['uninstall', '-y'] + pkgs) 2. 安装pyspider失败，提示PycURL how to specify the SSL backend manually. 卸载已存在pycurl 1$ pip3 uninstall pycurl 使用link-time ssl后端导出变量 1$ export PYCURL_SSL_LIBRARY=openssl 重新安装pycurl 1$ pip3 install pycurl 参考 https://stackoverflow.com/questions/21096436/ssl-backend-error-when-using-openssl 3. 运行pyspider提示async=True, get_object=False, no_input=False 因为async和await从python3.7开始已经加入保留关键字中，参考What’s New Python3.7，所以async和await不能作为函数的参数名 需要降低python版本至3.6]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Problems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的系统编程工具]]></title>
    <url>%2F2018%2F09%2F17%2FPython%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Python的系统编程工具 介绍sys模块12345678import os,sys# 分别有287和84个属性len(dir(os))287len(dir(sys))84&gt;&gt;&gt; sys.platform,sys.version,sys.maxsize('darwin', '3.6.6 (v3.6.6:4cf1f54eb7, Jun 26 2018, 19:50:54) \n[GCC 4.2.1 Compatible Apple LLVM6.0 (clang-600.0.57)]', 9223372036854775807) 模块搜索路径 sys模块使得我们可以在Python程序内部或者交互地常看模块搜索路径。sys.path是一个由目录名称字符串组成的列表，每个目录名称字符串代表正在运行的Python解释器的真正的搜索路径。 sys.path可以用程序进程更改，比如append、extend、insert、pop、remove和del。 sys.path.append(r&#39;C:\mydir&#39;) sys模块导出的其他工具 显示为由字符串组成的列表的命令行参数，称为sys.argv 标准流，包括sys.stdin、sys.stdout和sys.stderr 程序可以通过调用sys.exit强制退出 介绍os模块 常用的os模块 | 任务 | 工具 || —————— | ———————————————————— || Shell变量 | os.environ || 运行程序 | os.system,os.popen,os.execv,os.spawnv || 派生进程 | os.fork,os.pipe,os.waitpid,os.kill || 文件描述符，文件锁 | os.open,os.read,os.write || 文件处理 | os.remove,os.rename,os.mkdir,os.rmdir || 管理工具 | os.getcwd,os.chdir,os.chmod,os.getpid,os.listdir,os.access || 移植工具 | os.sep,os.pathsep,os.curdir,os.path.split,os.path.join || 路径名工具 | os.path.exists(‘path’),os.path.isdir(‘path’),os.path.getsize(‘path’) | 12345678910111213import osdir(os)len(dir(os))['CLD_CONTINUED', 'CLD_DUMPED', 'CLD_EXITED', 'CLD_TRAPPED', 'DirEntry', 'EX_CANTCREAT', 'EX_CONFIG', 'EX_DATAERR', 'EX_IOERR', 'EX_NOHOST', 'EX_NOINPUT', ... 'sync', 'sys', 'sysconf', 'sysconf_names', 'system', 'tcgetpgrp', 'tcsetpgrp', 'terminal_size', 'times', 'times_result', 'truncate', 'ttyname', 'umask', 'uname', 'uname_result', 'unlink', 'unsetenv', 'urandom', 'utime', 'wait', 'wait3', 'wait4', 'waitpid', 'walk', 'write', 'writev']287dir(os.path)len(dir(os.path))['__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_get_sep', '_joinrealpath', '_varprog', ... 'sep', 'split', 'splitdrive', 'splitext', 'stat', 'supports_unicode_filenames', 'sys']55 管理工具 1234567&gt;&gt;&gt; os.getpid() # 给出调用函数的进程IDI1210&gt;&gt;&gt; os.getcwd() # 返回当前的工作目录'/Users/entercoder'&gt;&gt;&gt; os.chdir('/Users/entercoder/Documents') # 更改当前工作目录&gt;&gt;&gt; os.getcwd()'/Users/entercoder/Documents' 可移植的常量 os模块同时导出了一组用于简化跨平台编程的名称，包括具体平台相关的路径和目录分隔符、父目录和当前目录的指示器，以及底层计算机所采用的换行符。 12345678910&gt;&gt;&gt; os.sep # 运行平台所采用的目录分隔符'/'&gt;&gt;&gt; os.pathsep # 在目录列表中分隔目录的字符':'&gt;&gt;&gt; os.pardir # 上一级目录'..'&gt;&gt;&gt; os.curdir # 当前目录'.'&gt;&gt;&gt; os.linesep # 换行符'\n' 常见的os.path工具1234567891011121314151617181920212223242526# 判断文件类型os.path.isdir('/Users/entercoder/Documents/entercoder1993.github.io_back')Trueos.path.isfile('/Users/entercoder/Documents/entercoder1993.github.io_back')False# 判断文件是否存在os.path.exists('/Users/entercoder/Documents/entercoder1993.github.io_back')True# 获取文件的大小os.path.getsize('/Users/entercoder/Documents/entercoder1993.github.io_back')512# 分离目录和文件名os.path.split('/Users/entercoder/Documents/entercoder1993.github.io_back') ('/Users/entercoder/Documents', 'entercoder1993.github.io_back')# 合并目录和文件名os.path.join('/Users/entercoder/Documents', 'entercoder1993.github.io_back')'/Users/entercoder/Documents/entercoder1993.github.io_back'# 返回目录名os.path.dirname('/Users/entercoder/Documents/Note-Book/README.md')'/Users/entercoder/Documents/Note-Book/'# 返回文件名os.path.basename('/Users/entercoder/Documents/Note-Book/README.md')'README.md'# 分离文件的扩展名os.path.splitext('/Users/entercoder/Documents/Note-Book/README.md')('/Users/entercoder/Documents/Note-Book/README'，'.md')]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python之进程和线程]]></title>
    <url>%2F2018%2F09%2F13%2FPython%E4%B9%8B%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Python之进程和线程 对于操作系统来说，一个任务就是一个进程(Process)，比如打开浏览器就是启动一个浏览器进程，打开记事本，就启动了记事本进程。而且有些进程还能同时做几件事情，要同时做几件事，就需要同步运行多个“子任务”，进程内的这些“子任务”称为线程(Thread)。 Python执行多进程有以下两种解决方案： 多进程模式； 多线程模式； 多进程+多线程模式 多进程Unix/Linux提供了一个fork()系统调用。fork()调用一次返回两次，因为操作系统自动把当前进程(父进程)复制了一份(称为子进程)，然后分别在父进程和紫禁城内返回。 子进程永远返回0，父进程返回子进程的ID。因为一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。 12345678import osprint('Process (%s) start...' % os.getpid())pid = os.fork()if pid == 0: print('i am process (%s) and my parent is %s.' % (os.getpid(),os.getppid()))else: print('I (%s) just created a child process (%s).' % (os.getpid(), pid)) 运行结果 123Process (2291) start...I (2291) just created a child process (2294).i am process (2294) and my parent is 2291. 有了fork调用，一个进程在接到新的任务时就可以复制出一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。 缺点：因为Windows没有fork调用，所以上述代码在Windows上无法运行。 multiprocessingmultiprocessing提供了一个Process类来代表一个进程对象 123456789101112from multiprocessing import Processimport osdef run_proc(name): print('Run child process %s (%s)...' % (name,os.getpid()))if __name__ == '__main__': print('Parent process %s. ' % os.getpid()) p = Process(target=run_proc,args=('test',)) print('Child process will start.') p.start() p.join() print('Child process end') 结果如下： 1234Parent process 2357.Child process will start.Run child process test (2360)...Child process end 创建子进程时，只需要传入一个执行函数和函数参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()简单多了。 PoolPool可以启动大量的子进程，可以用进程池的方式批量创建子进程。 123456789101112131415161718192021from multiprocessing import Poolimport os,time,randomdef long_time_task(name): print('Run task %s (%s)...' % (name, os.getpid())) start = time.time() time.sleep(random.random() * 3) end = time.time() print('Task %s runs %0.2f seconds.' % (name, (end - start)))if __name__=='__main__': print('Parent process %s.' % os.getpid()) p = Pool(4) for i in range(5): p.apply_async(long_time_task, args=(i,)) print('Waiting for all subprocesses done...') # 调用close后就不能添加新的Process了 p.close() # Pool对象调用join方法会等待所有进程执行完毕 p.join() print('All subprocesses done.') 子进程subprocess模块可以非常方便地启动一个子进程，然后控制其输入和输出。 12345678910111213import subprocessprint('$ nslookup www.python.org')r = subprocess.call(['nslookup','www.python.org'])print('Exit code:',r)# 输入可以通过communicate()import subprocessprint('$ nslookup')p = subprocess.Popen(['nslookup'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)output, err = p.communicate(b'set q=mx\npython.org\nexit\n')print(output.decode('utf-8'))print('Exit code:', p.returncode) 进程间通信Python的multiprocessing模块包装了底层的机制，通过了Queue、Pipes等多种方式交换数据。 1234567891011121314151617181920212223242526272829303132# 以Queue为例from multiprocessing import Process, Queueimport os, time, random# 写数据进程执行的代码:def write(q): print('Process to write: %s' % os.getpid()) for value in ['A', 'B', 'C']: print('Put %s to queue...' % value) q.put(value) time.sleep(random.random())# 读数据进程执行的代码:def read(q): print('Process to read: %s' % os.getpid()) while True: value = q.get(True) print('Get %s from eue.' % value)if __name__=='__main__': # 父进程创建Queue，并传给各个子进程： q = Queue() pw = Process(target=write, args=(q,)) pr = Process(target=read, args=(q,)) # 启动子进程pw，写入: pw.start() # 启动子进程pr，读取: pr.start() # 等待pw结束: pw.join() # pr进程里是死循环，无法等待其结束，只能强行终止: pr.terminate() 多线程多任务可以由多进程完成，也可以由一个进程内的多线程完成。Python的标准库提供了_thread和threading，_thread是低级模块，threading是高级模块。绝大多数，我们只需使用threading这个高级模块。 12345678910111213141516import time,threadingdef loop(): print('thread %s is running...' % threading.current_thread().name) n = 0 while n &lt; 5: n = n + 1 print('thread %s &gt;&gt;&gt; %s' % (threading.current_thread().name,n)) time.sleep(1) print('thread %s ended.' % threading.current_thread().name)print('thread %s is running...' % threading.current_thread().name)t = threading.Thread(target=loop, name='LoopThread')t.start()t.join()print('thread %s ended.' % threading.current_thread().name) 任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的threading模块里有个current_thread()函数，它就永远返回当前线程的实例。主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用LoopThread命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1，Thread-2…… Lock]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7配置静态IP地址]]></title>
    <url>%2F2018%2F09%2F12%2FCentOS7%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[CentOS 7 配置静态IP地址 切换到网卡列表目录 1$cd /etc/sysconfig/network-scripts/ 一般第一个就是你的网卡，若是服务器，可能会有多个以ifcfg-em开头的网卡，分别对应服务器的网卡接口，在这里我的网卡为ifcfg-eth0 编辑网卡 12345678910111213$vi ifcfg-eth0BOOTPROTO=noneONBOOT=yes# IP地址IPADDR=102.168.1.100# 子网掩码PREFIX=24# 网关地址GATEWAY=192.168.1.1# 设置DNS地址DNS1=202.96.134.133DNS2=8.8.8.8 退出vi，使用:wq命令 保存退出，重启网络服务 1$service network restart 若成功，则出现如下提示]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络爬虫开发实战]]></title>
    <url>%2F2018%2F09%2F11%2FPython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[Python网络爬虫开发实战一、开发环境配置1.1 Python3 相关链接 官方网站：https://www.python.org 下载地址：https://www.python.org/downloads 第三方库：https://pypi.org 官方文档：https://docs.python.org/3 中文文档 中文教程： 菜鸟教程 廖雪峰Python3教程 1.2 请求库的安装Request的安装 相关链接 GitHub：https://github.com/requests/requests PyPI：https://pypi.org/project/requests/ 官方文档：http://docs.python-requests.org/en/master/ 中文文档：http://cn.python-requests.org/zh_CN/latest/ Selenium的安装 相关链接 官方网站：https://www.seleniumhq.org/ GitHub：https://github.com/SeleniumHQ/Selenium PyPI：https://pypi.org/project/selenium/ 官方文档：http://selenium-python.readthedocs.io/ 中文文档：http://selenium-python-zh.readthedocs.io ChromeDriver的安装 相关链接 官方地址：http://chromedriver.chromium.org/ 下载地址：https://chromedriver.storage.googleapis.com/index.html?path=2.40/（需根据Chrome的版本下载对应的ChromeDriver） 环境变量配置： Windows：将chromedriver.exe文件拖到Python的Scripts目录下即可。 Linux和Mac下 将文件移动到/usr/bin目录下suod mv chromedriver /usr/bin 或者将ChromeDriver配置到$PATH export PATH=&quot;$PATH:/usr/local/chromedriver&quot; GeckoDriver的安装 相关链接 Github：https://github.com/mozilla/geckodriver 下载地址：https://github.com/mozilla/geckodriver/releases PhantomJS的安装 相关链接 官方网站：http://phantomjs.org 官方文档：http://phantomjs.org/quick-start.html 下载地址：http://phantomjs.org/download.html API接口说明：http://phantomjs.org/api/command-line.html aiohttp的安装 相关链接 官方文档：https://docs.aiohttp.org/en/stable/ GitHub：https://github.com/aio-libs/aiohttp PyPI：https://pypi.org/project/aiohttp/ 1.3 解析库的安装lxml的安装 相关链接 官方网站：https://lxml.de/ GitHub：https://github.com/lxml/lxml PyPI：https://pypi.org/project/lxml/ Beautiful Soup4的安装 相关链接 官方网站：https://www.crummy.com/software/BeautifulSoup/bs4/doc/ 中文文档：https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/ PyPI：https://pypi.org/project/beautifulsoup4/ pyquery的安装 相关链接 官方网站：https://pythonhosted.org/pyquery/ GitHub：https://github.com/gawel/pyquery/ PyPI：https://pypi.org/project/pyquery/ tesserocr的安装 相关链接 tesserocr GitHub：https://github.com/tesseract-ocr/tesseract tesserocr PyPI：https://pypi.org/project/tesserocr/ tesseract 下载地址：https://github.com/tesseract-ocr/tesseract/wiki tesseract GitHub：https://github.com/tesseract-ocr/tesseract tesseract语言包：https://github.com/tesseract-ocr/tessdata tesseract文档：https://github.com/tesseract-ocr/tesseract/wiki/Documentation 1.4 数据库的安装MySQL的安装MongoDB的安装Redis的安装1.5 存储库的安装PyMySQL的安装PyMongo的安装redis-py的安装RedisDump的安装1.6 Web库的安装Flask的安装Tornado的安装1.7 App爬取相关的库安装Charles的安装mitmproxy的安装1.8 爬虫框架的安装pyspider的安装Scrapy的安装Scrapy-Splash的安装Scrapy-Redis的安装1.9 部署库相关的库的安装Docker的安装 安装 1$brew cask install docker Scrapyd的安装 安装 1$pip3 install scrapyd 配置 新建配置文件/etc/scrapyd/scrapyd.conf Scrapyd的安装Scrapyd-Client的安装Scrapyd API的安装Scrapyrt的安装Gerapy的安装二、爬虫基础2.1 HTTP基本原理 请求网站并提取数据的自动化程序 URI和URL URI全称Uniform Resource Identifier，即统一资源标志符 URL全称Universal Resource Locator，即统一资源定位符 URL是URI的子集 另一个子类为URN全称Universal Resource Name，即统一资源名称 关系 超文本(hypertext)，网页就是超文本解析而成的。 HTTP和HTTPS HTTP全称Hyper Text Transfer Protocol，中文名称:超文本传输协议。是用于从网络传输文本数据到本地浏览器的传送协议，它能保证高效而准确地传送超文本文档。 HTTPS全称Hyper Text Transfer Protocol voer Secure Socket Layer，是以安全为目标的HTTP通道，即HTTP的安全版，HTTP下加入SSL层，简称HTTPS 作用: 建立一个信息安全通道来保证数据传输的安全 确认网站的真实性，凡是使用了HTTPS的网站，都可以通过点击浏览地址栏的锁头标志来查看网站认证之后的真实信息，也可以通过CA机构颁发的安全签章来查询。 HTTP请求过程 浏览器向网站所在的服务器发送一个请求 网站服务器接受到这个请求后进行处理和解析 返回对应的响应（响应包含页面的源代码等内容） 传回给浏览器（浏览器对其进行解析，便将网页呈现出来） Chrome浏览器 Name：请求的名称，一般会将URL的最后一部分内容当做名称 Status：响应的状态码，200代表响应是正常的 Type：请求的文档类型 Initiator：请求源。用来标记请求是由哪个对象或进程发起的 Size：从服务器下载的文件和请求的资源大小。如果从缓存中取得的数据，则该列会像是from cache Time：发起请求到获取响应所用的总时间 Waterfall：网络请求的可视化瀑布流 请求 请求方法 GET POST 区别 GET请求中的参数包含在URL里面，数据可以在URL中看到，而POST请求的URL不会包含这些数据，数据都是通过表单形式传输的，会包含在请求体中 GET请求提交的数据最多只有1024字节，而POST方式没有限制 其他方法： GET、HEAD、POST、PUT、DELETE、OPTIONS、CONNECT、TRACE等 | 方法 | 描述 || ——- | ———————————————————— || GET | 请求页面，并返回页面内容 || HEAD | 类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头 || POST | 大多用于提交表单或上传文件，数据包含在请求体中 || PUT | 从客户端向服务器传送的数据取代指定文档中的内容 || DELETE | 请求服务器删除指定的页面 || CONNECT | 把服务器当做跳板，让服务器代替客户端访问其他网页 || OPTIONS | 允许客户端查看服务器的性能 || TRACE | 回显服务器收到的请求，主要用于测试或诊断 | 请求的网址：即统一资源定位符URL，它可以唯一确定我们想请求的资源 请求头 Accept：请求报头域，用于指定客户端可接受哪些类型的信息 Accept-Language：制定客户端可接受的语言类型 Accept-Encoding：指定客户端可接受的内容编码 Host：用于请求资源的主机IP和端口号，其内容为请求URL的原始服务器或网关的位置 Cookie：常用复数形式Cookies，这是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。主要功能是维持当前访问会话。 Referer：便是请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如做来源统计、防盗链处理等。 User-Agent：简称UA，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及版本等信息。在做爬虫时加上此信息，可以伪装为浏览器；如果不加，很可能会被识别为爬虫。 Content-Type：也叫互联网媒体类型或者MIME类型，如HTTP协议消息头中，它用来表示具体请求中的媒体类型信息。text\html代表HTML格式，image/gif代表GIF图片，application/json代表JSON类型等。 请求体：登录之前，填写的用户名和密码信息，提交时这些内容就会以表单数据的形式提交给服务器，只有有设置Request Headers中的Content-Type为application/x-www-form-urlencoded时，才会以表单数据的形式提交。 | Content-Type | 提交数据的方式 || ——————————— | ————– || application/x-www-form-urlencoded | 表单数据 || mulitipart/form-data | 表单文件上传 || application/json | 序列化JSON数据 || text/xml | XML数据 | 响应 响应状态码（Response Status Code） 响应头（Response Headers） Date：标识响应产生的时间 Last-Moidfied：指定资源的最后修改时间 Content-Encoding：指定响应内容的编码 Server：包含服务器的信息，比如名称、版本号等 Content-Type：文档类型，指定返回的数据类型是什么就返回什么类型 Set-Cookie：设置Cookies。响应头中的Set-Cookie告诉浏览器需要将此内容放在Cooikes中，下次请求携带Cookies请求 Expires：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如再次访问时，就可以直接从缓存中加载。 响应体（Response Body）：响应的正文数据都在响应体重，比如请求网页时，它的响应就是网页的HTML代码。爬虫请求网页后，要解析的内容就是响应体。 2.2 网页基础 网页可以分成三大部分：HTML、CSS和JavaScript HTML（Hyper Text Markup Language，即超文本标记语言）：是用来描述网页的一种协议 CSS（Cascading Sytle Sheet，即层叠样式表）：“层叠”是指当在HTML中引用了数个样式文件，并且样式发生冲突时，浏览器能依据层叠顺序处理。“样式”指网页中文字大小、颜色、元素间距、排列等格式 JavaScript：简称JS，是一种脚本语言。HTML和CSS配合使用，提供给用户的只是一种静态信息，缺乏交互性。网页里的交互和动画效果，通常都是JavaScript的功劳。它的出现使得用户与信息之间不只是一种浏览与显示的关系，而是实现了一种实时、动态、交互的页面功能。 网页的结构 12345678910111213141516171819202122232425&lt;!-- 定义文档类型 --&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;!-- head标签内定义了一些页面的配置和引用 --&gt; &lt;head&gt; &lt;!-- 指定网页编码为utf-8 --&gt; &lt;meta charset="utf-8"&gt; &lt;!-- 网页的标题 --&gt; &lt;title&gt;This is a Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- div标签定义了网页中的区块，id是container，id的内容在网页中是唯一的 --&gt; &lt;div id="container"&gt; &lt;!-- class所谓wrapper --&gt; &lt;div class="wrapper"&gt; &lt;h2&gt; Hello World &lt;/h2&gt; &lt;p&gt; Hello,This iis a paragraph. &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 节点树及节点间的关系：在HTML中，所有标签定义的内容都是节点，它们构成了HTML DOM树 DOM(Document Object Model)文档对象模型。它定义了访问HTML和XML文档的标准 W3C DOM标准被分为3个不同的部分 核心DOM：针对任何结构化文档的标准模型 XML DOM：针对XML文档的标准模型 HTML DOM：针对HTML文档的标准模型 根据W3C的HTML DOM标准，HTML文档中的所有内容都是节点 整个文档是一个文档节点 每个HTML元素是元素节点 HTML元素内的文本是文本节点 每个HTML属性都是属性节点 注释是注释节点 节点树 节点树及节点之间的关系 CSS选择器的语法规则 节点树 节点树及节点之间的关系 CSS选择器的语法规则 2.3 爬虫的基本原理 爬虫概述：爬虫就是获取网页并提取和保存信息的自动化程序。 获取网页：获取网页的源代码，并从源代码中提取想要的信息 提取信息：分析网页源代码，从中提取我们想要的数据。 正则表达式提取，这是一个万能的方法，但是在构造时比较复杂且易出错。 根据网页节点属性、CSS选择器或XPath来提取网页信息的库：如Beautiful Soup、pyquery、lxml。 保存数据：可以简单保存为文本或JSON文本，也可以保存到数据库，如MySQL和MongoDB等，也可以保存至远程服务器。 自动化程序：爬虫可以替代我们来完成爬取工作的自动化程序，他可以在爬取过程中进行各种异常处理、错误重试等操作，以确保爬取持续高效地运行。 能抓怎样的数据：HTML源代码、二进制数据、JSON字符串等，只要在浏览器里面可以访问得到，就可以将其抓取下来。 JavaScript渲染页面 网页越来越多地采用Ajax、前端模块化工具来构建，整个网页可能都是由JavaScript渲染出来的，原始的HTML代码就是一个空壳。使用urlib或requests请求当前页面时，我们只能得到这个HTML代码，它不会帮助我们去继续加载这个JavaScript文件。 解决方法 分析Ajax接口 使用Selenium、Splash等库实现模拟JavaScript渲染 2.4 会话和Cookies无状态HTTPHTTP协议对事务处理是没有记忆能力的，即服务器不知道客户端是什么状态。当我们向服务器发送请求后，服务器解析请求，然后返回对应的响应，服务器负责完成这个过程，该过程是完全独立的，服务器不会记录前后状态的变化，缺少状态记录。若后续需要处理前面的信息，则必须重传，这导致需要额外传递一些前面的重复请求，才能获取后续响应。 会话和Cookies可以保持HTTP连接的状态，会话在服务端，Cookies在客户端。浏览器在下次访问网页时会自动附带上Cookies发送给服务器，服务器通过识别Cookies并鉴定出是哪个用户，然后再判断用户是否是登录状态，然后返回对应的响应。 会话和Cookies可以保持HTTP连接的状态，会话在服务端，Cookies在客户端。浏览器在下次访问网页时会自动附带上Cookies发送给服务器，服务器通过识别Cookies并鉴定出是哪个用户，然后再判断用户是否是登录状态，然后返回对应的响应。 会话：在Web中，会话对象用来存储特定用户会话所需的属性及配置信息。当用户在应用程序的Web也之间跳转存储在会话对象中的变量将不会丢失，而是在用户会话中一直存在下去。当用户请求来自应用程序的Web页时，如果该用户还没有会话，则Web服务器自动创建一个会话对象。当会话过期或被放弃后，服务器将终止该会话。 Cookies：Cookies指某些网站为了辨别用户身份、进行会话跟踪而存储在用户本地端上的数据。 会话维持 属性结构 Name：Cookies的名称，一旦创建不可更改 Value：该Cookies的值。如果值为Unicode字符，需要为字符编码。如果为二进制数据，则需要用BASE64编码 Domain：可以访问该Cookie的域名 Max Age：Cookie失效的时间，单位为秒，若为正数，则Cookie在Max Age秒之后失效。若为负数，关闭浏览器即失效。 Path：该Cookie的使用路径。若设置为/，则本域名下所有页面都可以访问该Cookie Size：Cookie的大小 HTTP：Cookie的httponly属性。若为True，则只有在HTTP头中带有此Cookie的信息，而不能通过document.cookie来访问此Cookie Secure：该Cookie是否仅被使用安全协议传输。安全协议有HTTPS和SSL等，在网络上传输数据之间先将数据加密。默认为false 常见误区 除非程序通知服务器删除一个会话，否则服务器会一直保留。 关闭浏览器不会导致会话被删除，这就需要服务器为会话设置一个失效时间，当距离客户端上一次使用会话的时间超过这个失效时间时，服务器就可以认为客户端已停止活动，然后才会将会话删除。 2.5 代理的基本原理基本原理代理实际上是指代理服务器，英文叫作proxy server，他的功能是代理网络用户去取得网络信息。形象地说，它是网络信息的中转站。如果设置了代理服务器，本机不是直接向Web服务器发起请求，而是向代理服务器发出请求，请求会发送给代理服务器，然后代理服务器再发送给Web服务器，接着由代理服务器再把Web服务器返回的响应转发给本机。&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 作用 突破IP访问限制，访问一些平时不能访问的站点 访问一些单位或团体内部资源：比如使用教育网内地址段免费代理服务器，就可以对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务 提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外接的信息通过时，同时也将其保存在缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息，传给用户，以提高访问速度。 隐藏真实IP 爬虫代理 作用 突破IP访问限制，访问一些平时不能访问的站点 访问一些单位或团体内部资源：比如使用教育网内地址段免费代理服务器，就可以对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务 提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外接的信息通过时，同时也将其保存在缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息，传给用户，以提高访问速度。 隐藏真实IP 爬虫代理 对于爬虫来说，由于爬虫爬取速度过快，在爬取过程中可能遇到同一个IP访问过于频繁的问题，此时网站就会让我们输入验证码登录后者直接封锁IP。 使用代理隐藏真实的IP，让服务器以为是代理服务器在请求自己。这样再爬取过程中通过不断更换代理，就不会被封锁。 代理分类 根据协议 FTP代理服务器：主要用于访问FTP服务器，一般有上传、下载及缓存功能，端口一般为21、2121等 HTTP代理服务器：主要用于访问网页，一般有内容过滤和缓存功能，端口一般为80、8080、3128 SSL/TLS代理：主要用于访问加密网站，一般有SSL或TLS加密功能（最高支持128位加密强度），端口一般为443 RTSP代理：主要用于访问Real流媒体服务器，一般有缓存功能，端口一般为554 Telnet代理：主要用于telnet远程控制（黑客入侵计算机时常用语隐藏身份），端口一般为23 POP3/SMTP代理：主要用户POP3/SMTP方式收发邮件，一般有缓存功能，端口一般为110/25 SOCKS代理：单纯传递数据包，速度快，一般有缓存功能，端口一般为1080 SOCKS4：只支持TCP SOCKS5：支持TCP和UDP，还支持各种身份验证机制、服务器域名解析等 根据匿名程度 高度匿名代理：数据包原封不动地转发 普通匿名代理：会在数据包上做一些改动，服务端有可能发现这个是代理服务器，也有一定几率追查到真实IP。代理服务器通常会加入的HTTP头有HTTP_VIA和HTTP_X_FORWARDED_FOR 透明代理：不但改动数据包，还有告诉服务器客户端的真实IP。这种代理除了能用缓存技术提高浏览速度，能将内容过滤提高安全性之外，并无其他显著作用，最常见的例子是内网中的硬件防火墙 间谍代理：指组织或个人创建的用于记录用户传输的数据，然后进行研究、监控等目的的代理服务器 常见代理设置 使用网上的免费代理 使用付费代理服务 ADSL拨号 三、基本库的使用3.1 使用urllib 官方文档 四个模块 request：最基本的HTTP请求模块，用来模拟发送请求 error：异常处理模块，若出现请求错误，可以捕获这些异常，然后进行重试或其他操作保证程序不会意外终止 parse：工具模块，提供URL处理方法，比如拆分、解析、合并等 robotparser：识别网站的robots.txt文件 发送请求 urlopen() urllib.request.urlopen(url,data=None,[timeout,]*,cafile=None,capath=None,cadefault=False,context=None) 1234567891011import urllib.requestresponse = urllib.request.urlopen('https://www.python.org')print(response.read().decode('utf-8'))# 输出为HTTPResponse类型对象，主要包含read()、readinto()、getheader(name)、getheaders()、fileno()等方法# msg、version、status、reason、debuglevel、closed属性等print(type(response))print(response.status)print(response.getheaders())print(response.getheader('Server')) data参数 timeout参数 其他参数 Request 12345import urllib.requestrequest = urllib.request.Request('https://python.org')response = urllib.request.urlopen(request)print(response.read().decode('utf-8')) 依然通过urlopen()方法来发送请求，但是该方法的参数不再是URL。而是一个request类型的对象。这样可以将请求独立成一个对象，也可以灵活地配置参数。 class urllib.request.Request(url,data=None,headers={},origin_req_host=None,unverifiable=False,method=None) url：用于请求URL，这是必传参数，其他都是可选参数。 data：必须传bytes(字节流)类型的参数。如果是字典，可以通过rullib.parse模块里的urlencode()编码。 headers：该参数是一个字典，它就是请求头，可以直接构造，也可以通过调用请求实例的add_headers()方法添加。 origin_req_host：指的是请求方的host名称或IP地址。 unverifiable：表示这个请求是否是无法验证的，默认是False。例如，我们请求一个HTML文档中的图片，但是我们没有自动抓取图像的权限，这时unverifiable的值就是True。 method：用来指示请求使用的方法，比如GET、POST和PUT等。 1234567891011121314151617from urllib import request,parseurl = 'http://httpbin.rog/post'headers = &#123; 'User-Agent':'...', 'Host':'httpbin.org'&#125;dict = &#123; 'name':'Germey'&#125;data = bytes(parse.urlencode(dict),encoding='utf-8')req = request.Request(url=urll,data=data,headers=headers,method='POST')# 使用add_headers()方法添加# req = request.Request(url=urll,data=data,method='POST')# req.add_headers('User-Agent','Mozilla/4.0...')response = request.urlopen(req)print(response.read().decode('utf-8')) 高级用法 处理异常 URLError HTTPError 解析链接 分析Robots协议 3.2 使用requests 安装 1$pip3 install requests 实例 123456789101112131415import requestsr = requests.get('https://www.baidu.com')r.encoding = r.apparent_encodingprint(type(r))print(r.status_code)print(type(r.text))print(r.text)print(r.cookies)r= requests.post('http://httpbin.org/post')r= requests.put('http://httpbin.org/put')r= requests.delete('http://httpbin.org/delete')r= requests.head('http://httpbin.org/get')r= requests.options('http://httpbin.org/get') GET请求 12345678910111213141516import requestsr = requests.get('http://www.httpbin.org/get')print(r.text)# 添加参数data = &#123; 'name':'germey', 'age':22&#125;r = requests.get('http://httpbin.org/get',params=data)print(r.text)# 直接解析返回结果，可以得到一个字典格式的结果print(r.json())print(type(r.json())) 抓取知乎发现页标题 12345678910import requestsimport reheaders = &#123; 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36'&#125;r = requests.get('https://www.zhihu.com/explore',headers=headers)pattern = re.compile('explore-feed.*?question_link.*?&gt;(.*?)&lt;/a&gt;',re.S)titles = re.findall(pattern,r.text)print(titles) 抓取二进制数据 123456import requestsr = requests.get('http://github.com/favicon')print(r.content)with open('pic.jpg','wb') as f: f.write(r.content) POST请求 123456import requestsdata = &#123;'name':'germey','age':22&#125;# 提交数据到form，说明POST请求成功r = requests.post('http://httpbin.org/post',data=data)print(r.text) 响应 123456789101112131415161718import requestsheaders = &#123; 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36'&#125;r = requests.get('http://www.jianshu.com',headers=headers)print(type(r.status_code),r.status_code)# headers属性得到的结果CaseInsensitiveDictprint(type(r.headers),r.headers)# cookies属性得到的结果RequestsCookieJarprint(type(r.cookies),r.cookies)print(type(r.url),r.url)print(type(r.history),r.history)# 内置的状态码查询对象requests.codesexit() if not r.status_code == requests.codes.ok else print('successs')# print('fault') if r.status_code == requests.codes.not_found else exit() 高级用法 文件上传 123456import requestsfiles = &#123;'file':open('favicon.icon','rb')&#125;r = requests.post('http://httpbin.org/post',files=files)print(r.text)print(r.status_code) Cookies设置 12345678910111213141516171819import requestsr = requests.get('https://www.baidu.com')print(r.cookies)for key,value in r.cookies.items(): print(key + '=' + value)# 利用Cookies维持登录状态import requestsheaders = &#123; 'Cookie':'......', 'Host':'www.zhihu.com', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36'&#125;r = requests.get('https://www.zhihu.com',headers=headers)print(r.text) 会话维持 使用Session对象维持会话，可以做到模拟同一个会话二不用担心Cookies的问题。通常用于模拟登录成功后再进行下一步的操作。 123456import requestss = requests.Session()s.get('http://httpbin.org/cookies/set/number/123456789')r = s.get('http://httpbin.org/cookies')print(r.text) SSL证书验证 1234567891011import requestsimport logging# from requests.packages import urllib3# 忽略警告# urllib3.disable_warnings()# 捕获警告到日志logging.captureWarnings(True)r = requests.get('https://www.12306.cn',verify=False)# 或指定本地证书用作客户端证书# ...print(r.status_code) 代理设置 12345678910import requests#proxies = &#123;# 'http':'http://10.10.1.10:3128',# 'https':'http://10.10.1.10:1080'#&#125;proxies = &#123; 'http':'http://user:password@10.10.1.10:3128/',&#125;requests.get('https://www.taobao.com',proxies=proxies) 超时设置 12345import requests# timeout=None则为永久等待，或直接不加参数r = requests.get('https://www.taobao.com',timeout = 1)print(r.status_code) 身份认证 1234import requestsr = requests.get('http:localhost:5000',auth=('username','password'))print(r.status_code) Prepared Requests 在requests中将请求表示为数据结构，这个数据结构就叫Prepared Requests 1234567891011121314from requests import Request,Sessionurl = 'http://httpbin.org/post'data = &#123; 'name':'germey'&#125;headers = &#123; 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36'&#125;s = Session()req = Request('POST',url,data=data,headers=headers)prepped = s.prepare_request(req)r = s.send(prepped)print(r.text) 3.3 正则表达式 常用匹配规则 | 模式 | 描述 || —— | ———————————————————— || \w | 匹配字母、数字及下划线 || \W | 匹配不是字母、数字及下划线的字符 || \s | 匹配任意空白字符，等价于[\t\n\r\f] || \S | 匹配任意非空字符 || \d | 匹配任意数字，等价于[0-9] || \D | 匹配任意非数字字符 || \A | 匹配字符串开头 || \Z | 匹配字符串结尾，若存在换行，只匹配到换行前的结束字符串 || \z | 匹配字符串结尾，若存在换行，同时还会匹配换行符 || \G | 匹配最后匹配完成的位置 || \n | 匹配一个换行符 || \t | 匹配一个制表符 || ^ | 匹配一行字符串的开头 || $ | 匹配一行字符串的结尾 || . | 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符 || […] | 用来表示一组字符串，单独列出，比如[amk]匹配a、m或k || [^…] | 不在[]中的字符，比如[^abc]匹配除了a、b、c之外的字符 || * | 匹配0个或多个表达式 || + | 匹配1个或多个表达式 || ? | 匹配0个或1个前面的正则表达式定义的片段，非贪婪方式 || {n} | 精确匹配n个前面的正则表达式 || {n,m} | 匹配n到m次由前面正则表达式定义的片段，贪婪方式 || a|b | 匹配a或b || () | 匹配括号内的表达式，页表示一个组 | match() match()会从字符串的起始位置匹配正则表达式，如果匹配，返回匹配成功的结果；若不匹配，则返回None 1234567891011import recontent = 'Hello 123 4567 World_This is a Regex Demo'print(len(content))result = re.match('^Hello\s\d\d\d\s\d&#123;4&#125;\s\w&#123;10&#125;',content)print(result)# group()可以输出匹配到的内容print(result.group())# span()输出匹配结果在原字符串中的的位置范围，print(result.span()) 匹配目标 可以使用括号()将想要提取的子字符串括起来。()实际上标记了一个表达式的开始和结束位置，被标记的每个子表达式会依次对应每一个分组，调用group()方法传入分组的索引即可获取提取的结果 1234567import reresult = re.match('^Hello\s(.*?)\sWorld',content)print(result)print(result.group())print(result.group(1))print(result.span()) 通用匹配 1234567import re# .*可以匹配任意字符result = re.match('^Hello.*Demo$',content)print(result)print(result.group())print(result.span()) 贪婪与非贪婪 12345678910111213141516171819202122import re# 运行结果只得到7，在贪婪匹配中，.*会匹配尽可能多的字符，\d+代表至少一个数字，# 所以.*尽可能的匹配多的字符，因此只留下一个可满足条件的数字7result = re.match('^He.*(\d+).*Demo$',content)print(result)print(result.group(1))# .*?是非贪婪匹配，就是尽可能匹配少的字符result = re.match('^He.*?(\d+).*Demo$',content)print(result)print(result.group(1))content = 'http://weibo.com/comment/kEraCN'result1 = re.match('http.*?comment/(.*?)',comment)result2 = re.match('http.*?comment/(.*)',comment)print('result1',result1.group(1))print('result2',result1.group(2))# 运行结果为# result1# result2 kEraCN# .*?没有匹配到任何结果，.*尽量匹配多的内容，因此成功匹配 修饰符 12345678910import recontent = ''''Hello 1234567 World_This is a Regex Demo'''# 运行报错，因为这个正则表达式无法匹配到换行符，所以返回结果None# result = re.match('^He.*?(\d+).*?Demo$',content)# print((result.group(1)))# 添加re.S即可修正此错误，这个修饰符可以匹配包括换行符在内的所有字符result = re.match('^He.*?(\d+).*?Demo$',content，re.S)print((result.group(1))) | 修饰符 | 描述 || —— | ———————————————————- || re.I | 使匹配对大小写不敏感 || re.L | 做本地化识别匹配 || re.M | 多行匹配，影响^和$ || re.S | 使.匹配包括换行在内的所有字符 || re.U | 根据Unicode字符集解析字符。这个标志影响\w、\W、\b、\B || re.X | 该标志通过给予更灵活的格式以便你将正则表达式写得更易于理解 | 转义匹配 若目标字符串里包含.,，则需要用到转义匹配 12345import recontent = '(百度)www.baidu.com'result = re.match('\(百度\)www\.baidu\.com',content)print(result) search() match()方法是从字符串的开头开始匹配的，一旦开头不匹配，name整个匹配就失败了。search()在匹配时会扫描整个字符串，然后返回第一个成功匹配的结果。若搜索完成还未找打，则返回None 123456789import recontent = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'result = re.match('Hello.*?(\d+).*?Demo',content)print(result)# Noneresult = re.search('Hello.*?(\d+).*?Demo',content)print(result) 1234567891011121314151617181920212223242526272829303132333435import rehtml = ''' &lt;div id="songs-list"&gt; &lt;h2 class="title"&gt;经典老歌&lt;/h2&gt; &lt;p class="introduction"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id="list" class="list-group"&gt; &lt;li data-view="2"&gt;一路有你&lt;/li&gt; &lt;li data-view="7"&gt; &lt;a&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view="4" class="active"&gt; &lt;a href="/5.mp3" singer="齐秦"&gt;随风往事&lt;/a&gt; &lt;/li&gt; &lt;li data-view="6"&gt; &lt;a href="/5.mp3" singer="beyond"&gt;光辉岁月&lt;/a&gt; &lt;/li&gt; &lt;li data-view="5"&gt; &lt;a href="/5.mp3" singer="陈慧琳"&gt;记事本&lt;/a&gt; &lt;/li&gt; &lt;li data-view="5"&gt; &lt;a href="/.6mp3" singer="邓丽君"&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;'''result = re.search('&lt;li.*?active.*?singer="(.*?)"&gt;(.*?)&lt;/a&gt;',html,re.S)print(result.group(1),result.group(2))# 若不加activeresult = re.search('&lt;li.*?singer="(.*?)"&gt;(.*?)&lt;/a&gt;',html,re.S)# 则返回匹配的第一条结果 findall() findall()会搜索整个字符串，然后返回匹配正则表达式的所有内容，返回的是列表类型 123456result = re.findall('&lt;li.*?href="(.*?)".*?singer="(.*?)"&gt;(.*?)&lt;/a&gt;',html,re.S)print(type(result))for result in result: print(result)# 返回的列表中的每个元素都是元祖类型，用对应的索引一次取出即可。 sub() 除了使用正则表达式提取信息外，有时候还需要借助它来修改文本。 123456789101112import recontent = '54aK54yr5oiR54ix5L2g'# 第一个参数\d+用来匹配所有的数字，第二个参数为替换成的字符串，第三个参数为原字符串content = re.sub('\d+','',content)# 上面的HTML文本也可以直接使用正则表达式修改之后再进行提取，就会简单很多了result = re.sub('&lt;a.*?&gt;|&lt;/a&gt;','',html)print(result)results = re.findall('&lt;li.*?&gt;(.*?)&lt;/li&gt;',result,re.S)for result in results: print(result.strip()) compile() compile()可以将正则字符串编译成正则表达式对象，以便在后面的匹配中复用 1234567891011import recontent1 = '2016-12-15 12:00'content2 = '2016-12-17 12:55'content3 = '2016-12-22 13:21'# 还可以将修饰符传入，这样在search()、findall()方法中就不需要额外传了pattern = re.compile('\d&#123;2&#125;:\d&#123;2&#125;')result1 = re.sub(pattern,'',content1)result2 = re.sub(pattern,'',content2)result3 = re.sub(pattern,'',content3)print(result1,result2,result3) 3.4 抓取猫眼电影排行 目标：提取出猫眼电影TOP100的电影名称、时间、评分、图片等信息，提取的站点URL为http://maoyan.com/board/4，提取结果 会以文件形式保存下来。 分析 目标站点：http://maoyan.com/board/4 第二页：http://maoyan.com/board/4?offset=10 抓取首页实现get_one_page(url) 正则表达式提取： 1'\&lt;dd&gt;.*?board-index.*?&gt;(.*?)\&lt;/i&gt;.*?data-src="(.*?)".*?name.*?a.*?&gt;(.*?)\&lt;/a&gt;.*?"star".*?&gt;(.*?)\&lt;/p&gt;.*?"releasetime".*?&gt;(.*?)\&lt;/p&gt;.*?"integer".*?&gt;(.*?)\&lt;/i&gt;.*?"fraction".*?&gt;(.*?)\&lt;/i&gt;.*?\&lt;/dd&gt;' 写入文件 分页爬取 运行代码 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import requestsimport refrom requests.exceptions import RequestExceptionimport jsonfrom multiprocessing import Pooldef get_one_page(url): try: headers = &#123; 'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36' &#125; response = requests.get(url,headers=headers) if response.status_code == 200: return response.text return None except RequestException: return Nonedef parse_one_page(html): pattern = re.compile('&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;/i&gt;.*?data-src="(.*?)".*?name.*?a.*?&gt;(.*?)&lt;/a&gt;.*?"star".*?&gt;(.*?)&lt;/p&gt;.*?"releasetime".*?&gt;(.*?)&lt;/p&gt;.*?"integer".*?&gt;(.*?)&lt;/i&gt;.*?"fraction".*?&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;',re.S) items = re.findall(pattern,html) for item in items: yield &#123; 'index':item[0], 'image':item[1], 'title':item[2], 'actor':item[3].strip()[3:], 'time':item[4].strip()[5:], 'score':item[5] + item[6] &#125;def write_to_file(content): with open('result.txt','a',encoding='utf-8') as f: f.write(json.dumps(content,ensure_ascii=False) + '\n') f.close()def main(offset): url = 'http://maoyan.com/board/4?offset=' + str(offset) html = get_one_page(url) for item in parse_one_page(html): write_to_file(item) print(item) # print(html)if __name__ == '__main__': pool = Pool() pool.map(main,[i * 10 for i in range(10)]) 练习：抓取豆瓣top250电影排行12345678910111213141516171819202122232425262728293031323334353637383940414243444546import requestsfrom requests.exceptions import RequestExceptionimport reimport jsonfrom multiprocessing import Pooldef get_one_page(url): try: headers = &#123; 'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36' &#125; response = requests.get(url,headers=headers) if response.status_code == 200: return response.text return None except RequestException: return Nonedef parse_one_page(html): pattern = re.compile('&lt;li&gt;.*?class=""&gt;(.*?)&lt;/em&gt;.*?"title"&gt;(.*?)&lt;/span&gt;.*?average"&gt;(.*?)&lt;/span&gt;.*?inq"&gt;(.*?)&lt;/span&gt;.*?&lt;/li&gt;',re.S) items = re.findall(pattern,html) for item in items: yield &#123; 'index':item[0], 'title':item[1], 'score':item[2], 'quote':item[3] &#125;def write_to_file(content): with open('douban.txt','a',encoding='utf-8') as f: f.write(json.dumps(content,ensure_ascii=False) + '\n') f.close()def main(start): url = "https://movie.douban.com/top250?start=" + str(start) html = get_one_page(url) for item in parse_one_page(html): # print(item) write_to_file(item)if __name__ == '__main__': # for i in range(10): # main(i * 25) pool = Pool() pool.map(main, [i * 25 for i in range(10)]) 四、解析库的使用4.1 使用XPath 常用规则 | 表达式 | 描述 || ——– | ———————— || nodename | 选取此节点的所有子节点 || / | 从当前节点选取直接子节点 || // | 从当前节点选取子孙节点 || . | 选取当前节点 || .. | 选取当前节点的父节点 || @ | 选取属性 | 栗子：//title[@lang=’eng’] —— 代表选择所有名称为title，同时属性lang的值为eng的节点 实例 123456789101112131415161718from lxml import etreetext = '''&lt;div&gt; &lt;ul&gt; &lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;div&gt;'''html = etree.HTML(text)# tostring输出结果为bytes类型，这里利用decode()方法将其转成str类型result = etree.tostring(html)print(result.decode('utf-8')) 所有节点 我们一般会用//开头的XPath规则来选取所有符合要求的节点。 123456789101112from lxml import etreehtml = etree.HTML(text)# 这里的*代表匹配所有节点，即整个HTML文本中的所有节点都会被获取result = html.xpath('//*')print(result)html = etree.HTML(text)# 这里选取所有li节点，直接在//后加上节点名称即可result = html.xpath('//li')print(result)print(result[0]) 子节点 通过/或//即可查找子节点或子孙节点 12345678910from lxml import etreehtml = etree.HTML(text)# 选择li节点的所有直接a子节点result = html.xpath('//li/a')print(result[0].text)html = etree.HTML(text)result = html.xpath('//ul//a')print(result) 父节点 通过..可以查找父节点 12345678910from lxml import etreehtml = etree.HTML(text)result = html.xpath('//a[@href="link4.html"]/../@class')print(result)html = etree.HTML(text)# 也可以通过parent::获取父节点result = html.xpath('//a[@href="link4.html"]/parent::*/@class')print(result) 属性匹配 可以用@符号进行属性过滤 12345from lxml import etreehtml = etree.HTML(text)result = html.xpath('//li[@class="item-0"]')print(result) 文本获取 XPath中的text()方法可以获取节点中的文本 123456789101112# 先选取a节点再获取文本html = etree.HTML(text)result = html.xpath('//li[@class="item-0"]/a/text()')print(result)# 使用//html = etree.HTML(text)result = html.xpath('//li[@class="item-0"]//text()')print(result)# 直接用//加text()的方式，可以保证获取到最全面的文本信息，但是可能会夹杂一些换行符等特殊字符# 如果想要获取某些特定子孙节点下的所有文本，可以先选取到特定的子孙节点，再调用text()方法获取其内部文本，这样可以保证获取到的结果是整洁的 属性获取 123html = etree.HTML(text)result = html.xpath('//li/a/@href')print(result) 属性多值匹配 12345678from lxml import etreetext = '''&lt;li class="li li-first"&gt;&lt;a href="link.html"&gt;first item&lt;/a&gt;&lt;/li&gt;'''html = etree.HTML(text)result = html.xpath('//li[contains(@class,"li")]/a/text()')print(result) 多属性匹配 需要同时匹配多个属性，可以使用运算符and来连接 123456789from lxml import etreetext = '''&lt;li class="li li-first" name="item"&gt;&lt;a href="link.html"&gt;first item&lt;/a&gt;&lt;/li&gt;'''html = etree.HTML(text)result = html.xpath('//li[contains(@class,"li") and @name="item"]/a/text()')print(result) | 运算符 | 描述 | 实例 | 返回值 || —— | ————– | —————— | ——————————– || or | 或 | age=19 or age=20 | 19-true,21-false || and | 与 | age&gt;19 and age &lt;21 | 20-true,22-false || mod | 除法的余数 | 5 mod 2 | 1 || | | 计算两个节点集 | //book | //cd | 返回所有拥有book和cd元素的节点集 || + | 加法 | 6+4 | 10 || - | 减法 | 6-4 | 2 || | 乘法 | 64 | 24 || div | 除法 | 8 div 4 | 2 || = | 等于 | age=19 | 19-true,20-false || != | 不等于 | age!=19 | 19-false,18-true || &lt; | 小于 | age&lt;19 | 19-false,18-false || &lt;= | 小于或等于 | age&lt;=19 | 19-true,20-false || &gt; | 大于 | age&gt;19 | 19-false,21-true || &gt;= | 大于或等于 | age&gt;=19 | 19-true,18-false | 按序选择 1234567891011121314151617181920212223from lxml import etreetext = '''&lt;div&gt; &lt;ul&gt; &lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;div&gt;'''html = etree.HTML(text)result = html.xpath('//li[1]/a/text()')print(result)result = html.xpath('//li[last()]/a/text()')print(result)result = html.xpath('//li[last()-2]/a/text()')print(result)result = html.xpath('//li[position()&lt;3]/a/text()')print(result) 节点轴选择 12345678910111213141516171819202122232425262728293031323334from lxml import etreetext = '''&lt;div&gt; &lt;ul&gt; &lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;div&gt;'''html = etree.HTML(text)# ancestor可以获取祖先节点，其后需要跟两个冒号，*匹配所有节点result = html.xpath('//li[1]/ancestor::*')print(result)result = html.xpath('//li[1]/ancestor::div')print(result)# attribute获取所有属性值result = html.xpath('//li[1]/attribute::*')print(result)# child获取所有直接子节点result = html.xpath('//li[1]/child::a[@href="link1.html"]')print(result)# descendant可以获取所有子孙节点result = html.xpath('//li[1]/descendant::span')print(result)# following可以获取当前节点之后的所有节点，可以使用索引result = html.xpath('//li[1]/following::*[2]')print(result)# following-sibling可以获取当前节点之后的所有同级节点result = html.xpath('//li[1]/following-sibling::*')print(result) 更多参考 4.2 使用BeautifulSoupBeautiful Soup就是Python的一个HTML或XML的解析库，可以用它来方便地从网页中提取数据 基本用法 123456789101112131415161718192021222324252627282930html = '''&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p class="title" name="dromouse"&gt; &lt;b&gt;The Dormouse's story&lt;/b&gt; &lt;/p&gt; &lt;p class="story"&gt; Once upon a time there were three little sisters;and their names were &lt;a href="http://example.com/elsie" class="sister" id="link1"&gt; &lt;!-- Elsie --&gt; &lt;/a&gt;, &lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and &lt;a href="http://example.com/tillie" class="sister" id="link2"&gt;Tillie&lt;/a&gt;; and they lived at the bottom of a well.&lt;/p&gt; &lt;/p&gt; &lt;p class="story"&gt; ... &lt;/p&gt;&lt;/html&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html,'lxml')print(soup.prettify())print(soup.title.string) 节点选择器 选择元素 123456print(soup.title)print(type(soup.title))print(soup.title.string)print(soup.head)# 当存在多个节点，这种选择方式只会选择第一个匹配的节点print(soup.p) 提取信息 获取名称 获取属性 获取内容 123456print(soup.title.name)print(soup.p.attrs)print(soup.p.attrs['name'])print(soup.p.b.string) 嵌套选择 123print(soup.head.title)print(type(soup.head.title))print(soup.head.title.string) 关联选择 —— 先选中某一节点元素，然后以它为基准再选择它的子节点、父节点、兄弟节点等 子节点和孙节点 方法选择器 CSS选择器 4.3 使用pyquery五、数据存储5.1 文件存储TXT存储 实例：保存知乎上“发现”页面的“热门话题”部分，将其问题和答案统一保存成文本形式 使用requests获取网页源代码，使用pyquery解析库解析 123456789101112131415161718192021import requestsfrom pyquery import PyQuery as pqurl = 'https://www.zhihu.com/explore'headers = &#123; 'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36'&#125;html = requests.get(url,headers=headers).textfile_html = open('explore.html','a',encoding='utf-8')file_html.write(html)file_html.close()doc = pq(html)items = doc('.explore-tab .feed-item').items()for item in items: question = item.find('h2').text() author = item.find('.author-link-line').text() answer = pq(item.find('.content').html()).text() file = open('explore.txt','a',encoding='utf-8') file.write('\n'.join([question,author,answer])) file.write('\n' + '=' * 50 + '\n') file.close() 打开方式 r：以只读方式打开文件，文件指针将会放在文件的开头，默认模式 rb：以二进制只读方式打开，指针放在开头 r+：以读写方式打开。指针放在开头 rb+：以二进制读写方式打开，指针放在开头 w：以写入方式打开，若文件已存在，则覆盖，若文件不存在，则创建新的文件 wb：以二进制写入方式打开，则覆盖，若文件不存在，则创建新的文件 w+：以读写方式打开，若文件已存在，则覆盖，若文件不存在，则创建新的文件 wb+：以二进制读写方式打开，若文件已存在，则覆盖，若文件不存在，则创建新的文件 a：以追加方式打开，若该文件已存在，文件指针将会放在文件结尾。即新的内容会被写入到已有内容之后，若文件不存在，则创建新的文件写入 ab：以二进制追加方式打开，若该文件已存在，文件指针将会放在文件结尾。即新的内容会被写入到已有内容之后，若文件不存在，则创建新的文件写入 a+：以读写方式打开一个文件，若该文件已存在，文件指针将会放在文件结尾。文件打开时会是追加模式，若文件不存在，则创建新的文件写入 ab+：以二进制追加方式代开，若该文件已存在，文件指针将会放在文件结尾。即新的内容会被写入到已有内容之后，若文件不存在，则创建新的文件写入 简化写法 with as语法，在with控制块结束时，文件会自动关闭，就不需要再调用close()方法了 123with open('explore.txt','a',encoding='utf-8') as file: file.write('\n'.join([question,author,answer])) file.write('\n' + '=' *50 + '\n') JSON文件存储 JSON，全称JavaScript Object Notion，也就是JavaScript对象标记，它通过对象和数组的组合来表示数据，是一种轻量级的数据交换格式。 对象和数组 对象：使用{}包裹起来的内容，数据结构为{key1:value1,key2:value2,…}的键值对结构。在面向对象的语言中，key为对象的属性，value为对应的值。键名可以使用整数和字符串表示。值得类型可以使任意类型。 数组：使用[]包裹起来的内容，数据结构为[“java”,”javascritpt”,”vb”,…]的索引结构。在JavaScript中，数组是一种比较特殊的数据类型，它也可以像对象那样使用键值对，但还是索引用的多。同样，值可以是任意类型。 123456789101112[ &#123; "name":"bob", "gender":"male", "birthday":"today" &#125;, &#123; "name":"selina", "gender":"female", "birthday":"tomorrow" &#125;] 读取JSON：通过dumps()方法将JSON对象转为文本字符串 1234567891011121314151617181920212223242526272829303132import jsonstr = '''[ &#123; "name":"bob", "gender":"male", "birthday":"today" &#125;, &#123; "name":"selina", "gender":"female", "birthday":"tomorrow" &#125;]'''print(type(str))data = json.loads(str)print(data)print(type(json))#添加索引获得字典元素，通过调用键名即可得到键值data[0]['name']data[0].get('name')data[0].get('age') # Nonedata[0].get('age',25) # default value = 25# 从JSON文本读取内容with open('data.json','r') as file: str = file.read() data = json.loads(str) print(data) JSON的数据需要用双引号来保卫，不能使用单引号，否则会出现JSONDecodeError错误 输出JSON：调用dumps()方法将JSON对象转换为字符串 12345678910import jsondata = [&#123; 'name':'王伟', 'gender':'male', 'birthday':'19920825'&#125;]# 为了输出中文，还需要指定参数ensure_ascii=False,参数indent，代表缩进字符个数，另外还要规定文件输出的编码with open('data.json','w',encoding='utf-8') as file: file.write(json.dumps(data,indent=2,ensure_ascii=False)) CSV文件存储 CSV，全称Comma-Separated Values，中文可以叫作逗号分隔值或字符分隔值，其文件以纯文本形式存储表格数据。该文件是一个字符序列，可以由任意数目的记录组成，记录间以某种换行符分隔。 写入 1234567891011121314151617import csv# delimiter可以修改列与列之间的分隔符，writerrows可以同时写入多行，此时参数就需要为二位列表with open('data.csv','w') as csvfile: writer = csv.writer(csvfile,delimiter=' ') writer.writerrow('id','name','age') writer.writerrows([['1001','mike',20],['1002','bob',22]])# 写入字典import csvwith open('data.csv','w',encoding='utf-8') as csvfile: fieldnames = ['id','name','age'] writer = csv.DictWriter(csvfile,fieldnames=fieldnames) writer.writeheader() writer.writerow(&#123;'id':'1001','name':'mike','age':20&#125;) writer.writerows([&#123;'id':'1002','name':'bob','age':21&#125;,&#123;'id':'1003','name':'du','age':25&#125;]) 读取 这里构造的Reader对象，通过遍历输出了每行的内容，每一个行都是一个列表形式。如果文件中包含中文的话，还需要指定文件编码。 1234with open('data.csv','r',encoding='utf-8') as csvfile: reader = csv.reader(csvfile) for row in reader: print(row) 也可以使用pandas中的read_csv()方法将数据从CSV中读取出来 1234import pandas as pddf = pd.read_csv('data.csv')print(df) 5.2 关系型数据库存储 关系型数据库是基于关系模型的数据库，关系模型是通过二维表来保存的，所以它的存储方式就是行列组成的表，每一列就是一个字段，每一行就是一条记录。表可以看作某个实体的集合，而实体之间也存在联系，这就需要表与表之间的联系关系来体现，如主键外键的关联关系。多个表组成一个数据库，也就是关系型数据库。 关系型数据库有多种，如SQLite、MySQL、Oracle、SQL Server、DB2等。 MySQL存储 连接数据库 12345678910111213import pymysql# 通过PyMySQL的connect()方法声明一个MySQL连接duixiangdbdb = pymysql.connect(host='localhost',user='root',password='',port=3306)# 连接成功后调用cursor()获取MySQL的操作游标cursor = db.cursor()# execute()方法执行sql语句cursor.execute('SELECT VERSION()')# 返回执行结果data = cursor.fetchone()print('Database version:',data)cursor.execute('CREATE DATABASE spiders DEFAULT CHARACTER SET UTF8')db.close() 创建表 12345678import pymysql# 代码格式化 command + alt + Ldb = pymysql.connect(host='localhost', user='root', password='', port=3306, db='spiders')cursor = db.cursor()sql = 'CREATE TABLE IF NOT EXISTS students (id VARCHAR(255) NOT NULL ,name VARCHAR(255) NOT NULL,age INT NOT NULL,PRIMARY KEY (id))'cursor.execute(sql)db.close() 插入数据 123456789101112131415161718192021import pymysqlid = '20120001'user = 'bob'age = 20db = pymysql.connect(host='localhost', user='root', password='', port=3306, db='spiders')cursor = db.cursor()# 使用构造SQL语句：sql = 'INSERT INTO student(id,name,age) values(' + id + ', ' + name + ', ' + age + ')'# 使用格式化符%s实现，可以避免字符串拼接的麻烦，又可以避免引号冲突的问题sql = 'INSERT INTO students(id,name,age) values(%s,%s,%s)'try: cursor.execute(sql,(id,user,age)) # 需要执行db对象的commit()方法才可实现数据插入，该方法可以将语句提交到数据库执行的方法 # 对于数据插入、更新、删除操作，都需要调用该方法才能生效 db.commit()except: # 如果执行失败，则调用rollback()执行数据回滚 db.rollback()finally: db.close() 事务的4个属性（ACID） | 属性 | 解释 || :——————-: | :———————————————————– || 原子性（atomicity） | 事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做 || 一致性（consistency） | 事务必须使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的 || 隔离性（isolation） | 一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能相互干扰 || 持久性（durability） | 持久性也称永久性（permanence），指一个事务一旦提交，它对数据库的改变就应该是永久的。接下来的其他操作或故障不应该对其有任何影响 | 1234567891011121314151617181920212223import pymysqldb = pymysql.connect(host='localhost', user='root', password='', port=3306, db='spiders')cursor = db.cursor()# 优化data = &#123; 'id':'20120002', 'name':'bob', 'age':20&#125;table = 'students'keys = ', '.join(data.keys())values = ', '.join(['%s'] * len(data))sql = 'INSERT INTO &#123;table&#125;(&#123;keys&#125;) VALUES (&#123;values&#125;)'.format(table=table,keys=keys,values=values)try: if cursor.execute(sql,tuple(data.values())): print('successful') db.commit()except: print('failed') db.rollback()finally: db.close() 更新数据 1234567891011121314151617181920212223242526272829303132import pymysqldb = pymysql.connect(host='localhost', user='root', password='', port=3306, db='spiders')cursor = db.cursor()data = &#123; 'id':'20120001', 'name':'bob', 'age':25&#125;table = 'students'keys = ', '.join(data.keys())values = ', '.join(['%s'] * len(data))# ON DUPLICATE KEY UPDATE 如果主键存在，就执行更新操作sql = 'INSERT INTO &#123;table&#125;(&#123;keys&#125;) VALUES(&#123;values&#125;) ON DUPLICATE KEY UPDATE'.format(table=table,keys=keys,values=values)update = ','.join([" &#123;key&#125; = %s".format(key = key) for key in data])sql += update# 若执行更新操作，则sql语句就是# INSERT INTO students(id, name, age) VALUES(%s, %s, %s) ON DUPLICATE KEY UPDATE id = %s, name = %s, age = %s# 这里就变成了6个%s，所以在后面的excute()方法的第二个参数元组就需要乘以2编程原来的2倍try: print(sql) if cursor.execute(sql,tuple(data.values()) * 2): print('successful') db.commit()except: print('failed') db.rollback()finally: db.close() 删除数据 123456789101112table = 'students'condition = 'age &gt; 20'# 因为删除条件有多种多样，所以不再继续构造复杂的判断性。这里之间将条件当做字符串来传递，以实现删除操作sql = 'DELETE FROM &#123;table&#125; WHERE &#123;condition&#125;'.format(table=table,condition=condition)try: cursor.excute(sql) db.commit()except: db.rollback()finally: db.close 查询数据 12345678910111213141516171819202122232425262728import pymysqldb = pymysql.connect(host='localhost', user='root', password='', port=3306, db='spiders')cursor = db.cursor()sql = 'SELECT * FROM students WHERE age &gt;= 19'try: cursor.execute(sql) print('Count:',cursor.rowcount) # 内部有一个偏移指针用来指向查询结果，最开始偏移指针指向第一条数据，取一次以后，指针指向下一条数 据，这样再取得话，就会取到下一条数据 # one = cursor.fetchone() # print('One:',one) result = cursor.fetchall() print('Result:',result) print('Result Type:',type(result)) for row in result: print(row)except: print("Error")finally: db.close()# 结果：Count: 2One: ('20120001', 'bob', 25)Result: (('20120002', 'bob', 20),)Result Type: &lt;class 'tuple'&gt;('20120002', 'bob', 20) 非关系型存储 NoSQL，全称Not Only SQL，意为不仅仅是SQL，泛指非关系型数据库。NoSQL是基于键值对的，而且不需要经过SQL层的解析，数据之间没有耦合性，性能非常高。 分类 键值存储数据库：Redis、Voldemort和Oracle BDB等 列存储数据库：Cassandra、HBase和Riak等 文档型数据库：CouchDB和MongoDB等 图形数据库：Neo4J、InfoGrid和Infinite Graph等 MongoDB存储 连接MongoDB，连接数据库并插入、查询数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import pymongofrom pymongo import MongoClient# 连接数据库client = MongoClient('mongodb://localhost:27017/')# client = pymongo.MongoClient(host='localhost',prot=27017)# 指定数据库，两种方式等价# db = client.testdb = client['test']# 指定集合# collection = db.studentcollection = db['student']# 插入数据student = &#123; 'id':'20170101', 'name':'jordan', 'age':20, 'gender':'male'&#125;student1 = &#123; 'id':'20170102', 'name':'mike', 'age':20, 'gender':'male'&#125;student2 = &#123; 'id':'20170103', 'name':'du', 'age':20, 'gender':'male'&#125;# 插入一条数据并返回_id值# result = collection.insert_one(student)# print(result.inserted_id)# 插入多条数据# result = collection.insert_many([student1,student2])# print(result.inserted_ids)# 查询数据 利用find_one()或find()方法进行查询result = collection.find_one(&#123;'name':'mike'&#125;)print(type(result))print(result)results = collection.find(&#123;'age':20&#125;)print(results)for r in results: print(r)# 查询年龄大于20的数据results = collection.find(&#123;'age':&#123;'$gt':19&#125;&#125;)print(results)for r in results: print(r) 查询符号表 计数 12345count = collection.find().count()print(count)count = collection.find(&#123;'age':20&#125;).count()print(count) 排序 123# 升序：pymongo.ASCENDING 降序：pymongo.DESCENDINGresults = collection.find.sort('name',pymongo.ASCENDING)print([result['name'] for result in results]) 偏移 1234567# 忽略前两个元素results = collection.find().sort('name',pymongo.ASCENDING).skip(2)print([result['name'] for result in results])# 忽略前两个元素并只取2个元素结果results = collection.find().sort('name',pymongo.ASCENDING).skip(2).limit(2)print([result['name'] for result in results]) 更新 1234567891011121314151617181920212223# 更新数据condition = &#123;'name':'du'&#125;student = collection.find_one(condition)student['age'] = 25# 建议使用update_one或update_many# result = collection.update(condition,student)# 也可以使用$set操作符对数据进行更新，这样可以只更新student字典内存在的字段，如果原先还有其他字段，则不会更新也不会删除。# result = collection.update(condition,&#123;'$set':student&#125;)print(result)condition = &#123;'name':'mike'&#125;student = collection.find_one(condition)student['age'] = 26result = collection.update_one(condition,&#123;'$set':student&#125;)print(result)print(result.matched_count,result.modified_count)condition = &#123;'age':&#123;'$gt':20&#125;&#125;# 第一条符合条件的年龄+1# result = collection.update_one(condition,&#123;'$inc':&#123;'age':1&#125;&#125;)result = collection.update_many(condition,&#123;'$inc':&#123;'age':1&#125;&#125;)print(result)print(result.matched_count,result.modified_count) 删除 1234567# 删除result = collection.delete_one(&#123;'name':'mike'&#125;)print(result)print(result.deleted_count)result = collection.delete_many(&#123;'age':20&#125;)print(result)print(result.deleted_count) 其他方法 find_one_and_delete()、finde_one_and_replace()和find_one_and_update()等 create_index()、create_indexes()和drop_index()等 操作指南：https://docs.mongodb.com/guides/ PyMongo官方文档：http://api.mongodb.com/python/current/api/pymongo/collection.html Redis存储 Redis是一个基于内存的高效的键值型非关系型数据库，存取效率极高，而且支持多种存储数据结构，使用简单。 启动redis服务端 1234# 启动redis数据库服务端redis-server# 使用密码启动redis客户端redis-cli -a 1234 Redis和StrictRedis redis-py库提供两个类Redis和StrictRedis来实现Redis的命令操作（官方推荐使用StrictRedis） 连接Redis 12345678910111213141516171819202122232425from redis import StrictRedis,ConnectionPool# 使用ConnectionPool连接pool = ConnectionPool(host='localhost',port=6379,db=0,password='1234')''''# ConnectionPool还支持通过URL来构建# Redis TCP连接redis://[:passwrod]@host:port/db# Redis TCP+SSL连接rediss://[:passwrod]@host:port/db# Reids UNIX socket连接unix://[:password]@path/to/socket.sock?db=dburl = 'redis://:1234@localhost:6379/0'pool = ConnectionPoo;.from_url(url)redis = StrictRedis(connection_pool=pool)'''# redis = StrictRedis(host='localhost',port=6379,db=0,password='1234')redis = StrictRedis(connection_pool=pool)redis.set('name','duzhida')print(redis.get('name')) 六、Ajax数据爬取6.1 什么是Ajax什么是Ajax Ajax全称为Asynchronous JavaScript and XML，即异步的JavaScript和XML。它不是一门编程语言，而是利用JavaScript在保证页面不被刷新，页面链接不改变的情况下与服务器交换数据并更新部分网页的的技术。 基本原理 实例引入：很多网页都有下滑查看更多的选项，下滑页面会出现加载动画，一段时间过后才会出现新的内容，这个过程就是Ajax加载的过程。 发送Ajax请求到网页更新的过程分为以下3步： 发送请求 解析内容 渲染网页 发送请求 1234567891011121314151617// 这个JavaScript对Ajax最底层的实现，实际上就是新建了XMLHttpReequest对象，然后调用onreadystatechange属性设置了监听，然后调用open()和send()方法向某个链接(服务器)发送请求var xmlhttp;if(window.XMLHttpRequest)&#123; //code for IE7+,Firfox,Chrome,Opera,Safari xmlhttp = new XMLHttpRequest();&#125;else&#123; //code for IE6,IE5 xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");&#125;xmlhttp.onreadystatechange=function()&#123; if(xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200)&#123; document.getElementById("myDiv").innerHTML = xmlhttp.responseText; &#125;&#125;xmlhttp.open("POST","/ajax/",true);xmlhttp.send() 解析内容 得到相应之后，onreadystatechange属性对应的方法就会触发，此时利用xmlhttp的responseText属性便可取到响应内容。返回的内容可能是HTML，可能是JSON，接下来只需要在方法中用JavaScript进一步处理即可。 渲染网页 JavaScript有改变网页内容的能力，解析完响应内容之后，就可以调用JavaScript来针对解析完的内容对网页进行下一步处理。比如，通过document。getElementById().innerHTML就可以对元素内的源代码进行更改。这样网页显示的内容就改变了，这样的操作也被称为DOM操作。 6.2 Ajax分析方法 查看请求 XHR即是Ajax特殊的请求类型。 过滤请求 6.3 Ajax结果提取 分析请求 6.4 分析Ajax爬取今日头条街拍美图 抓取分析 目标：https://www.toutiao.com/search/?keyword=%E8%A1%97%E6%8B%8D 实战演练 1 Ajax分析方法 查看请求 过滤请求 七、动态渲染页面爬取7.1 Selenium的使用 Selenium是一个自动化测试工具，利用它可以驱动浏览器执行特定的动作，如点击、下拉等操作，同时还可以获取浏览器当前呈现的页面的源代码，做到可见既可爬。 安装selenium pip install selenium 安装chromedriver 下载地址 解压并移动到python安装目录下sudo mv chromedriver /usr/bin 配置ChromeDriver到$PATH 12export PATH="$PATH:/usr/local/chromedriver"source ~/.profile 输出Only local connections are allowed则配置完成 基本使用 1234567891011121314151617181920from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.wait import WebDriverWaitbrower = webdriver.Chrome()try: brower.get('https://www.baidu.com') input = brower.find_element_by_id('kw') input.send_keys('Python') input.send_keys(Keys.ENTER) wait = WebDriverWait(brower,1000) wait.until(EC.presence_of_element_located((By.ID,'content_left'))) print(brower.current_url) # print(brower.get_cookies()) # print(brower.page_source)finally: brower.close() 声明浏览器支持对象 1234567from selenium import webdriverbrowser = webdriver.Chrome()browser = webdriver.Firefox()browser = webdriver.Edge()browser = webdriver.PhantomJS()browser = webdriver.Safari() 访问页面 123456from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.taobao.com')print(browser.page_source)browser.close() 查找节点 单个节点，可以根据name、id获取，还可以根据XPath、CSS选择器等获取的方式 123456789101112131415161718192021from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.taobao.com')input_first = browser.find_element_by_id('q')input_second = browser.find_element_by_css_selector('#q')input_third = browser.find_element_by_xpath('//*[@id="q"]')print(input_first,input_second,input_third)browser.close()# 所有获取单个节点的方法browser.find_element_by_id()browser.find_element_by_name()browser.find_element_by_xpath()browser.find_element_by_link_text()browser.find_element_by_tag_name()browser.find_element_by_class_name()browser.find_element_by_css_selector()# 通用方法browser.find_element(By.ID,id) 多个节点 1234567891011121314151617181920from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.taobao.com')lis = browser.find_elements_by_css_selector('.service-bd li')print(lis)browser.close()# 所有获取多个节点的方法browser.find_elements_by_id()browser.find_elements_by_name()browser.find_elements_by_xpath()browser.find_elements_by_link_text()browser.find_elements_by_partial_link_text()browser.find_elements_by_tag_name()browser.find_elements_by_class_name()browser.find_elements_by_css_selector()# 通用方法browser.find_elements(By.ID,id) 节点交互 常见用法有：输入文字send_keys()方法，清空文字clear()方法，点击按钮click()方法 123456789101112from selenium import webdriverimport timebrowser = webdriver.Chrome()browser.get('https://www.taobao.com')input = browser.find_element_by_id('q')input.send_keys('iPhone')time.sleep(5)input.clear()input.send_keys('ipad')button = browser.find_element_by_class_name('btn-search')button.click() 官方文档 动作链 123456789101112from selenium import webdriverfrom selenium.webdriver import ActionChainsbrowser = webdriver.Chrome()url = 'http://www.runoob.com/try/try.php?filename=jqueryui-example-droppable'browser.get(url)browser.switch_to.frame('iframeResult')source = browser.find_element_by_css_selector('#draggable')target = browser.find_element_by_css_selector('#droppable')actions = ActionChains(browser)actions.drag_and_drop(source,target)actions.perform() 执行JavaScript 123456from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.zhihu.com/explore')browser.execute_script('window.scrollTo(0,document.body.scrollHeight)')browser.execute_script('alert("To Bottom")') 获取节点信息 获取属性 123456789from selenium import webdriverfrom selenium.webdriver import ActionChainsbrowser = webdriver.Chrome()url = 'https://www.zhihu.com/explore'browser.get(url)logo = browser.find_element_by_id('zh-top-link-logo')print(logo)print(logo.get_attribute('class')) 获取文本值 1234567from selenium import webdriverbrowser = webdriver.Chrome()url = 'https://www.zhihu.com/explore'browser.get(url)input = browser.find_element_by_class_name('js-signin-noauth')print(input.text) 获取id、位置、标签名和大小 12345678910from selenium import webdriverbrowser = webdriver.Chrome()url = 'https://www.zhihu.com/explore'browser.get(url)input = browser.find_element_by_class_name('zu-top-add-question')print(input.id)print(input.location)print(input.tag_name)print(input.size) 切换Frame 网页中有一种节点叫作iframe，它的结构和外部网页的结构完全一致。Selenium打开网页后，它默认实在父级Frame里面操作，如果页面中还有子Frame，它是不能获取到子Frame里面的节点的，需要使用switch_to.frame()方法来切换Frame。 12345678910111213141516import timefrom selenium import webdriverfrom selenium.common.exceptions import NoSuchElementExceptionbrowser = webdriver.Chrome()url = 'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'browser.get(url)browser.switch_to.frame('iframeResult')try: logo = browser.find_element_by_class_name('logo')except NoSuchElementException: print('no logo')browser.switch_to.parent_frame()logo = browser.find_element_by_class_name('logo')print(logo)print(logo.text) 延时等待 在Selenium中，get()方法会在网页框架加载结束后结束执行，但可能并不是浏览器完全加载完成的页面，所以需要延时等待一定时间，确保节点已经加载出来。 隐式等待 使用隐式等待执行测试的时候，如果Selenium没有在DOM中找到节点，将继续等待，超出设定时间则抛出找不到节点的异常，默认时间为0。 123456789from selenium import webdriveroption = webdriver.ChromeOptions()option.add_argument('-headless')browser = webdriver.Chrome(options=option)browser.implicitly_wait(10)browser.get('https://www.zhihu.com/explore')input = browser.find_element_by_class_name('zu-top-add-question')print(input) 显式等待 显式等待指定要查找的节点，然后指定一个最长等待时间。如果在规定时间内加载出该节点，就返回查找的节点；如果未加载出该节点，则抛出异常。 123456789101112131415from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECoption = webdriver.ChromeOptions()option.add_argument('-headless')browser = webdriver.Chrome(options=option)# browser = webdriver.Chrome()browser.get('https://www.taobao.com/')wait = WebDriverWait(browser,10)# presence_of_element_located的参数是节点的定位元祖，也就是ID为q的节点搜索框input = wait.until(EC.presence_of_element_located((By.ID,'q')))button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR,'.btn-search')))print(input,button) 其他等待条件 | 等待条件 | 含义 || ————————————– | ———————————————– || title_is | 标题是某内容 || title_contains | 标题包含某内容 || presence_of_element_located | 节点加载出来，传入定位元祖 || visibility_of+element_located | 节点可见，传入定位元祖 || visibility_of | 可见，传入节点对象 || presence_of_all_elements_located | 所有节点加载出来 || text_to_be_present_in_element | 某个节点文本包含某文字 || text_to_bo_present_in_element_value | 某个节点值包含某文字 || frame_to_bo_available_and_switch_to_it | 加载并切换 || invisibility_of_element_located | 节点不可见 || element_to_be_clickable | 节点可点击 || staleness_of | 判断一个节点是否仍在DOM，可判断页面是否已经刷新 || element_to_be_selected | 节点可选择，传入节点对象 || element_located_to_be_selected | 节点可选择，传入定位元祖 || element_selection_state_to_be | 传入节点对象及状态，相等为True，否则False || element_located_selection_state_to_be | 传入定位元祖及状态，相等为True，否则False || alert_is_present | 是否出现警告 | 更多参考官方文档 前进和后退 1234567891011import timefrom selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.taobao.com')browser.get('https://www.taobao.com')browser.get('https://www.baidu.com')browser.back()time.sleep(1)browser.forward()browser.close() Cookies 123456789101112from selenium import webdriveroption = webdriver.ChromeOptions()option.add_argument('-headless')browser = webdriver.Chrome(options=option)browser.get('https://www.zhihu.com/explore')print(browser.get_cookies())browser.add_cookie(&#123;'name':'name','domain':'www.zhihu.com','value':'germey'&#125;)print('-' * 50)print(browser.get_cookies())browser.delete_all_cookies()print(browser.get_cookies()) 选项卡管理 123456789101112import timefrom selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.baidu.com')browser.execute_script('window.open()')print(browser.window_handles)browser.switch_to_window(browser.window_handles[1])browser.get('https://www.taobao.com')time.sleep(1)browser.switch_to_window(browser.window_handles[0])browser.get('https://www.python.org') 异常处理 1234567891011121314from selenium import webdriverfrom selenium.common.exceptions import TimeoutException,NoSuchElementExceptionbrowser = webdriver.Chrome()try: browser.get('https://www.baidu.com')except TimeoutException: print('time out')try: browser.find_element_by_id('hello')except NoSuchElementException: print('no element')finally: browser.close() 7.2 Splash的使用 功能 异步方式处理多个网页渲染过程 获取渲染后的页面的源代码或截图 通过关闭图片渲染或使用adblock规则来加快页面渲染速度 可执行特定的JavaScript脚本 可通过Lua脚本来控制页面渲染速度 获取渲染的详细过程病通过HAR格式呈现 安装 安装dockerbrew cask install docker 现在安装spalshdocker pull scrapinghub/splash 运行spalshdocker run -p 8050:8050 -p 5023:5023 scrapinghub/splash 使用浏览器访问http://localhost:8050 7.3 Splash负载均衡配置7.4 使用Selenium爬取淘宝商品八、验证码识别8.1 图形验证码的识别九、代理的使用十、模拟登陆十一、APP的爬取十二、 pyspider框架的使用 相关链接 GItHub地址：https://github.com/binux/pyspider 官方文档：http://docs.pyspider.org/en/latest/ 基本功能 提供方便易用的WebUI系统，可视化编写和调试爬虫 提供爬取进度监控、爬取结果查看、爬虫项目管理等功能 支持多种后端数据库，如MySQL、MongoDB、Redis、SQLite、Elasticsearch、PostgreSQL 支持多种消息队列，如RabbitMQ、Beanstalk、Redis、Kombu 提供优先级控制、失败重试、定时抓取等功能 对接了PhantomJS，可以爬取JavaScript渲染的页面 支持单机和分布式部署，支持Docker部署 与Scrapy比较 架构 基本使用 目标：爬去去哪儿网的旅游攻略，链接为http://travel.qunar.com/travelbook/list.htm 十三、Scrapy框架的使用十四、分布式爬虫十五、分布式爬虫的部署 待更新2018.09.11]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Spider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python文件处理]]></title>
    <url>%2F2018%2F09%2F11%2FPython%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[Python文件处理Python文件基础操作文件：Python中文件是对象；linux文件：一切设备都可以看成文件，例如：磁盘文件，管道，网络Socket，外设等；文件属性：用户，读，写，执行权限 Python文件打开方式文件打开方法：open(name[,mode[buf]]) name：文件路径 mode：打开方式 buf：缓冲buffering大小 mode 说明 注意 ‘r’ 只读方式打开(默认) 文件必须存在 ‘w’ 只写方式打开 文件不存在创建文件,文件存在则清空文件内容 ‘a’ 追加方式打开 文件不存在创建文件 ‘r+’/‘w+’ 读写方式打开 ‘a+’ 追加和读写方式打开 123# 默认为只读f = open('push.py')x = f.read() 12345678910111213141516# 以只写方式打开文件，若文件文件不存在创建文件,文件存在则清空文件内容f = open('1.txt','w')f.write("test write")f.close()# 以追加方式打开文件f = open('hello.py','a')f.write('print('write test')')f.close()# 以读写方式r+打开，会覆盖文件内容f = open('hello.py','r+')f.write('test r+')f.close()# 以读写方式w+打开，会先清空文件内容f = open('hello.py','w+')f.write('test r+')f.close() Python读取方式 read([size])：读取文件(读取size个字节，默认读取全部) readline([size])：读取一行 len(line) &gt; size return size len(line) &lt; size return len(line) readlines([size])：读取缓冲buff左右的文件，返回每一行所组成的列表 123456789101112131415f = open('hello.py')list_c = f.readlines(1)# 仍返回hello.py中的所有内容，这是因为readlines([size])里的size默认大小为8192字节import io&gt;&gt;&gt; io.DEFAULT_BUFFER_SIZE8192# 此hello.py大小大于8192字节f = open('hello.py')list_c = f.readlines(1)# readlines每次只读取与buff缓冲相接近的数字# 使用迭代器可完成整个文件的读取iter_f = iter(f)lines = 0for line in iter_f: lines += 1 Python写入方式 write(str)：将字符串写入文件 writelines(sequence_of_strings)：写入多行到文件，参数为可迭代的对象 12345678910111213f = open('hello.py','w')f.write('test write)f.close()# 以writelines写入文件f.open('hello.py','w')f.writelines(('1','2','3'))f.writelines(['1','2','3'])f.close()f = open('hello.py','w')f.write('1111111')cat hello.py# 结果仍未空，因未执行文件操作，写入操作还未写入磁盘 写入文件过程 主动调用close()或者flush()方法，写缓存同步到磁盘 写入数据量大于或者等于写缓存，写缓存同步到磁盘 Python文件关闭 缓存同步到磁盘 linux系统中每个进程打开文件的个数是有限的 如果打开文件数到了系统限制，再打开文件就会失败 linux系统限制 123ps #查看进程IDcat /proc/进程ID/limits# 可查看软件限制和硬件限制文件打开个数 fileno属性指当前打开文件数，每打开一个文件，fileno返回的整数+1 12345list_f = []for i in range(1025): list_f.append(open('hello.py','w')) print("%d:%d" % (i,list_f[i].fileno()))# 当超如软件限制时，就会出现打开失败的错误 Python文件指针文件读取写入文件指针移动的过程： Python操作文件指针 seek(offset[,whence])：移动文件指针 offset：偏移量，可以为负数 whence：偏移相对位置 os.SEEK_SET：相对文件起始位置 0 os.SEEK_CUO：相对文件当前位置 1 os.SEEK_END：相对文件结尾位置 2 1234567891011121314f = open('hello.py','r+')import os# 返回当前文件的偏移f.tell()f.read(3)# 指针回到起始位置f.seek(0,os.SEEK_SET)f.tell()# 指针回到结尾位置f.seek(0,os.SEEK_END)f.tell()# 指针相对当前位置向左偏移5f.seek(-5,os.SEEK_CUR)f.tell() 文件属性及OS模块使用Python文件属性编码格式Python文件对象属性file.fileno()：文件描述符file.mode：文件打开权限file.encoding：文件编码格式file.closed：文件是否关闭 Python标准文件文件标准输入：sys.stdin文件标准输出：sys.stdout文件标准错误：sys.stderr 文件命令行参数12345import sysif __name__ == "__mian__": print(len(sys.argv)) for arg in sys.argv: print(arg) OS模块对文件和目录操作os.open(filename,flag[,mode])：打开文件 flag：打开文件方式 os.O_CREAT：创建文件 os.O_RDONLY：只读方式打开 os.O_WRONLY：只写方式打开 os.O_RDWR：读写方式打开 os.read(fd,buffersize)：读取文件 os.write(fd,string)：写入文件 os.lseek(fd,pos,how)：文件指针操作 os.close(fd)：关闭文件]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim操作指南]]></title>
    <url>%2F2018%2F09%2F10%2FVim%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[移动 hjkl ctrl - f 上翻页 ctrl - b 下翻页 % w 移动到单词前端(包含标点符号) W 单词间移动 e 移动到单词末端(包含标点符号) E 移动到单词末端 b 向上移动到单词词首(包含标点符号) B 空白字符分割的上词词首 O 开始新的一行 ^ 当前行的第一个非空字符 $ 到 行尾 gg 第一行 gd [N]G 第N行行首 fx ; tx Fx ) 到句首 ( 到句尾 } 到段首 { 到段尾 * `. 智能移动 书签 插入模式 i 在光标之前插入 I 行尾插入 a 在光标之后插入 A 行首插入 o 当前行下插入一空行 O 当前行上插入一空行 Esc 返回模式选择 提示 ctrl - n ctrl - p 编辑 r J cc cw c$ s S xp u 撤销改动 ctrl - r 重做 . 重复上一命令 ~ g~iw gUiw guiw >> &lt;&lt; == 剪切和复制 dd 删除一行 dw 删除一个单词 x 删除当前光标下的字符 X 删除当前光标左边的字符 D 删除到行尾的内容 yy 复制一行 nyy 复制n行 yw y$ p 粘贴到光标之前 P 粘贴到光标之后 ]p “a d 剪切 多文件 :e :bn :bd :sp fn ctrl - w ctrl - w s ctrl - w w ctrl - w q ctrl - w v :table fn gt gT :tabr :tabl :tabm [N] 搜索/替换 /pattern ?pattern n N :s/old/new/g :s/old/new/gc 选中模式 文本标记 v V ctrl - v o U O aw ab aB ib iB 命令 &lt; y d ~ 离开 :w :wq :x :q :q! 宏命令 qa q @a]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python面向对象编程]]></title>
    <url>%2F2018%2F09%2F09%2FPython%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Python面向对象编程 面向对象编程(Object Oriented Programming，简称OOB)是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 123456789101112131415# 采用面向对象编程，将Student这种数据类型视为一个对象，这个对象拥有name和score两个属性。如果要打印学生的成绩，首先必须创建出这个学生对应的对象，然后调用对象的方法，让对象自己把对应的数据打印出来。class Student(object): def __init__(self,name,score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name,self.score))# 给对象发消息实际上是调用对象对应的关联函数，称之为对象的方法bart = Student('Bart Simpson',59)lisa = Student('Lisa Simpson',87)bart.print_score()lisa.print_score() 类和实例面向对象最重要的概念就是类(Class)和实例(Instance)，类是抽象的模板，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。 定义类是通过class关键字： 12class Student(object)： pass 变量指向的就是类的实例，0x10b0a60b8是内存地址，每个实例的地址都不一样。 12345bart = Student()bart&lt;__main__.Student object at 0x10b0a60b8&gt;Student&lt;class '__main__.Student'&gt; 类可以起到模板的作用，因此在创建实例的时候，把一些必须绑定的数据强制填写进去。通过一个特殊的__init__方法。 12345class Student(object): def __init__(self,name,score): self.name = name self.score = score 特殊方法__init__前后分别有两个下划线，__init__方法的第一个参数永远是self，表示创建实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。有了init方法，在创建实例的时候，就不能传入空的参数了，必须传入与init方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传递进去。 数据封装每个实例都拥有自己的数据。可以通过函数来访问这些数据，实例本身就拥有数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在Student类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和Student类本身是关联起来的，我们称之为类的方法。 123456789101112class Student(object): def __init__(self, name, score): self.name = name self.score = score def get_grade(self): if self.score &gt;= 90: return 'A' elif self.score &gt;= 60: return 'B' else: return 'C' 访问限制在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线，在Python中，实例的变量名如果以开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。 12345678class Student(object): def __init__(self,name,score): self.__name = name self.__score = score def print_score(self): print('%s: %s' % (self.__name,self.__score))# 改吗修改完成后，对外部代码来说没有什么变化，但是 已经无法从外部访问实例变量.__name和实例变量.__score了。 好处：这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。 外部无法获取name和score属性，就需要给类增加响应的get和set方法： 1234567class Student(object): ... def get_name(self): return self.name def set_name(self,name): self.name = name# 这样可以在方法中对传入的数据进行检查，便面传入无效参数。 在Python中，变量名类似xxx的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用name、score这样的变量名。有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。 集成和多态当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。 12345678910111213141516171819202122class Animal(object): def run(self): print('Animal is running...')# 编写Dog和Cat类class Dog(Animal): def run(self): passclass Cat(Animal): def run(self): print('Cat is running')# 子类可以获得父类的全部功能dog = Dog()dog.run()Animal is running...# 当子类和父类都存在相同的run方法时，子类的方法会覆盖父类的方法，代码运行时总会调用子类的run()方法。这是继承的另一个好处：多态。# 判断某个变量是否为某个类型时，可以用isinstance()判断&gt;&gt;&gt; isinstance(dog,Dog)True 对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。 对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了, 获取对象信息 使用type()可以判断对象的类型 使用isinstance()可以判断类的继承关系 使用dir() 使用dir()可以获取一个对象的所有属性和方法，它返回一个包含字符串的list 实例属性和类属性如果类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归类所有 12class Student(object): name = 'Student' 这个类属性虽然归类所有，但是所有实例都可以访问到。 1234567891011121314151617# 创建实例s&gt;&gt;&gt; s = Student()# 因为实例没有name属性，因此会继续查找class的name属性&gt;&gt;&gt; s.name'Student'&gt;&gt;&gt; Student.name'Student'# 给实例绑定name属性，由于实例属性的优先级比类属性高，因此会屏蔽掉类的name属性&gt;&gt;&gt; s.name = 'Michael'&gt;&gt;&gt; s.name'Michael'&gt;&gt;&gt; Student.name'Student'# 删除实例的name属性，再次调用类属性&gt;&gt;&gt; del s.name&gt;&gt;&gt; s.name'Student' 编写程序时，实例属性和类属性不应该使用相同的名字 面向对象高级编程使用slots在Python中，我们可以动态地给实例绑定任何属性和方法。 123456789101112class Student(object): pass# 动态地给实例绑定属性和方法，但只对当前实例有效，对其他实例是不起作用的&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.name = 'michael'&gt;&gt;&gt; s.age = 23&gt;&gt;&gt; s.score = 99&gt;&gt;&gt; def set_age(self,age):... self.age = age...&gt;&gt;&gt; from types import MethodType&gt;&gt;&gt; s.set_age = MethodType(set_age,s) 在定义class的时候，定义一个特殊的变量slots，可以显示该class实例能添加的属性。 123class Student(object):# 用tuple定义允许绑定的属性名称 __slots__ = ('name','age') 1234567&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.name = 'michael'&gt;&gt;&gt; s.age = 23&gt;&gt;&gt; s.score = 99Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute 'score' slots定义的属性仅对当前类实例起作用，对集成的子类是不起作用的，若在子类中也定义slots属性，则子类实例允许的属性就是自身的slots属性加上父类的slots__。 使用@property装饰器(decorator)可以给函数动态加上功能，对于类的方法，装饰器同样起作用。Python内置的@property装饰器就是负责把一个方法编程属性调用的。 123456789101112class Student(object): @property def score(self): return self._score @score.setter def score(self,value): if not isinstance(value,int): raise ValueError('score must be an integer!) if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100') self._score = value 多重继承定制类str当我们定义类并打印出它的实例是，通常是&lt;__main__.Student object at 0x00000000&gt;这种形式的，如何才能将它变得好看又直观呢？只需要在类中定义好str()方法。 12345678&gt;&gt;&gt; class Student():... def __init__(self,name):... self.name = name... def __str__(self):... return 'student object (name: %s)' % self.name...&gt;&gt;&gt; print(Student('michael'))student object (name: michael) iter如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。 123456789101112class Fib(object): def __init__(self): self.a, self.b = 0, 1 # 初始化两个计数器a，b def __iter__(self): return self # 实例本身就是迭代对象，故返回自己 def __next__(self): self.a, self.b = self.b, self.a + self.b # 计算下一个值 if self.a &gt; 100000: # 退出循环的条件 raise StopIteration() return self.a # 返回下一个值 getitem虽然可以用类实现循环迭代，但无法像list那样按照下标取出元素，需要实现getitem()方法 123456789101112131415161718192021222324class Fib(object): def __getitem__(self,n): if isinstance(n,int): a,b = 1,1 for x in range(n): a,b = b,a+b return a if isinstance(n,slice): start = n.start stop = n.stop if start is None: start = 0 a,b = 1,1 L = [] for x in range(stop): if x &gt;= start: L.append(a) a,b = b,a+b return L# 现在就可以按下标访问数列的任意一项了，并加入判断，若n为切片，则使用切片方法&gt;&gt;&gt; f = Fib()&gt;&gt;&gt; f[0]1 getattr通常情况下，当我们调用类的属性或方法时，若不存在即报错，但是使用__getattr__()方法，可以动态返回一个属性。 123456789101112131415class Student(object): def __init__(self): self.name = 'Michael' def __getattr__(self,attr): if attr == 'score': return 99 # 也可以返回函数 if attr == 'age': return lambda:25&gt;&gt;&gt; s.scorre99&gt;&gt;&gt; s.age()25# 只有在没有找到属性的情况下才会调用__getattr__，已有的属性不会再__getattr__中查找。 call一个对象实例可以有自己的属性和方法，当我们调用实例方法时，使用instance.method()来调用。在Python中，任何类只需要定义一个__call__()方法，就可以直接对实例进行调用。 12345678910class Student(object): def __init__(self,name): self.name = name def __call__(self): print('My name is %s.' % self.name)# 调用方法如下&gt;&gt;&gt; s = Student('Michael')&gt;&gt;&gt; s()My name is Michael. __call__()还可以定义参数，对实例进行直接调用就好像对一个函数进行调用一样。如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个Callable对象。 1234&gt;&gt; callable(s)True&gt;&gt;&gt; callable(Student('duzhida'))True 使用枚举类当我们需要定义常量时，一个方法时用大写变量通过整数来定义，例如月份。更好的方法是为这样的枚举类定义一个class类型，然后每个常量都是class的一个唯一实例。Python可以通过Enum类来实现。 1234567from enum import EnumMonth = Enum('Month',('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))for name,member in Month.__members__.items(): # value属性是自动赋给成员的int常量，默认从1开始计数 print(name,'=&gt;',member,',',member.value) 若需要更精确地控制枚举类型，可以从Enum派生出自定义类 123456789101112from enum import Enum, unique# @unique装饰器可以帮助我们检查保证没有重复值@uniqueclass Weekday(Enum): Sun = 0 # Sun的value被设定为0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pro-Git笔记]]></title>
    <url>%2F2018%2F09%2F08%2FPro-Git%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Pro Git学习笔记目录 Git简介 安装Git 初次运行Git前的配置 Git基础 Git分支 Git简介 直接记录快照，而非差异比较 近乎所有操作都是本地执行 Git保证完整性 Git一般只添加数据 三种状态 以提交 – 已提交表示数据已经安全的保存在本地数据库中 已修改 – 修改了文件，但还没保存到数据库中 已暂存 – 对一个已修改的文件的当前版本做了标记，使之包含在下次提交的快照中。 工作区域 Git仓库 – 用来保存项目的元数据和对象数据库的地方，从其他计算基金克隆仓库时，拷贝的就是这里的数据 工作目录 – 对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘 上供你使用或修改。 暂存区域 – 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索 引’’，不过一般说法还是叫暂存区域。 安装Git Linux上安装 123$ sudo yum install git $ sudo apt-get install git Mac上安装安装Xcode Command Line Tools Windows上安装Git官网 源代码安装从源码安装Git，需要安装Git以来的库：curl、zlib、openssl、expat和libiconv 12$ sudo yum install curl-devel expat-devel gettext-devel \ openssl-devel zlib-devel $ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \ libz-dev libssl-dev 为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包： 12$ sudo yum install asciidoc xmlto docbook2x $ sudo apt-get install asciidoc xmlto docbook2x 下载Git的tar包 1234$ tar -zxf git-2.0.0.tar.gz $ cd git-2.0.0 $ make configure $ ./configure --prefix=/usr $ make all doc info $ sudo make install install-doc install-html install-info 使用Git来获取Git的升级 1git clone git://git.kernel.org/pub/scm/git/git.git 初次运行Git前的配置三个配置变量每一个级别覆盖上一级别的配置 /etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 –system 选项的 git config 时，它会从此文件读写配置变量。 ~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 可以传递 –global 选项让 Git 读写此文件。 .git/config 当前使用仓库的 Git 目录中的 config 文件（就是 .git/config）：针对该仓库。 在Windows 系统中，Git 会查找 $HOME 目录下（一般情况下是 C:\Users\$USER）的 .gitconfig 文件。 Git 同样也会寻找 /etc/gitconfig 文件，但只限于 MSys 的根目录下，即安装 Git 时所选的目标位置。 用户信息和文本编辑器设置用户名称和邮件地址，因为每一个Git的提交都会使用这些信息，并且会写入到你的每一次提交中，不可更改： 1234$ git config --gloabl user.name "username"$ git config --global user.email "user email"$ git config --global core.editor emacs//default vim 如果使用了 –global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事 情， Git 都会使用那些信息。当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运 行没有 –global 选项的命令来配置。 检查配置信息 123git config --list//check someonegit config &lt;key&gt; 获取帮助Git命令使用手册 123$ git help &lt;verb&gt;$ git &lt;verb&gt; --help$ man git-&lt;verb&gt; config命令手册 1git help config Git基础获取Git仓库 在现有目录中初始化仓库 1$ git init 克隆现有的仓库 1git clone [url] 记录每次更新到仓库 检查当前文件状态 1$ git status 跟踪新文件 1$ git add [file] 暂存已修改文件 1$ git add [file] 状态简览 1$ git status -s/--short 忽略文件 创建一个名为.gitignore的文件，列出药忽略的文件模式。 123$ cat .gitignore *.[oa] //忽略所有以.o或.a结尾的文件*~ //忽略所有以~结尾的文件 &gt; .gitignore的格式规范如下： • 所有空行或者以 ＃ 开头的行都会被 Git 忽略。 • 可以使用标准的 glob 模式匹配。 • 匹配模式可以以（/）开头防止递归。 • 匹配模式可以以（/）结尾指定目录。 • 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（\*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（? ）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配 （比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（\*) 表示匹配任意中间目录，比如\`a/**/z\` 可以匹 配 a/z, a/b/z 或 \`a/b/c/z\`等。 &gt; [.gitignore文件列表](https://github.com/github/gitignore) 查看已暂存和未暂存的修改 1$ git diff Git分支分支简介 创建分支 1$ git branch bran-name 切换分支 1$ git checkout bran-name 查看分叉历史 12$ git log$ git log --oneline --decorete --graph --all 分支的新建与合并工作流： 开发某个网站 为实现某个需求，创建一个分支 在这个分支上展开工作有Bug需紧急处理： 切换到你的线上分支 为紧急任务创建一个新的分支，并修复它 测试通过后，切换回线上分支，合并这个修补分支，最后将改动推动到线上分支 切换回最初工作的分支，继续工作 新建并切换分支 1234$ git branch bran-name$ git checkout bran-name//简写$ git checkout -b bran-name 切换分支之前，保持干净的状态(提交还未被提交的修改)。也可以保存进度(stashing)和修补提交(commit amending) 分支的合并 123$ git checkout masterSwitched to branch 'master'$ git merge bran-name 分支的删除 1$ git branch -d bran-name 遇到冲突时的分支合并]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双系统Windows时间不同步问题]]></title>
    <url>%2F2018%2F09%2F07%2F%E5%8F%8C%E7%B3%BB%E7%BB%9FWindows%E6%97%B6%E9%97%B4%E4%B8%8D%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[双系统Windows时间不同步问题在电脑上安装使用双系统时，Windows常常会出现时间不同步的为题。需要重新设置时间才能解决。今天偶然在掘金上看到这个问题，并解决了我电脑的问题，因此记录下来备忘。 Win + R 运行regedit打开注册表编辑器 在左边的导航菜单，找到HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TimeZoneInformation路径，然后再右边的窗口点击空白位置，选择New &gt;&gt; DWORD(32 bit) Value 将这个条目重命名为RealTimeIsUniversal，并设置为1 之后重启就不会出现时间不同步的问题了。 参考： https://juejin.im/entry/5adbd1ad51882567137dc6de 原文]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>Time</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-reset相关用法]]></title>
    <url>%2F2018%2F09%2F06%2Fgit-reset%E7%9B%B8%E5%85%B3%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[git reset相关用法 HEAD 当前版本的别名，即当前分支最近的一个提交。 Index 指下一次提交所包含的文件的集合。 Working Copy 正在工作的文件集。 流程 使用checkout切换分支，HEAD指向当前分支的最近一次commit，当前HEAD、Index和Working Copy中的文件集合是相同的。 对文件执行修改，Git发现文件发生改变，此时Working Copy发生改变。 执行git add，Git将改变的文件集合记录到Index，此时Index的状态与Working Copy的状态相同。 最后执行git commit，Git创建了新的commit，此时HEAD指向新的commit，HEAD、Index和Working Copy一致。 Restgit reset本质是重置HEAD(当前分支的版本顶端)到另一个commit。假设有有个分支如下： 此时执行git reset HEAD任何事情都不会发生，GIT会重置当前分支到HEAD，而这个正是它现在所在的位置。 若执行git reset HEAD~1，HEAD将指向上一个commit。若执行git reset HEAD~2则HEAD将指向后两个commit如图： 参数–soft–soft参数告诉Git重置HEAD到另外一个commit，但此时Index和working copy不会有任何变化。 –hard–hard参数将会重置HEAD返回到另一个commit，且index和working copy也将重置。数据因此可能会丢失，若丢失只能只用git reflog。 如果我们希望彻底丢掉本地修改但是又不希望更改branch所指向的commit，则执行git reset –hard = git reset –hard HEAD。 –mixed(default)–mixed是reset的默认参数，它将重置HEAD到另一个commit，并且重置index保持和HEAD相同，但work copy不会改变。 总结–soft 、–mixed以及–hard是三个恢复等级。使用–soft就仅仅将头指针恢复，已经add的缓存以及工作空间的所有东西都不变。如果使用–mixed，就将头恢复掉，已经add的缓存也会丢失掉，工作空间的代码什么的是不变的。如果使用–hard，那么一切就全都恢复了，头变，aad的缓存消失，代码什么的也恢复到以前状态。 参考 参考：https://www.cnblogs.com/kidsitcn/p/4513297.html]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python操作列表、元祖、字典、集合]]></title>
    <url>%2F2018%2F09%2F05%2FPython%E6%93%8D%E4%BD%9C%E5%88%97%E8%A1%A8%E5%85%83%E7%A5%96%E5%AD%97%E5%85%B8%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[列表 列表：由一系列按特定顺序排列的元素组成。可用list()函数或方括号创建，元素间用逗号分隔。 12my_list = ['name','age']list1 = list((1,2)) 访问元素：列表是有序集合，通过元素的位置或索引即可访问列表的任何元素 12computer = ['dell','asus','apple']print(computer[0]) 修改、添加和删除元素修改列表元素12phone = ['xiaomi','oneplus','apple']phone[0] = 'vivo' 添加列表元素 在列表末尾添加元素 12phone = ['xiaomi','oneplus','apple']phone.append('oppo') 在列表中插入元素 12phone = ['xiaomi','oneplus','apple']phone.insert(1,'SAMSUNG') 删除列表元素 使用del语句删除元素 12phone = ['xiaomi','oneplus','apple']del phone[2] 使用pop()方法删除元素 pop()方法可删除列表末尾的元素，并且可以接着使用它。 12345phone = ['xiaomi','oneplus','apple']new_phone = phone.pop()# 在括号中指定要删除的元素的索引可删除任何位置的元素my_phone = phone.pop(1) 根据值删除元素 使用remove方法可以删除元素的值，并且也可以接着使用它的值。 12phone = ['xiaomi','oneplus','apple']your_phone = phone.remove('oneplus') 方法remove()只删除第一个指定的值。多国药删除的值可能多次在列表中出现多次，就需要用循环来判断是否删除了所有的值。 组织列表使用sort()方法对列表进行永久性排序1234cars = ['bmw','audi','toyota']cars.sort()# 按与字母顺序想法的顺序排列列表元素cars.sort(reverse=True) 使用sorted()对列表进行临时排序123cars = ['bmw','audi','toyota','BMW']sorted(cars)['BMW', 'audi', 'bmw', 'toyota'] 倒着打印列表使用reverse()方法可以反转列表元素的排列顺序，reverse()方法永久性地修改列表元素的排列顺序，但可以恢复原来的排列顺序，只需再次使用reverse()方法。 12cars = ['BMW', 'audi', 'bmw', 'toyota']cars.reverse() 确定列表的长度12cars = ['BMW', 'audi', 'bmw', 'toyota']len(cars) 遍历整个列表123cars = ['BMW', 'audi', 'bmw', 'toyota']for car in cars: print(car) 创建数值列表123456789101112131415for value in range(1,5): print(value)1234numbers = list(range(1,6))# 指定步长even_numbers = list(range(2,11,2))# 找出列表的最大值、最小值和总和min(numbers)max(numbers)sum(numbers) 列表解析1squares = [value**2 for value in range(1,11)] 使用列表的一部分切片123456cars = ['BMW', 'audi', 'bmw', 'toyota']print(cars[0:2])['BMW', 'audi']print(cars[:3])print(cars[2:])print(cars[-2:]) 复制列表复制列表可以创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引([:]) 12my_foods = ['pizza','falafel','corrot cake']your_foods = my_foods[:] 方法 操作 解释 list.append() 追加元素 list.count(x) 计算列表中参数x出现的次数 list.extend(L) 向列表中追加另一个列表L list.index(x) 获得参数x在列表中的位置 list.insert() 向列表中插入数据 list.pop() 删除列表中的成员（通过下标删除） list.remove() 删除列表中的成员（直接删除） list.reverse() 将列表中成员的顺序颠倒 list.sort 将列表中成员排序 元祖不可变的列表被称为元祖。使用圆括号来标识。使用索引来访问元素。可以用tuple()函数或者括号创建，元素间用逗号分隔。 1234567dimensions = (200，50)tuple1 = tuple([1,2])print(dimensions[0])## 遍历元祖中的所有值for dimension in dimensions: print(demension) 虽然不能修改元祖的元素，但可以给存储元祖的变量赋值，重新定义整个元祖。 12dimensions = (100，200)print(dimensions[0]) 元组由于它的不可变性（第五点特点），相比列表的操作少了很多，只保留了index()，count()函数，用法同列表。当然也可以用内置函数来对他进行操作，这些内置函数对于列表也适用。 操作 解释 cmp(tuple1, tuple2) 比较两个元组元素。 len(tuple) 计算元组元素个数。 max(tuple) 返回元组中元素最大值。 min(tuple) 返回元组中元素最小值。 tuple(seq) 将列表转换为元组。 list(seq) 将元组转换为列表。 字典使用字典字典是一系列键——值对。每个键都与一个值相关联，可以使用键来访问与之相关的值。可将任何Python对象用作字典中的值。可以用dict()或花括号创建，元素之间用逗号’,‘’分隔，键与值之间用冒号”:”隔开。键必须是唯一的，但值则不必。值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。 12alien = &#123;'color':'green','point':5&#125;dict1 = dict([('name','entercoder'),('age',10)]) 访问字典中的值获取与键相关的值，指定字典名和放在方括号内的键。 123alien = &#123;'color':'green','point':5&#125;alien['color']alien['point'] 添加键——值对12alien['x_position'] = 0alien['y_position'] = 25 创建一个空字典123alien_0 = &#123;&#125;alien_0['color'] = 'green'alien_0['points'] = 5 修改字典中的值1alien_0['color'] = 'yellow' 删除键——值对使用del语句将相应的键——值对彻底删除。 1del alien_0['points'] 由类似对象组成的字典123456favorite_language = &#123; 'jen':'python', 'sarah':'c', 'edward':'ruby', 'phil':'python',&#125; 遍历字典123456789101112131415161718192021favorite_language = &#123; 'jen':'python', 'sarah':'c', 'edward':'ruby', 'phil':'python',&#125;for key,value in favorite_language.items(): print("\nname: " + key.title()) print("\nlanguage: " + value.title())# 遍历字典中的所有键for name in favorite_language.keys(): print(name.title())# 遍历字典中的所有值for value in favorite_language.values(): print(value.title())# 按顺序遍历字典中的所有键for name in sorted(favorite_language.keys()): print(name.title()) 方法 操作 解释 adict.keys() 返回一个包含字典所有KEY的列表； adict.values() 返回一个包含字典所有value的列表； adict.items() 返回一个包含所有（键，值）元祖的列表； adict.clear() 删除字典中的所有项或元素； adict.copy() 返回一个字典浅拷贝的副本； adict.fromkeys(seq, val=None) 创建并返回一个新字典，以seq中的元素做该字典的键，val做该字典中所有键对应的初始值（默认为None）； adict.get(key, default = None) 返回字典中key对应的值，若key不存在字典中，则返回default的值（default默认为None）； adict.has_key(key) 如果key在字典中，返回True，否则返回False。 现在用 in 、 not in； adict.iteritems() adict.iterkeys() adict.itervalues() 与它们对应的非迭代方法一样，不同的是它们返回一个迭代子，而不是一个列表； adict.pop(key[,default]) 和get方法相似。如果字典中存在key，删除并返回key对应的vuale；如果key不存在，且没有给出default的值，则引发keyerror异常； adict.setdefault(key, default=None) 和set()方法相似，但如果字典中不存在Key键，由 adict[key] = default 为它赋值； adict.update(bdict) 将字典bdict的键值对添加到字典adict中。 集合1.可以用set()函数或者方括号{}创建，元素之间用逗号”,”分隔。2.与字典相比少了键3.不可索引，不可切片4.不可以有重复元素 12set1 = set('entercoder')set2 = &#123;'c','java','python','java'&#125; 方法 操作 解释 s.issubset(t)，s &lt;= t 测试是否 s 中的每一个元素都在 t 中 s.issuperset(t)，s &gt;= t 测试是否 t 中的每一个元素都在 s 中 s.union(t)，s \ t 返回一个新的 set 包含 s 和 t 中的每一个元素 s.intersection(t)，s &amp; t 返回一个新的 set 包含 s 和 t 中的公共元素 s.difference(t),s - t 返回一个新的 set 包含 s 中有但是 t 中没有的元素 s.symmetric_difference(t),s ^ t 返回一个新的 set 包含 s 和 t 中不重复的元素 s.copy() 返回 set “s”的一个浅复制 差异用法列表主要用于对象长度不可知的情况下，而元组用于对象长度已知的情况下，而且元组元素一旦创建变就不可修改。字典主要应用于需要对元素进行标记的对象，这样在使用的时候便不必记住元素列表中或者元组中的位置，只需要利用键来进行访问对象中相应的值。集合中的元素不可重复的特点使它被拿来去重。 在海量数据中查找元素时，最好将数据创建为字典，或者是集合。这是由于字典和集合背后的查找原理是散列（哈希）表。由于散列表在查找元素时的时间复杂度基本是O(1),这使查找时间很短。]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS终端美化及设置]]></title>
    <url>%2F2018%2F09%2F02%2FmacOS%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96%E5%8F%8A%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[macOS美化及设置 macOS美化及设置教程 iTerm 安装：下载地址 1$brew cask install iterm oh-my-zsh 安装 12345# via curlsh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"# via wgetsh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)" oh-my-zsh主题及插件插件 zsh-autosuggestion 1234567# 安装$git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions# 添加到./zshrc中plugins=(zsh-autosuggestions)source ~/.zshrc zsh-syntax-highlighting 1234567# 安装git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting# 添加到./zshrc中plugins=(zsh-syntax-highlighting)source ~/.zshrc autojump 123456789# 安装$brew install autojump#在.zshrc中添加plugins=(autojump)[[ -s $(brew --prefix)/etc/profile.d/autojump.sh ]] &amp;&amp; . $(brew --prefix)/etc/profile.d/autojump.sh$source ~/.zshrc brew安装，更换及替换Homebrew默认源 安装 1$/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 安装brew cask 1$brew install cask 替换默认源 1234567$cd "$(brew --repo)"$git remote set-url origin https://mirrors.ustc.edu.cn/brew.git$cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"$git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git$ brew update 替换Homebrew-bottles二进制预编译包 12$echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles' &gt;&gt; ~/.bash_profile$source ~/.bash_profile 替换brew cask源 12cd "$(brew --repo)"/Library/Taps/homebrew/homebrew-caskgit remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git 重置为默认源 12345678910111213# 重置brew.git:$cd "$(brew --repo)"$git remote set-url origin https://github.com/Homebrew/brew.git# 重置homebrew-core.git:$cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"$git remote set-url origin https://github.com/Homebrew/homebrew-core.git# Homebrew-bottles二进制只需注释或删除.bash_profile中的代码即可# 重置brew cask源$cd "$(brew --repo)"/Library/Taps/homebrew/homebrew-cask$git remote set-url origin https://github.com/Homebrew/homebrew-cask App允许任何来源下载安装 1$sudo spctl --master-disable Dock设置 设置启动台每行显示数量 12$defaults write com.apple.dock springboard-columns -int 8 # 每行8个$defaults write com.apple.dock ResetLaunchPad -bool TRUE;killall Dock # 重启dock 显示隐藏文件 1defaults write com.apple.finder AppleShowAllFiles -bool true ; killall Finder 隐藏隐藏文件 1defaults write com.apple.finder AppleShowAllFiles -bool false ; killall Finder 修改终端欢迎画面 cd /etc sudo pico motd [神奇的网站] control + x，然后输入y保存 开启终端显示信息 效果如下所示 相关链接 GitHub地址：https://github.com/athlonreg/archey-osx 官网地址：https://athlonreg.github.io/archey-osx/ 安装 1234$cd &amp;&amp; git clone https://github.com/athlonreg/archey-osx #若无法下载可直接到github下载zip文件$sudo mv archey-osx/ /usr/local/ $sudo ln -s /usr/local/archey-osx/bin/archey /usr/local/bin/archey #中文版$sudo ln -s /usr/local/archey-osx/bin/archey-en /usr/local/bin/archey-en #英文版 设置终端自启动 1234$echo archey &gt;&gt; ./.bashrc #中文版$echo archey-en &gt;&gt; ./.bashrc #英文版$echo "[[ -s ~/.bashrc ]] &amp;&amp; source ~/.bashrc" &gt;&gt; ./.bash_profile $source ./.bashrc &amp;&amp; source ./.bash_profile oh-my-zsh用户 123$echo archey &gt;&gt; ./.zshrc #中文版$echo archey-en &gt;&gt; ./.zshrc #英文版$source ./.zshrc 更新 1cd /usr/local/archey-osx/ &amp;&amp; git pull &amp;&amp; cd 修改 因为我的电脑显示显卡信息太长了，因此替换为用户名，只需修改archey文件中的User即可。 1User=$(echo $(whoami) | sed "s/-/ /g") 取消自动大写字词的首字母设置-键盘-文本-取消自动大写字词的首字母]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Setting</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎样在一年内获得一份开发者的工作]]></title>
    <url>%2F2018%2F08%2F29%2F%E6%80%8E%E6%A0%B7%E5%9C%A8%E4%B8%80%E5%B9%B4%E5%86%85%E8%8E%B7%E5%BE%97%E4%B8%80%E4%BB%BD%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E5%B7%A5%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[怎样在一年甚至更少的时间内获得一份开发者的工作 加快学习速度,对于决定自学代码的人来说，最难的部分是什么？他们通常不知道学什么的事实 - 选择什么样的编程语言，如何对待学习，资源，这是最好的时间效率上。 这一切都始于谷歌搜索这些主题，这不可避免地导致人们使用教授人们编码的众多资源之一。这些资源的格式差异很大，常识告诉我们应该尝试一堆不同的资源，并选择最适合我们学习方式的资源。一些人的教程，其他人的屏幕录像，另一组的文章等。看起来很合乎逻辑，不是吗？ 嗯……不。今天我想说服你，其中一种学习形式可以让你到达你想要比其他任何一个更快的地方。没有进一步的延迟，让我告诉你它是什么以及为什么你应该把所有的努力集中在它上面。 建立项目我打赌你看到那个人来了。 首先，让我解决一些你的反对意见。我并不是说你应该放弃所有其他类型的学习资源。 所有的教程和截屏都有它们在阳光下的位置，我将在文章中进一步阐述。例如，有时引入新技术或框架的最有效方法可能是阅读文章或阅读教程。 问题是我们倾向于（或者至少我）坚持使我们处于舒适区的资源，即使是时候做我们自己的事情了。它太方便了，准备好了。它总是让我们感觉很棒，因为嘿，我们在这里，学习！对吗？谁能说我们在浪费时间？他们怎么敢？我们正在填补我们的知识空白！ 这些资源似乎是最有效的学习方式，这很危险。作为人类，我们可以证明几乎任何使我们处于舒适区域的事情。我已经在这种幻觉中生活了很长一段时间。 敲，敲，新。创建项目……这个想法有什么新意？没有什么，在内心深处，我们都知道，这将最好地利用我们的时间和精力，我们将更快地实现我们的目标。那我们为什么不这样做呢？阻力。 我在我以前的文章（阅读它，如果你正在努力或者如果你觉得卡住了），所以让我解释一下我为什么这么坚定的关于这个话题，让我说服你改变你的焦点（除非它是谈到了抵抗已经在那里建设。 像新的矩阵，谁是由于红色药丸和蓝色药丸的选择，我们可以回到我们的幻想，以为这都拿着我们的手无时无刻的资源是最好的学习方法，或者我们可以把红当我们离开我们的舒适区时，我们只会向前迈进并成长。 （如果你没有看过Matrix，你应该这样做。） 以下是我对如何处理这些项目的一些想法，这可能是令人生畏的开始，以及我在此过程中提到的一些技巧。 你可能需要不到一年的时间（什么？）这背后的原因是基于我的工作人员的经验，与我们的免费组代码多伦多营的成员说话，阅读有关会员遍布世界各地的旅程。 我发现，大多数情况下，人们甚至可以在完成Free Code Camp的前端开发认证之前找到工作。他们构建所需的项目，并开始申请。很快，他们得到了代码换钱的提议。 如果您阅读Free Code Camp的subreddit，您会发现有很多类似的故事。 请注意，就业市场因城市而异。例如，在多伦多，有大量的前端开发人员职位空缺。 免费代码营的官方立场是，您应该完成所有2,080小时的课程。如果你这样做，你可能会成为一个更强大的候选人（并且在更具挑战性的职位上获得更高的薪水）。 我们来做一些数学： 免费代码营的前端Web开发证书大约需要478个小时。有些人会更快地完成它，但它会根据人员的准备程度而有所不同，所以让我们保持478作为我们的基础。 什么不到一年？为了论证，我们将工作9个月。 9个月* 30天给我们270天。 478小时/ 270天每天约1.8小时。这意味着我们可以每天少于2小时，在9个月内我们可以做好工作准备。 我知道，对于某些人来说，时间表不允许每天有两个小时，但对大多数人来说，可以找到它们。对于其他人来说，可能需要更长的时间，但总会有周末和其他方式来寻找（或制造）时间。 如果您正在寻找有关如何找到编码时间的建议，请不要犹豫，在Twitter上与我联系，我将很乐意为您提供帮助。 我花了比这更长的时间 - 大约一年零两个月。本文分析了为什么它花了我更长的时间。我在文章中犯了我所说的所有错误。当我给你建议时，请记住我也在给自己这个建议。我们在同一条船上。 在我完成免费代码阵营前端课程之前，我被录用了，但我知道这将有助于我成长为一名开发人员，以恢复并完成这些项目。在这里，在那里的文章我已经放在Codepen链接到我的个人资料（我有点惭愧呢！），当在你看看吧，你会看到，我还有很长的路要走。所以我说 - 让我们一起做吧！我的目标是完成所有前端项目，并将其作为我在不久的将来学习的与代码相关的任何事情的优先事项。 这篇文章适合我和你 - 让我们克服不适并优化我们的学习，以便我们能够更快地到达我们想要的地方！ 确保你已经涵盖了你的基础知识我坚信，在你的学习的开始，你绝对应该使用教程和在线互动资源，熟悉HTML，CSS，JavaScript的语法，要学会编程方式思考，并熟悉基本，基础的东西。 试图在没有这些知识的情况下立即建立项目将太令人沮丧。确保你不要在这个阶段花太多时间，因为它很容易做到。 当我学习HTML / CSS / JS时，我会去学习来自不同资源的类似主题，认为这会填补我所知的所有空白。它确实填补了一些空白，但在某些时候，我意识到我正在使用这些资源作为拐杖，以防止我转向新的，更令人兴奋的，但有点可怕的东西。不要陷入无休止的循环（可能是一段时间循环？;）审查和重新审视您已经知道的信息。 不要屈服于合理化当您开始创建项目时，您将不可避免地陷入困境。如果坚持下去，过了一会儿就会克服障碍，但不久之后你会再次击中障碍物。这不是一个选择，它发生在每个人身上。 在这样的时刻，我们身体的每一个部分是尖叫 - 让我们做别的事情，让我们从这里开始运行，这是使我感到不舒服，我可以解决这个后来当我知道更多，我会回来的，等等。所以我们暂停一下。 但是，我们担心我们的暂停会延长，我们会继续编写越来越少的代码并放弃它。为了不让这种情况发生，但仍然保持我们的“决定”不在项目上工作，我们决定现在，我们将通过一些教程或在线课程。 从创造中理解自己很容易。没有人会告诉你，你不会以任何方式学习编码或批评你。你是唯一能够识别真实情况的人（恐惧，厌恶风险，抵抗），并决定坚持从事项目工作。 相信我，如果你敲打它们，所有的墙壁都会崩溃。想想那些在当天学习外语的人，他们用本地语言和目标语言制作同一本书的两本。他们是怎么做到的？他们只是坚持了足够长的时间。 不要从你的BIG IDEA开始令人惊讶的是你已经拥有它，但是在这里有一些其他的考虑可能会改变你的想法。我提出的原因是点埃斯塔那我保留这个听到了很多来自人：“我想建立一个在线应用程序，让人们为他们的宠物创建帐户，上传照片，轨道位置和许多其他的事情。我最近开始学习的代码，我在建设出我的想法的过程是了。“这让我走”哇喔哇。“ 我可以很容易地看到的情况。在这种情况，一个人被过量使用的想法，他们开始很热情，并慢慢建立出来，但随着时间的推移，他们的学习跟不上随着项目的需求，而且感觉拖延，始终在他们的思想背后，未完成。 在这种情况下可能发生的最糟糕的情况是，该人将放弃该项目，并放弃编码。 我建议先从简单的项目，并且完成他们每个人，你会得到一种成就感，并更好地了解如何构建一个更大的项目。 想象一下，你是一名作家，并且对于你生活中的一本重要书籍有了一个想法，并且你已经开始立刻写作了。你可能会不得不重新改写整个事情的3-4倍，以得到它的质量的一个体面的水平，而你可以用小作文的故事开始，得到的反馈，可以提高写作和接近你的白鲸当你真正准备好了。 我知道，对于某些人来说，时间表不允许每天有两个小时，但对大多数人来说，可以找到它们。对于其他人来说，可能需要更长的时间，但总会有周末和其他方式来寻找（或制造）时间。 如果您正在寻找有关如何找到编码时间的建议，请不要犹豫，在Twitter上与我联系，我将很乐意为您提供帮助。 我花了比这更长的时间 - 大约一年零两个月。本文分析了为什么它花了我更长的时间。我在文章中犯了我所说的所有错误。当我给你建议时，请记住我也在给自己这个建议。我们在同一条船上。 在我完成免费代码阵营前端课程之前，我被录用了，但我知道这将有助于我成长为一名开发人员，以恢复并完成这些项目。在这里，在那里的文章我已经放在Codepen链接到我的个人资料（我有点惭愧呢！），当在你看看吧，你会看到，我还有很长的路要走。所以我说 - 让我们一起做吧！我的目标是完成所有前端项目，并将其作为我在不久的将来学习的与代码相关的任何事情的优先事项。 这篇文章适合我和你 - 让我们克服不适并优化我们的学习，以便我们能够更快地到达我们想要的地方！ 确保你已经涵盖了你的基础知识我坚信，在你的学习的开始，你绝对应该使用教程和在线互动资源，熟悉HTML，CSS，JavaScript的语法，要学会编程方式思考，并熟悉基本，基础的东西。 试图在没有这些知识的情况下立即建立项目将太令人沮丧。确保你不要在这个阶段花太多时间，因为它很容易做到。 当我学习HTML / CSS / JS时，我会去学习来自不同资源的类似主题，认为这会填补我所知的所有空白。它确实填补了一些空白，但在某些时候，我意识到我正在使用这些资源作为拐杖，以防止我转向新的，更令人兴奋的，但有点可怕的东西。不要陷入无休止的循环（可能是一段时间循环？;）审查和重新审视您已经知道的信息。 不要屈服于合理化当您开始创建项目时，您将不可避免地陷入困境。如果坚持下去，过了一会儿就会克服障碍，但不久之后你会再次击中障碍物。这不是一个选择，它发生在每个人身上。 在这样的时刻，我们身体的每一个部分是尖叫 - 让我们做别的事情，让我们从这里开始运行，这是使我感到不舒服，我可以解决这个后来当我知道更多，我会回来的，等等。所以我们暂停一下。 但是，我们担心我们的暂停会延长，我们会继续编写越来越少的代码并放弃它。为了不让这种情况发生，但仍然保持我们的“决定”不在项目上工作，我们决定现在，我们将通过一些教程或在线课程。 从创造中理解自己很容易。没有人会告诉你，你不会以任何方式学习编码或批评你。你是唯一能够识别真实情况的人（恐惧，厌恶风险，抵抗），并决定坚持从事项目工作。 相信我，如果你敲打它们，所有的墙壁都会崩溃。想想那些在当天学习外语的人，他们用本地语言和目标语言制作同一本书的两本。他们是怎么做到的？他们只是坚持了足够长的时间。 不要从你的BIG IDEA开始令人惊讶的是你已经拥有它，但是在这里有一些其他的考虑可能会改变你的想法。我提出的原因是点埃斯塔那我保留这个听到了很多来自人：“我想建立一个在线应用程序，让人们为他们的宠物创建帐户，上传照片，轨道位置和许多其他的事情。我最近开始学习的代码，我在建设出我的想法的过程是了。“这让我走”哇喔哇。“ 我可以很容易地看到的情况。在这种情况，一个人被过量使用的想法，他们开始很热情，并慢慢建立出来，但随着时间的推移，他们的学习跟不上随着项目的需求，而且感觉拖延，始终在他们的思想背后，未完成。 在这种情况下可能发生的最糟糕的情况是，该人将放弃该项目，并放弃编码。 我建议先从简单的项目，并且完成他们每个人，你会得到一种成就感，并更好地了解如何构建一个更大的项目。 想象一下，你是一名作家，并且对于你生活中的一本重要书籍有了一个想法，并且你已经开始立刻写作了。你可能会不得不重新改写整个事情的3-4倍，以得到它的质量的一个体面的水平，而你可以用小作文的故事开始，得到的反馈，可以提高写作和接近你的白鲸当你真正准备好了。 哪里可以获得项目的想法我所知道的最好的地方是Free Code Camp。这就是我被完全卡住后使用的东西。在编码之旅的开始，我会问我认识的开发人员（离线和在线）我的第一个项目应该是什么。当我说（惊喜）他们都说它应该是待办事项列表应用程序时，我不会欺骗你。老实说，如果我们继续制作这些待办事项列表应用程序，他们很快就会过度拥挤整个互联网。 免费代码营帮助我发现它是一系列激动人心的项目，排列在一系列日益增加的难度之中。另一个伟大的事情是，他们每个人是专门设计来教你一个特定的主题，例如：致敬页将你的HTML / CSS技能的测试，显示本地天气会教你如何搭配的API，建立一个JavaScript显然，计算器将提高你的JS技能等。 这是我所知道的最强大的起点。对于所有项目，您可以从社区获得反馈，以及了解其他人如何与他们接触（在您建立自己之后，而不是作弊！） “或者类似的东西。 首先构建项目在开始构建之前，请写出您希望它执行的操作。编写特定的用户故事，例如：“用户可以在点击音频播放器按钮时播放音频”，“用户可以使用他们的电子邮件和密码以及仅使用Facebook登录”。 在开始编写代码之前，代码也必须具有基本结构。用伪代码写 - 基本上只是解释应用程序的一部分或项目代码将做什么。 基本示例：//当用户打开页面时，抓住他们的位置//使用位置向weather API站点发送请求//接收数据//在页面上显示度数//更改页面的背景图像以反映当前天气 不要过度，不需要先写出你的代码在伪代码中做的每一件小事，但是你已经完成了主要部分。 我可以为您提供的是最好的例子：记得当你正在写在学校的文章，你必须构建他们首先，例如，在介绍关于这个问题，在支持你的意见的3个主要的点您的意见和结论。 这有助于您预测潜在问题并提高代码质量。 卡住是可以的正如我之前提到的，可以卡住。这并不意味着我们是愚蠢的，它只是意味着我们还不知道。你将永远经历陷入困境的时刻：不仅在你学习的时候，还在工作中。 你越快感到不舒服就越好。它会让你的进步更快。编程本身就是创造性地解决问题如果没有难以解决的问题，那就意味着要安全地玩。停止在浅水中踩踏并潜水！ 最重要的是，我将再次重复这一点，不要认为自己是愚蠢的。我知道在这些时刻很容易做到。我经常跟人通过免费代码阵营的HTML / CSS / JS部分容易去了，淘汰了一天30-40项，然后他们获得基本的和中间的算法和发现，他们只能做1每天5，所以他们得出结论，他们卡住了，他们是愚蠢的，不够好，或者不打算成为开发人员。 我也是这样，我觉得有些人，可能只是飞过这一部分，我对自己和我的进步感到不好。现在我知道的更好。 我在这里想说的是你应该学会： 在你的头脑中你必须找到那种让你处于“容易的事情”和“仍然太难的事情”之间的项目难度。 我已经谈了很多关于为什么它的危险，保持审查和重新学习相同的材料（容易的事情），所以让我们来谈谈等式的另一侧的原因：困难的事情。 在接近困难时你的一般规则 - 你认为你可能无法做到的事情 - 应该是先尝试做。 从基本结构开始，尝试编写代码。如果你坚持同样的事情超过三天专注于它，放弃它一段时间，找到类似的 - 但更容易 - 事情要做。 我发现，在我这样做之后，我的潜意识仍然专注于解决我遇到的问题。当我做一些简单的事情时，我会得到这些关于如何解决它的随机想法 - 比如洗澡或洗碗 - 它突然袭击了我！ 有时它的工作方式正是如此。有时它没有。但这里的主要建议是 - 总是挑选让你有点不舒服的东西。其他任何东西都不值得你花时间。 弹性我想和你分享我最喜欢的一句话： 弹性 - 系统容忍干扰而不会坍塌，承受冲击，在必要时重建自身，并在可能的情况下自我改善的能力。这是一个令人惊叹的品质，你作为一个程序员（以及一个希望在生活中取得成功的人）应该努力发展自己。准备好所有问题，所有挑战，对工作，设计，解决方案的所有批评以及在事情发生之前可能做的任何其他事情。 你害怕登台吗？注册以向当地社区的人员讲述Web开发的基础知识，或者报名参加会议/技术活动。 你对面试的方式感到失望 - 之后你没有被录用吗？您是否担心开始学习编码为时已晚？你对这个项目满意吗？ 重新构建所有这些：您可以从经验中学到什么，以便下次更好？你怎么能把你的弱点变成优势？ 例如，您可能会担心在X年的另一个职业道路上，您来编码太晚了。通过思考不同的视角和成熟度，在您的脑海中重新构建您将引入迫切需要更多成熟人（心理学）和更多不同背景的行业？通过决定进入它，您正在使科技行业变得更加富裕！ 如果你听到内心的声音说“你不能画画”，那么无论如何都会画画，那声音就会沉默。 - 文森特梵高我可以推荐的增加弹性的是这三本书： 塞内卡的“斯多葛派来信”Ryan Holiday的“障碍是道路”Steven Pressfield的“转向Pro”设置每日有时限的目标为了更快地进步，您应该每天处理您的项目。那部分只是常识。但是，您应该记住一些其他注意事项。 而不是设置结果目标（“我将完成此功能或今天的那部分”），设置一个明确的时间段，您将每天花费编码。不要每天超过30分钟或一小时。 我知道你想承诺每天3小时编码，并努力坚持下去。这有效，但只有这么长时间，直到生命发挥作用。有一个合理的时间限制 - 比如一天30分钟 - 你总会知道它可以完成，并且你总是有半小时的时间来完成编码，特别是如果你的主要目标是学习编码。你会发现自己在某些日子里编写的代码更多，这将是很棒的，因为你将完成当天的配额。 这个时间限制更多的是一种心理伎俩，因为我们的大脑连接的方式。还记得那个时候你有一个你需要开始的大项目，但你一直拖延和延迟，直到你有足够的时间在截止日期前完成它？你没事，但在此之前你一直都很紧张。然后加上这个事实，没有人让你成为开发人员的最后期限。那不是一个，而是你。 当我们设定结果目标时会发生什么，我们无法估计完成该功能或此功能所需的时间。而且通常情况下，我们最终没有完成我们今天要做的事情。这让我们觉得很糟糕，并且减少了第二天坐下来编码的愿望。 每天有一个有时间限制的目标，你每天都会取得进步。谁在乎你是否还没有完成今天要包装的特定功能？你取得了进步！你出现了。这就是让你领先的原因。 另外一个很大的好处就是11，你坐下来开始编码，想法和解决方案将开始流动，好像无处不在（类似于写一篇文章，嗯？:)。一旦你获得不切实际的期望和恐惧，就会更容易让自己坐下来编码。 复制代码浪费时间在建立项目的过程中，在开始时 - 当你不知道从哪里开始，或者在你遇到问题的后期，你无法轻易解决 - 你会有强烈的外表欲望在项目的源代码中查看它是如何完成的。您将合理化它将使您立即理解代码，这意味着您已经学习并吸收它。远非它。 不要复制整个项目并自定义它们。不要采取部分代码。甚至不要拿它的碎片。 有了项目 - 首先不要看代码。使用您在Stack Overflow上查找的内容，查看，分析，理解，然后从头开始自己编写代码。你会发现即使在你看到整件事之后也很难自己写。 这是故意练习与常规练习（重复）的不同之处。 10,000法则的主要内容是这种做法必须是慎重的。以下模板和现成的解决方案不会带您到任何地方。如果你这样做，有人可能会写入Python脚本，无论你在做什么，都会取代你。注意看起来对你来说很难的事情。 另一个偏离主题的想法是，如果你挣扎于某一特定主题，尝试将其教给别人，或者只是按照你理解的方式向他们解释。结果将跟随您和学习者。 复制代码会让你有机会学习如何自己学习，而且这并不比通过教程更好。是的，解决方案就在那里。是的，如果你愿意，可以带它。但重点是什么？您是否试图以您构建项目的速度给某人留下深刻印象？或者您是否试图避免需要一些时间来解决的难题？ 无论你的理由是什么 - 它只是回到我们试图摆脱的温暖舒适的另一种方式。反其道而行之跑到不舒服。 在您完成项目之后，唯一可以查看其他人的代码是可以的。然后看你想要的东西，分析它，并从中学习。 您解决的每一个难题都会让您实现跨越式发展。 不要分散你的努力我对此非常内疚，这实际上是我为自己写的比其他人更多的建议（对不起！）。当你开始处理一个项目并碰到我提到的那些墙壁时，你很想把这个项目搁置起来并开始一个新项目。 一开始总觉得很棒，直到你用第二个项目撞墙。那么你手上就有两个未完成的项目。如果你愿意，这将一次又一次地重复。 这里的解决方案是一次限制自己2个项目。一旦你陷入困境，花点时间搞清楚。但如果此刻似乎无法破解，那就转移到你已经拥有的另一个项目。关键是不要开始第三个，因为它是一个滑坡。 你应该总是尝试做任何可能的事情，让自己留在学习的道路上。如果你感到厌倦，或者对你目前正在做的事情感到厌倦，请稍微休息一下，调整一下，然后再回过头来。不要完全放弃编码。 这就是为什么我总是建议有一个小小的摆动空间，这是一种不同学习资源（限于一周）的临时分心，或者，在这种情况下，两个项目而不是一个。 你的投资组合将是你得到的招聘经理或工程师很难根据您在简历中写下的内容来评估您的技能。 “我知道JavaScript！ （并有4年的经验）。“”告诉我！“（我真的不得不停止使用Matrix参考）。 您构建和投放的所有项目都包含您的终极现场简历。任何人都可以看着它，并确信你确实知道自己在做什么。 不要害怕，这并不意味着你的代码应该是他们甚至考虑你的理想选择。这些项目将帮助任务的人员正确评估您的技能水平。 您不必经历高于您的级别的面试，因为一些人力资源人员在您的简历中找到了一组特定的关键字。您的雇主的期望将更符合您当前的能力。 在线工作的积极好处包括： 雇主看到你知道你在做什么他们看到你一直在努力提高自己的技能事实上，他们认为你是开发人员，并且你足够勇敢地将你的工作放在网上供所有人看。根据我的个人经验，以及我在多伦多免费代码营组中的人们所听到的情况，找到编码工作的最重要因素是他们的项目组合。 你会在面试中做得更好在采访中，您可能会获得一个真实的小型Web应用程序或要构建的页面，或者要解决问题。 通常有这些问题的人，正在招聘的人正在寻找如何通过解决问题来思考。他们并不总是想要产生理想的解决方案。有时他们会提出无法解决的问题只是为了看看你会做什么。您将通过项目获得大量此类练习：每个项目都将充满这些小问题。 至于你可以建立的现实生活中的东西，它可以而且会有所不同。这是我在面试当前的位置时必须要建立的。我知道代码不是很好，但这应该让你知道会发生什么。我在面试当天能够完成它的唯一原因是因为我以前有通过Free Code Camp构建天气应用程序和计算器之类的经验。 您将确定您的知识中的真正差距这里是教程等对你起作用的地方。它们会让您感觉到，当您完成它们时，您已经涵盖了您需要了解的有关该主题的所有内容。但是当你尝试自己构建一些东西时，你会立刻陷入困境 - 通常是非常简单的东西。 那是为什么？因为在教程中提供给您的信息的部分是由使用他们自己对人们可能正在寻找的内容的理解创建它的人选择的。而且因为根本不可能涵盖教程中的所有内容。 真正看到你缺乏什么知识的唯一方法就是随时随地发现它的差距。你不知道你不知道什么。所以这个过程是：去，撞墙，解决问题，继续前进，等等。 每个新项目都会吓到你。怎么办？我不了解你，但与我同在，它总是发生。我完成了一个项目，并对自己和我的技能感到满意。然后，当我读到下一个项目的用户故事时，我因恐惧而陷入瘫痪。 我发现自己在想 - 我怎么能开始呢？我该怎么办？我怎么能完成前一个？我什么都不知道！ 切换完全恐慌模式 当我遇到这种情况时，我会使用几种技术： 首先，看看你构建的所有以前的项目。他们也非常恐怖。不知何故，您找到了解决问题并构建这些项目的方法。 当你处于一个低自信时刻时，回顾你过去的成功是一种强大的方法，可以让你自己重新站起来，为新的挑战做好准备。 关键是要将项目视为一系列要解决的微小问题。我们只会感到害怕，因为我们完整地看到整个冰山，它正朝着我们的方向发展。但是，如果您使用我们之前讨论过的技术 - 将项目分解为基本结构 - 它将非常容易上手。 忘记完美主义你不是这样做的，以创造一些理想的，令人惊叹的项目，代码如此美丽，它将使有经验的开发人员哭泣。 我们的目标是做什么必要：履行您已获得（或为自己曾经创造）的用户故事，让你可以学习的编码技术/语言功能/框架如何将某些工程力学，是它的API，功能，承诺等 然后尽可能多地改进项目 - 包括设计，功能和代码质量。 但在某些时候，让自己停下来。这不是一场国际艺术比赛。这是你和你想要学习的主题。不要让主题吓到你，你甚至无法开始。 极端需要完美做事的人往往是那些完全没有做任何事情的人。 我无法从这篇文章开始，例如，如果我花了太多时间担心它是好还是坏，更不用说完美了。我知道这是一个重要的话题，很多人有兴趣，那我需要写什么，我到目前为止，希望它会帮助别人，使他们的编码和轻松的旅程发现。 如果一切都必须完美，艺术中的草图会不会有任何地方？毕竟，不完美是使它们独一无二的原因。 让你的创造力流动！如果您正在使用在线找到的描述和示例，请不要觉得您的项目与您在页面上看到的完全相同。编程既是艺术，也是科学。 如果你正在做前端，那就更加认真地对待这一点。 如果您正在制作随机报价机器，请让引号来自您最喜欢的角色。如果您正在制作游戏，请将声音和设计放在您想要的任何地方！ 太奇怪了。让你所有的怪癖和你个性的独特差异出来。释放你的真实自我 专注于完成所有用户故事，但其他一切完全取决于您。 这是我构建的Zen计算器，作为我所谈论的一个例子。当然，你可以获得更多的创意。原件在这里，虽然它已经更新。我工作的版本提醒了更多的iPhone计算器应用程序。 网络 - 以及一般的编程 - 让我们获得自由。永远不要让自己退缩无论你想做什么，做任何你想做的事，让这些溢出到你生活的每一个部分，包括编码。 这是一些灵感，并说明我的意思： 当你为他们增添个性时，事情才会有所体现！比较超现实主义画家和毕加索。你能通过观察他们的作品来区分超现实主义画家吗？我非常怀疑。然而，你会马上知道毕加索的画作。让你思考。 偶尔屈服于分心有时可以从项目中稍稍休息一下，但为此你必须有一些规则。 理想情况下，您的注意力不得超过一周，无论是课程还是教程，还是其他任何事情。它应该是您想要学习的特定主题，最好连接到您需要知道的东西以继续完善您的项目。 否则，如果您在上下班途中阅读编程书籍或观看编码视频，或者在无法访问互联网的某个地方等待，那么对我来说完全没问题。 只要确保当你回到你的办公桌时（或者你可以从哪个地方来，可能是一张床，对吗？），你回到真实的东西。这是你的实践。 获得有关您的项目的反馈除了帮助您填补知识空白之外，项目还为您提供了一个可以与世界分享的工件，征求建设性的反馈意见。 小心你与谁分享你的项目。不要让过度批评的人进来。尝试找到真正的开发人员，或者还在学习的人，但已经比你更先进了。让他们检查您的代码并提供他们的反馈。你可以改进什么？什么有用？什么不是？ 这将进一步加速您的学习，因为这些善良的人将帮助您发现您自己无法找到的见解。 我希望我已经确信，到目前为止，构建实时项目是学习编码的最有效方式。 我个人注意到，我建立的时期 - 而不是观看，阅读或通过在线课程 - 是我学习最多的时期。我希望你的经历与我的相同。 祝你好运！请随意在本文的评论中添加您的建议，并在此处分享您的项目。 随机说明：我在听Tron：Legacy Soundtrack时写了这篇文章。 如果您喜欢这篇文章，请点击❤在Medium上推荐它。这对我来说意味着世界！ :) How to Get a Developer Job in Less Than a Year]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Soup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learning-to-Code]]></title>
    <url>%2F2018%2F08%2F29%2FLearning-to-Code%2F</url>
    <content type="text"><![CDATA[Learning-to-Code 一些有用的心灵技巧解决你最内心的恐惧 我们来谈谈如何保持正轨。当你觉得有太多东西需要学习时，如何继续学习。当你感觉自己从未获得第一个编码工作时，如何继续前进。 你发现自己在想：“也许我不是因为它而被切断了？” 这就像跟着你，模糊和歪曲事实云，因此它可以呈现的状况是多么糟糕无望如果那样的话，并和怎么也没有办法，你可以做到这一点。 嗯，我不知道你，但对我来说，这种情况每4-5天发生一次。 自2014年11月以来，我一直在学习编码，慢慢沉浸在这个领域。我使用了各种资源：书籍，在线课程，在线挑战，博客文章，教程等。freeCodeCamp对我的学习产生了很大的影响，通过对编码进行积极的转变，以及一条前进的明确路径。 在那段时间里，我经常不得不打击我的思想，吓跑我。我几乎可以肯定你也会经常遇到这种情况。 史蒂芬普莱斯菲尔德埃斯塔力在他的书艺之战有句名言被称为“抵抗”。我强烈建议你“读这本书。我发现自己每天都在使用它的课程（有些日子甚至是小时）。 在这篇文章中，我将分享一些心理技巧，用于消除消极性“云” - 抵抗 - 这可能是如此难以击败。所有的建议都是基于我到目前为止所学到的，如果你有其他想法 - 请在这里分享！ 我将跳过最常见的激励建议（通常过于宽泛而无法采取行动），并专注于不寻常但有效的建议。我已经使用了这些技术并发现它们有效，我希望你也会这样做。 意识到每个人都经历过抵抗在学习新技能时，许多人认为如果事情没有顺利进行，那就不适合他们。我们总是幻想在我们的如何，对某些人来说，一切都自然地流淌思想，只是他们迅速向前滑行所有的表面上，而不会遇到在他们的旅程的任何问题和障碍。 这不可能是事实。他们可能难以克服我们可能甚至不知道的事情。他们可能会被拒绝，失望，他们可能会感到绝望。我们不知道。不要以你想象的另一个人的旅程的标准判断自己。 当然，有一点可能会吃他们更容易，这可能是编码，但我向你保证，还有其他的10件事情，他们都希望自己能做得更多，但仍然轻松挣扎。 （为了让你了解这个抵抗力量有多强大：我在2015年12月开始写这篇文章。是的，我知道。） 如何练习：不要再考虑困难，因为围绕着你建造的这些墙壁让你不能去你想去的地方。将它们视为实现目标的障碍 - 让您变得更强大的挑战。 不要让自己相信你经历这些情感这一事实意味着你不会因为编程而被裁掉。每个人在尝试学习新的东西时都会遇到同样不舒服的情绪。推动你的界限和你所谓的“限制”（嘘没有勺子）是痛苦的。 你觉得什么是抵抗。 它很自然，如果你用它作为你的指南针它可以成为你的朋友。这是一个告诉你正走在正确道路上的标志，也是个人成长的道路。 每天都在计算当看到已经在技术领域的人时，很容易（相信我这一点）变得气馁。如果你专注于拥有数千名粉丝的开发人员以及对主题的大量了解，那就更容易让人气馁。 问题在于，这些是您在Twitter上看到的人，或者是谷歌搜索视频，教程和编码文章的结果。 您很少看到了解该领域98％左右的常规开发人员。 我并不是说你的目标应该是成为98％中的一员。 （你应该比这更进一步）。我要说的是，它很容易自己吓到，以为是有隐喻的大峡谷，你和专业的开发人员之间。 所以，你已经花了几个月的学习代码，但它好像你还是那么远从正反那你想知道：怎么可以这么遥遥领先他们？我有什么希望能够达到这个水平吗？ 嗯，这是你的思想在你身上耍花招的地方。你不看专业的小提琴家，并认为对自己说：“哦，我一直在学习，现在打了一年小提琴，为什么我不能望其项背在执行自己的水平？” 但是通过编码，我们中的许多人每次都这样做。 你认为一个你认为是一个可靠的开发人员的人会忽略那个人的其他一切。你想：“这很简单。他们是一个伟大的程序员，我不是。就是这样。“ 你不考虑如何可能有一个人与编程或数学奋斗和努力克服这些困难，或有可能下班后花了试图理解卡住的错误消息，并且担心同样的事情，你是无数个夜晚。或者他们如何在全日制大学学习软件开发方面花了4年时间。 没人说这很容易。学会做好事需要时间。很多时间。抵抗基本上告诉你，他们在那个级别怎么样，你不是？怎么了？应该很容易，必须有快速的方法，快捷方式，秘密，东西！ 提醒自己，没有什么东西是无用的东西。关键是你应该知道你有可能到达那里。需要时间，是的，但那又怎么样？所有有价值的事情都需要时间。 如何练习：这是我学习编码和技术的主要难题之一。如果没有这个，我可能已经放弃了编码，就像我放弃了多年来我试图学习的许多其他东西。 在这里，它是：想象有多少人摆脱了那些已经开始了大致相同的一天编码上像你一样已经停止 - 或将退出今天 - 在同一诱惑让步停止的痛苦和学习的不适。 想想你在旅程中发展的力量（心理，情感）。每当你做出更进一步的决定时，你的意志和韧性就会增加，不要停留在你的位置，不要承认失败。您每天编码都是您赢得的那一天。 全力以赴因此，您已决定自学编码。什么阻止你在6个月没有看到你想看到的结果后退出？ 你需要一个目标来努力。一旦你的目标，这将是难以停止，而不是一个情况涉足如果您正在使用的代码，或不特定的，定义明确的目标，学习。 我最初的目标是找到一份编码工作。这花了我大约14个月的时间。我在当时的营销全职工作，所以整天晚上我无法代码，但我试图在尽可能多的时间去挤，因为我可以编码到每一天。 明确目标的另一个好处是，您可以更轻松地在想要学习的主题之间进行选择。我相信这将是主要的JavaScript技术我在在职使用，所以它更容易说不改道成Python，Ruby和其他语言。 重点关注你的努力。如果它们看起来像风玫瑰，将单个光线带入中心，您就会变成激光。你知道激光器的效果如何。有时，我们都需要收集试图向四面八方传播的光线，并将其重点放在我们的目标上。 一旦你决定了你的目标，全力以赴。花费尽可能多的时间来编码。 谁在乎您是否有所有日子或每天只有1小时？如果你没有它，你有多少时间或没有多少都没关系。 我读过的人照顾小孩和学习的代码时，他们有片刻的故事，但我没有看到的“一个故事，我怎么有我的天免费一年，我还是没能学会编码“。你知道为什么吗？这些人没有故事可讲。 使用您“不知道你有时间：在编码下载有声读物，听它，得到一本书，读它在地铁或公共汽车，如果你上班地点或其他地方。尝试使用多种类型的学习，但请确保您遵守相同的主题。 不要过头，成为气馁 - 如果你觉得你不能拿的JavaScript或Python（或任何其他受你关注）了，一天的休息放松，做别的事情。 我想传达的概念是，如果你担心你没有足够的时间去学习的代码，这可能只是你的担心是骗你的。这发生在我身上 - 我常常会想：它需要多长时间我学习ESTA而全职工作？我有没有机会坚持到底？ 请记住，你今天付出的努力越多（不打算明天投入），你到达那里的速度就越快。 如何练习：确定一个具体，切合实际的目标。一个定义明确的目标将是：“我想找到一份工作，前端Web开发的未来12个月内”或者说：‘我将创建3个单独的iOS应用在接下来的8个月里。’ 尽可能使用，并将所有精力集中在学习编码上。为什么呢？因为它是不容易的，时间越长你传播因为你的学习时间（除非你有具体时限的目标），你就越有可能会成为的“进展缓慢”的感觉气馁。 你足够聪明。我开始学习之旅时的另一个大恐惧是，我不够聪明，无法比较那些花时间解决数学，物理和编程问题的人。他们在3岁时开始编程，并在5岁时构建编译器。 我误以为编程中的每个人都是拥有博士学位的工程师。来自常春藤联盟大学，对我来说已经太晚了。 首先，我已经知道科技行业中有这么多人，他们有不同的编码途径。所以我可以开始相对较晚。 其次，更重要的是，我仍然担心“如果我不能在那里获得最好的软件工程工作怎么办？”就像Google和Facebook一样。起初我可能不会，但我会全力以赴达到这个水平。 我确信的事情是 - 如果一个人长时间保持编码并使练习刻意 - 他们将达到他们渴望的任何水平。 通过刻意练习，我的意思是： 检查代码中的错误和问题回到某些问题并试图以更好的方式解决它们阅读其他人的代码，看看他们是如何解决这些问题的重构你的旧代码简单地说：做返工而不是尝试新事物并一直切换主题。 如何练习：相信我，你足够聪明。相信你是，并且不要让“我不够好”的想法溜进来。它们本质上具有破坏性。 我将与您分享一个肯定，我不在乎您对肯定的看法： “我配得上生活中最好的一面，我可以做任何我梦寐以求的事情！” 如果你发现自己害怕自己不够聪明，那就重复一下这个肯定。每当恐惧得到你的想法，或者你需要的那一天多次，你可能想要重复它5次。你的思维就像粘土一样，你的工作就是训练它并将它塑造成你的朋友。 看看我们我们和你一样。所有人都渴望编码并变得更好。我们都有同样的恐惧。 如果你将它作为一个专业的开发人员，最终的因素不是你的智商或你的“代码才能”，而是你的弹性和勇气。 有一座山 - 珠穆朗玛峰，更高的机会，你会不会做它，你会吓跑你自己，因为出来的成功，而不是不被其他一些人一样聪明（你的项目或人在谁在你的心中非凡的光彩）。 如果您对自我形象感兴趣，以及它与成功的关系，我建议您阅读Maxwell Maltz的Psycho-Cyber​​netics。 不要浪费你的努力每当学习变得困难时 - 就像你在学习基础知识后开始学习中间部分一样 - 你会发现自己正在探索其他不那么密切相关的编程领域。 如果你专注于Ruby，你会突然开始发现Swift如此迷人和精彩，而且非常神奇。 那么如何保持正轨，同时也不会对同一主题过于厌倦？ 如何练习：首先，提醒自己你的目标。接下来，我的建议与您可能认为的相反。我说 - 去那个短暂的蜜月与那个新的令人兴奋的主题！ 我建议您在接下来的几天里探索引起您兴趣的新亮点。没关系。 我用Ruby做过。我用Python做到了。然后，在那个喘息之后，我会提醒自己我的目标 - 寻找编码工作。我想：探索这个和那个会很好，但是我真的想在这一点上做得更好，所以我最好再一次关注它！我会以新发现的能量和热情回到学习JavaScript。 如果你不允许自己这样的呼吸怎么办？长时间研究一个主题就像节食一样。你会做得很好，很好，很开心，直到有一天你休息，再也不能接受它。比如说，你从一个完全不同的主题开始这个为期6个月的学习之旅，结果却发现你还没有掌握你尝试过的许多主题。 另外，值得深思：你从来没有听过“我用Ruby，JS，Python，C ++和Java编写代码，然后开始我成功的编码生涯”的故事。 为了开始，你应该至少有一件令人惊奇（或至少是好的）的东西。选择它，追求它，只允许自己短暂的转移，以保持你的理智。 数量一致性当我们决定采取大的东西，喜欢学习的代码，我们通常会令“新年决议”的思想下星期一我们会下班后每天花费3-4小时学习代码的错误。 接下来发生什么？我们做了两天，然后我们被邀请参加一个朋友家吃饭，错过了一天，感觉太可怕了，我们只开始了几天后再次编码或更多已通过 - 如果我们回到它。 我们需要明白，缓慢但更加一致的进步总会胜过跳过几天的人的进步，然后试图通过塞满一整天，或者拉一个全能者来弥补它。 每天学习15到30分钟比周末学习10个小时要好。你会记得更多 - 并且学得更快 - 如果你每天都回来，而不是你想要记住你一周前所做的事情。 我知道这是常识，但是当我们从更快地获得更好的愿望中获得灵感时，我们常常会忘记这一切。 如何练习：制定明确的“亮线”规则，每天至少编码30分钟。如果你能做得更多，那就去做吧。但是，如果你已经完成了30分钟的工作，那就给自己一个当天感觉完成的许可。 因此，您的努力将变得更加一致，您将更快地实现目标。 不要欺骗自己相信你必须回到大学或支付训练营才能成为开发者。事实并非如此是的，有很多人通过回到大学获得第二学位或参加面对面的训练营来进入软件开发。但猜猜是什么？通过独立学习，有更多的人进入这个领域。所以不要让自己忘记这一点。 如何练习：不要再担心这一点了，并且知道可以在没有做任何这些事情的情况下获得编码工作。 如果你可以获得学位或通过编码训练营，你可以考虑这样做。如果你做不到，不要让你沮丧一点。 此外，你花时间为自己感到难过的时间（我知道我已经做了很多），你可以花时间编写代码和学习。 好消息是对优秀的开发人员有很大的需求，并且有大量的免费资源。freeCodeCamp是一个很好的起点。 寻找志同道合的人好的，这可能与您在每篇关于此主题的文章中找到的建议相同，但它很有意义。去黑客马拉松和其他技术活动。 首先，您将了解更多人并了解他们的故事。它将帮助您了解人们采用的数百万条不同的路径将它们带到现在的位置。 其次，您将会询问您所有的问题，并希望能够帮助解决您正在处理的项目遇到的任何问题。 虽然这些技术活动对初学者知识水平的人来说似乎有些吓人，但不要担心感到愚蠢或者不理解任何事情。大多数这些活动都欢迎初学者。 是什么让我意识到编码事件的重要性如下。 2014年底，我找到了freeCodeCamp。它的发展还处于早期阶段。该网站有一个城市列表，其中有一群人聚在一起学习编码，称为露营地。它还有关于在您所在城市建立露营地的说明，如果它还没有。 那时多伦多没有一个。我喜欢组织东西，所以我想：“哇，这是个什么样的机会！”我很快就创造了一个。 我很惊讶地看到人们开始加入新营地的速度有多快！随着团队的成长，我决定创建我们的第一个活动。 今天我们正在接近六月份的“周年纪念”聚会，这真是令人惊叹。该小组现在有800多名成员，我很享受我们的每一次会议。 最后，有一种社区感，不仅是我学会分享我的经历，我还遇到了我能在任何地方找到的最好的人。那些有兴趣发展自己，变得更好，做新事物，学习，并且通常会从生活中获得更多生活的人！ 我认识的一些人是我真正的好朋友，我喜欢和他们以及参加活动的人分享资源，挑战和想法。 如何练习：去编码活动，例如Free Code Camp的咖啡和代码活动，其中的重点不仅是编码，还关注社区意识。 我不知道你住的地方有哪些活动，但我很确定你会在你所在城市的freeCodeCamp露营地找到当地的咖啡和代码活动。 如果还没有，你知道该怎么做。 阅读其他人的编码起源故事阅读其他人学习编码的方式既有信息又有动力。您可以快速了解他们的情况以及他们使用的资源。 我花了一两个月阅读这些，同时试图决定我应该开始学习哪种编程语言。一旦我决定专注于JavaScript，新的问题是我应该如何学习它。以后教自己和找工作是否现实？ 我会诚实地说，其中一些故事 - 人们花费3个月到昂贵的训练营并在之后找到工作 - 对我来说并不鼓舞人心。我有工作和其他责任，我无法参加。但是，如果您正在考虑训练营，这些故事可能会对您产生不同的影响。 尽管如此，我还是读过一些单亲父母学习编码的故事，以及使用freeCodeCamp，课程，EdX和其他资源自学和成功的人。它帮助我获得了成功的勇气和信心。 如何练习：阅读人们的故事，我保证你会受到启发，你的很多恐惧都会消失。 好吧，阅读够了，去写一些代码:) 如果您有任何关于学习编码的问题，这些问题会在您脑海中迸发出一个漏洞，那么请您离开 - 我非常乐意为您提供帮助！ 如果您喜欢这篇文章，请告诉我 - 这将是我的一天！ 如果您有兴趣，可以在Medium或Twitter上关注我：@ ka11away，我一定会写更多文章分享我的经历！ 非常感谢您的阅读！ Learning to Code: When It Gets Dark]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Soup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker入门]]></title>
    <url>%2F2018%2F08%2F27%2FDocker%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 Docker入门初识Docker什么是DockerDocker开源项目Docker是基于Go语言实现的云开源项目，诞生于2013年初，最初发起者为dotCloud公司。Docker项目目前已加入Linux基金会，遵循Apache2.0协议，全部开源代码均在https://github.com/docker/docker上进行维护。 Docker的主要目标是”Build,ship and Run Any App,Anywhere“，即通过对应用组件的封装、分发、部署、运行等生命周期的管理，达到应用级别的”一次封装，到处运行“。这里的应用组件，可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统或编译器。 Linux容器技术Docker引擎的基础是Linux容器(Linux Containers,LXC)技术（容器有效第将由单个操作系统管理的资源划分到孤立的组中，以便更好第在孤立的组之间平衡有冲突的资源使用需求。与虚拟化相比，这样既不需要指令级模拟，也不需要即时编译。容器可以在核心CPU本地运行指令，儿不需要任何专门的解释机制。此外，也避免了准虚拟化和系统调用替换中的复杂性。） 从Linux容器到Docker在Linux容器的基础上，Docker进一步优化了容器的使用体验。Docker提供了各种容器管理工具（如分发、版本、移植等)让用户无需关注底层的操作，可以简单明了地管理和使用容器。 可以简单地将Docker容器理解为一种沙盒。每个容器内运行一个应用，不同的容器相互隔离，容器之间也可以建立通信机制。容器的创建和停止都十分快速，容器自身对资源的需求也十分有限，远远低于虚拟机。很多时候，甚至直接把容器当作应用本身也没有任何问题。 为什么使用DockeDocker容器虚拟化的好处高效地构建应用 Docker在开发和运维中的优势 更快的交付和部署。使用Docker，开发人员可以使用镜像来快速构建一套标准的开发环境；测试和运维人员可以直接使用相同的开发环境来部署代码。Docker可以快速创建和删除容器，实现快速迭代，大量节约开发、测试、部署的时间。并且各个步骤都有明确的配置和操作，整个过程全程课件，使团队更容易理解应用的创建和工作过程。 更高效的资源利用。Docker容器的运行不需要额外的虚拟化管理程序支持，它是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低。 更轻松的迁移和扩展。Docker容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 更简单的更新管理。使用Dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作。并且所有修改都可以以增量的方式进行分发和更新，从而实现自动化并且高效的容器管理。 Dcoker与虚拟机比较 Docker容器很快，启动和停止可以在秒级实现。 Docker容器对系统资源需求很少，一台主机可以同时运行数千个Docker容器。 Docker通过类似Git的操作来方便用户获取、分发和更新应用镜像，指令简明，学习成本较低。 Docker通过Dockerfile配置文件来支持灵活的自动化创建和部署机制，提高工作效率。 特性 容器 虚拟机 启动速度 秒级 分钟级 硬盘使用 一般为MB 一般为GB 性能 接近原生 弱于 系统支持量 单机支持上千个容器 一般几十个 隔离性 安全隔离 完全隔离 虚拟化与Docker在计算领域，一般指的是计算虚拟化，或通常说的服务器虚拟化。（维基百科：在计算机技术中，虚拟化是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以用比原本的组态更好的方式来应用这些资源。） 虚拟化技术分类 基于硬件的虚拟化（不常见） 基于软件的虚拟化 应用虚拟化 平台虚拟化 完全虚拟化。虚拟机模拟完整的底层硬件环境和特权指令的执行过程，客户操作系统无需进行修改。 硬件辅助虚拟化：利用硬件辅助支持处理敏感指令来实现完全虚拟化的功能，客户操作系统无需进行修改。 部分虚拟化：只针对部分硬件资源进行虚拟化，客户操作系统需要进行修改。 超虚拟化：部分硬件接口以软件的形式提供给客户机操作系统，客户操作系统需要进行修改。 操作系统及虚拟化：内核通过创建多个虚拟的操作系统实例来隔离不同的进行。容器相关技术属于这个范畴。 Docker和传统虚拟机方式的不同之处 Docker的核心概念和安装 三大核心概念：镜像、容器、仓库 核心概念Docker镜像Docker镜像类似于虚拟机镜像，可以理解为一个面向Docker引擎的只读模板，包含了文件系统。 镜像是创建Docker容器的基础。通过版本管理和增量的文件系统，Docker提供了一套简单的机制来创建和更新现有的镜像，用户设置可以从网上下载一个已经做好的应用镜像，并通过简单的命令就可以直接使用。 Docker容器Docker容器类似于一个轻量级的沙箱，Docker利用容器来运行和隔离应用。容器是从镜像创建的应用运行实例，可以将其启动、开始、停止、删除，而这些容器都是互相隔离、不可见的。 容器可以看做一个简易版的Linux系统环境（包括root用户权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序打包成应用盒子。 镜像自身是只读的。容器从镜像启动的时候，Docker会在镜像的最上层创建一个可写层，镜像本身保持不变。 Docker仓库注册服务器是存放仓库的地方，不能将Docker仓库和注册服务器(Registry)混为一谈。 Docker仓库类似于代码仓库，是Docker集中存放镜像文件的场所。每个仓库放着某一类镜像，往往包括多个镜像文件，通过不同的标签(tag)来区分。根据所存储的镜像公开与否，Docker仓库可以分为公开仓库和私有仓库两种形式。目前最大的公开仓库是Docker Hub，存放了数量庞大的镜像供用户下载。国内的公开仓库包括Docker Pool等，可以提供稳定的国内访问。Docker也支持用户在本地网络创建一个只能自己访问的私有仓库。 安装Docker Ubuntu CentOS Windows Mac OS 1brew install docker 镜像 镜像是Docker的三大核心概念之一。Docker运行容器前需要本地存在对应的镜像，如果镜像不存在本地，Docker会尝试先从默认镜像仓库下载，用户也可以通过配置，使用自定义的镜像仓库。 获取镜像镜像是Docker运行容器的前提。使用docker pull命令从网络上下载镜像。 1docker pull NAME[:TAG] 若不显式地指定TAG，则默认会选择latest标签，即下载仓库的最新版本的镜像。 12345678910111213docker pull ubuntu# 指定TAGdocker pull ubuntu:14.04# 已下载Using default tag: latestlatest: Pulling from library/ubuntuc64513b74145: Already exists01b8b12bad90: Already existsc5d85cf7a05f: Already existsb6b268720157: Already existse12192999ff1: Already existsDigest: sha256:aade50db36e1ed96716662cfe748789e154c213a711931c66746c42ce34aa296Status: Downloaded newer image for ubuntu:latest 下载过程可以看出，镜像文件一般由若干层组成，行首的c64513b74145代表了各层的ID。下载过程中会获取病输出镜像的各层信息。层其实是AUFS(Advanced Union File System，一种联合文件系统)中的重要概念，是实现增量保存与更新的基础。 两条安装命令相当于：docker pull registry.hub.docker.com/ubuntu:latest，即从默认的注册服务器registry.hub.docker.com中的ubuntu仓库下载标记为latest的镜像。 指定完整的仓库注册服务器地址。例如从DockerPool社区的镜像源下载 1docker pull dl.dockerpool.com:5000/ubuntu 使用镜像创建容器并运行bash应用 1docker run -t -i ubuntu /bin/bash 查看镜像信息1234# 列出本地主机上已有的镜像docker images# 来源仓库 标签 镜像的ID号 创建时间 大小# REPOSITORY TAG IMAGE ID CREATED SIZE TAG信息用来标记来自同一个仓库的不同镜像。仓库中有多个镜像，通过TAG信息来区分发行版本。 12# 使用docker tag为本地镜像添加新的标签docker tag dl.dockerpool.com:5000/ubuntu:latest ubuntu:latest 不同标签的镜像的ID完全一致的，说明它们实际上指向了同一个镜像文件，只是别名不同。标签起到了引用或快捷方式的作用。 docker inspect可以获取镜像的详细信息，docker inspect命令返回的是一个JSON格式的消息，若只要其中一项内容，可以使用-f参数指定。 1234docker inspect 2cb0d9787c4d# 指定镜像ID时，通常使用该ID的前若干个字符组成的可区分字串来替代完整IDdocker inspect -f &#123;&#123;".Architecture"&#125;&#125; 550 搜寻镜像使用docker search命令可以搜索远端仓库中的共享的镜像，默认搜索Docker Hub官方仓库中的镜像。 支持的参数： –automated=false 仅显示自动创建的镜像 –no-trunc=false 输出信息不截断显示 -s,–starts=0 指定仅显示评价为指定星级以上的镜像 删除镜像使用docker rmi可以删除镜像 1234# IMAGE可以为标签或IDdocker rmi IMAGE# -f 参数强制执行docker rmi -f ubuntu 当一个镜像拥有多个标签时，docker rmi只是删除了该镜像多个标签中的指定标签而已，并不影响镜像文件。但当只剩下一个标签时，执行docker rmi命令会删除这个镜像文件的所有AUFS层。 当使用docker rmi命令后面跟上镜像ID(也可以是ID能进行区分的部分前缀串)时，会先尝试删除所有指定该镜像的标签，然后删除镜像文件本身。 当有镜像创建的容器存在时，镜像文件默认是无法被删除的1234# 删除依赖该镜像的所有容器docker rm ubuntu# 然后再删除镜像docker rmi ubuntu 创建镜像 三种方法：基于已有镜像的容器创建、基于本地模板导入、基于Dockerfile创建 基于已有镜像的容器创建使用docker commit命令，格式： 1docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] 主要选项包括： -a，–author=””作者信息 -m，–message=””提交信息 -p，–pause=true提交时暂停容器运行 123456789101112# 演示docker run -ti ubuntu /bin/bashroot@32fe63d85c53:/# touch testroot@32fe63d85c53:/# exitdocker commit -m "add a new file " 32fe63d85c53 testsha256:4ff6ec596961a2c5f25bcd31e912abd40cc108b7e7e35d53d239b1ef4ff13233# 使用docker images查看本地镜像列表docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtest latest 4ff6ec596961 6 seconds ago 83.5MB 基于本地模板导入使用OpenVZ提供的模板创建。OPENVZ模板的下载地址为https://download.openvz.org/template/precreated/导入命令 1cat ubuntu-14.04-x86_64-minimal.tar.gz | docker import - ubuntu:14.04 存出和载入镜像可以使用docker save和docker load命令来存出和载入镜像 存出镜像1docker save -o ubuntu_14.04.tar ubuntu:14.04 载入镜像123docker load --input ubuntu_14.04.tardocker load &lt; ubuntu_14.04.tar 上传镜像使用docker push命令上传镜像到仓库，默认上传到DockerHub官方仓库（需要登录），命令格式为docker push NAME[:NAME]，第一次使用时，会提示输入登录信息或进行注册。 容器 容器时Docker的另一个核心概念，容器就是镜像的一个运行实例，不同的是，它带有额外的可写文件层。 创建容器新建容器使用docker create命令新建一个容器 1234docker create -it ubuntu:latestfb461fbaa2ffe5ebab82548feb5898a1b35b7a3d678b52e1085d94db0f08c6e5docker ps -afb461fbaa2ff ubuntu:latest "/bin/bash" 23 seconds ago Up 5 seconds heuristic_lamport 使用docker create新建的容器处于停止状态，可以使用docker start启动。 新建并启动容器启动容器的方式有两种 基于镜像新建一个容器并启动 将在终止状态的容器重新启动 docker run = docker create + docker start 12# 使用如下命令输出一个‘hello world’，之后容器自动终止docker run ubuntu /bin/echo 'hello world' 当利用docker run创建并启动容器时，Docker在后台运行的标准操作： 检查本地是否存在指定的镜像，不存在就从共有仓库下载。 利用镜像创建并启动一个容器。 分配一个文件系统，并在只读的镜像层外挂载一层可读写层。 从宿主主机配置的网桥接口中桥接一个虚拟接口道容器中去。 从地址池配置一个IP地址给容器。 执行用户指定的应用程序。 执行完毕后容器被终止。 下面命令启动一个bash终端，允许用户进行交互 1docker run -t -i ubuntu:latest /bin/bash -t：让Docker分配一个伪终端并绑定到容器的标准输出上-i：让容器的标准输入保持打开 12345678910111213docker run -ti ubuntu /bin/bashroot@d3df425445cf:/# lsbin dev home lib64 mnt proc run srv tmp varboot etc lib media opt root sbin sys usrroot@d3df425445cf:/# pwd/root@d3df425445cf:/# ps PID TTY TIME CMD 1 pts/0 00:00:00 bash 11 pts/0 00:00:00 psroot@d3df425445cf:/# exitexit# 使用exit退出后，容器自动处于终止状态 守护态运行-d参数可以让Docker容器在后台以守护态形式运行 12345678➜ ~ docker run -d ubuntu /bin/bash -c "while true;do echo hello world;sleep 1;done"9c9db4515c703021cd2fc3e4583291cb62007ecafa28709f898cf2183eb914c1➜ ~ docker logs 9c9db4515c703hello worldhello world➜ ~ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES9c9db4515c70 ubuntu "/bin/bash -c 'while…" 41 seconds ago Up 40 seconds elastic_brattain 终止容器docker stop可以用来终止一个运行中的容器，命令格式docker stop [-t|--time[=10]]它会首先向容器发送SIGTERM信号，等待一段时间后（默认为10s），再发送SIGKILL信号终止容器，当Docker容器中指定的应用终结时，容器也自动终止。 处于终止状态的容器，可以通过docker start重新启动 docker restart可以重启一个运行中的容器。 进入容器attach命令123456789➜ ~ docker run -idt ubuntua9e625b70f57ec70c242e5baf5c9a4431515e0e4d239b81a4729fcc4c08a0eef➜ ~ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESa9e625b70f57 ubuntu "/bin/bash" 5 seconds ago Up 4 seconds hungry_brown➜ ~ docker attach hungry_brownroot@a9e625b70f57:/# lsbin dev home lib64 mnt proc run srv tmp varboot etc lib media opt root sbin sys usr 但是使用attach命令有时候并不方便。当多个窗口同时attach到同一个容器时，所有的窗口都会同步显示。当某个命令因命令阻塞时，其他窗口也无法执行操作。 exec命令Docker自1.3版本起，提供了exec工具，可以直接在容器内运行命令。 1docker exec -ti a9e625 /bin/bash nsenter工具nsenter工具在util-linux包2.33版本后包含。 删除容器docker rm可以删除处于终止状态的容器，命令格式为docker rm [OPTION] CONTAINER [CONTAINER...]支持的选项包括： -f，–force=false强行终止并删除一个运行中的容器 -l，–link=false删除容器的连接，但保留容器 -v，–volume=false删除容器挂载的数据卷 导入和导出容器导出容器导出容器是指导出一个已经创建的容器到一个文件，不管此时这个容器是否处于运行状态，可以使用docker export命令，命令格式为docker export CONTAINER。 1docker export ce4 &gt; test_for_run.tar 导入容器docker import可以导入文件成为镜像 1cat test_for_run.tar | docker import - test/ubuntu:v1.0 与docker load的区别：docker load命令导入镜像存储文件到本地的镜像库docker import命令导入一个容器快照到本地镜像库容器快照文件将丢弃所有的历史记录和元数据信息（仅保留容器当时的快照状态），而镜像存储文件保留完整记录，体积也更大。此外，从容器快照文件导入可以重新指定标签等元数据信息。 仓库 仓库是集中存放镜像的地方，注册服务器是存放仓库的具体服务器，每个服务器上可以有多个仓库，每个仓库下面有多个镜像。仓库地址dl.dockerpool.com/ubuntu，dl.dockerpool.com是注册服务器，ubuntu是仓库名。 Docker Hub基础操作 docker pull 下载镜像到本地 docker search 搜索公共仓库镜像 docker push 将本地奖项推动到Docker Hub 镜像资源分为两类 类似ubuntu这样的基础镜像，成为基础或根镜像。这些镜像由Docker公司创建、验证、支持、提供，这样的镜像往往使用单个单词作为名字 类似user/ubuntu这样的镜像，它是由DockerHub的用户user闯将并维护的，带有用户名称前缀， 查找时可以通过-s N参数指定仅显示评价为N星以上的镜像。 自动创建自动创建使用户通过Docker Hub指定跟踪一个目标网站（目前支持GitHub或BitBucket）上的项目，一旦项目发现新的提交，则自动执行创建。步骤： 创建并登陆Docker Hub，以及目标网站；*在目标网站中连接账户到Docker Hub 在Docker Hub中配置一个自动创建 选取一个目标网站中的项目（需要含Dockerfile）和分支 指定Dockerfile的位置，并提交创建。 之后可以在Docker Hub的“自动创建”页面中跟踪每次创建的动态。 创建和使用私有仓库使用registry镜像创建私有仓库通过官方的registry镜像简单搭建一套本地私有仓库环境： 1docker run -d -p 5000:5000 registry 数据管理 用户在使用Docker的过程中，需要能查看容器内应用产生的数据，或者需要把容器内的数据进行备份，甚至多个容器之间进行数据共享，必然涉及到容器内的数据管理操作。容器中管理数据的方式主要有两种方式：1.数据卷 2.数据卷容器 数据卷数据卷是一个可供容器使用的特殊目录，它绕过文件系统，提供很多有用的特性： 数据卷可以在容器之间共享和重用 对数据卷的修改会立马生效 对数据卷的更新，不会影响镜像 卷会一致存在，知道没有容器使用 数据卷的使用用，类似于Linux下对目录或文件进行mmount操作。 在容器内创建一个数据卷使用docker run命令的时候，使用-v编辑可以在容器内创建一个数据卷。多次会用-v标记可以创建多个数据卷。 使用training/webapp镜像创建一个Web容器，并创建一个数据卷挂载到容器的/web目录： 1docker run -d -P --name web -v /webapp training/webapp python app.py -P是允许外部访问容器需要暴露的端口 挂载一个本地主机文件作为数据卷-v标记也可以从主机上挂载单个文件到容器中作为数据卷： 1docker run --rm -it -v ~/.zshrc ubuntu /bin/bash 网络基础配置端口映射实现访问从外部访问容器应用可以通过-P或-p参数来指定端口映射。当使用-P标记时，Docker会随机映射一个49000~49900的端口至容器内部开放的网络端口。-p则可以指定要映射的端口，并且在一个指定端口上只可以绑定一个容器。支持的格式有：ip:hostport:containerPort | ip::containerPort | hostPort:containerPort 123docker run -d -P training/webapp python app.pydocker ps -ld5c545dc020f training/webapp "python app.py" 7 seconds ago Up 6 seconds 0.0.0.0:32774-&gt;5000/tcp infallible_varahamihira 映射所有的接口地址将本地的5000端口映射到容器的5000端口 1docker run -d -p 5000:5000 training/webapp python app.py 亦可以多次使用-p标记绑定多个端口 1docker run -d -p 5000:5000 -p 3000:80 training/webapp python app.py 映射到指定地址的指定端口1docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py 映射到指定地址的任意端口使用ip::containerPort绑定localhost的任意端口到容器的5000端口，本地主机会自动分配一个端口： 123docker run -d -p 127.0.0.1::5000 training/webapp python app.py# 使用ud标记来指定udp端口docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py 查看映射端口配置使用docker port查看当前映射的端口配置，也可以查看到绑定的地址 1docker port DOCKERNAME containerPort 容器有自己的内部网络和IP地址(docker inspert + 容器ID可以获取所有的变量值)。 容器互联实现容器间通信 容器的连接系统是除了端口映射外另一种可以与容器中应用进行交互的方式。它会在源和接收容器之间创建一个隧道，接收容器可以看到源容器指定的信息。 连接系统根据容器的名称来执行，因此需要先自定义一个好记的容器命名。使用--name标记可以为容器自定义命名 1docker run -d -P --name web training/webapp python app.py 八、使用Dockerfile创建镜像 Dockerfile是一个文本格式的配置文件，用户可以使用Dockerfile快速创建自定义的镜像。 基本结构Docker由一行行命令语句组成，并且支持以#开头的注释行。一般分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动执行指令。 123456789101112131415161718# This dockerfile uses the ubuntu image# VERSION 2 - EDITION 1# Author:docker_user# Command format: Instruction [arguments / command]...# 第一行必须指定基于的基础镜像From ubuntu# 维护者信息MAINTAINER entercoder entercoder1993@gmail.com# 镜像的操作指令RUN echo "deb http://archive.ubuntu.com/ubuntu/ raring main universe" &gt;&gt; /etc/apt/sources.listRUN apt-get update &amp;&amp; apt-get install -y nginxRun echo "\nadaemon off;;" &gt;&gt; /etc/nginx/nginx.conf# 容器启动时执行指令CMD /usr/sbin/nginx Example1 1234From ubuntuMAINTAINER entercoder entercoder1993@gmail.comRUN apt-get update &amp;&amp; apt-get install -y inotify-tools nginx apache2 openssh-server% Example2 基于ubuntu，安装firfox和vnc软件，启动后，用户可以通过5900端口通过vnc方式使用firefox 123456789FROM ubuntuRUN apt-get update &amp;&amp; apt-get install -y xllvnc xvfb firefoxRUN mkdir /.vncRUN xllvnc -storepasswd 1234 ~/.vnc/passwdRUN bash -c 'echo "firefox" &gt;&gt; /.bashrc'EXPOSE 5900CMD ["xllvnc,"-forever","-usepw","-create"] 指令指令的一般格式为INSTRUCTION arguments，指令包括FROM、MAINTAINER、RUN等 FROM第一条必须为FROM指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个FROM指令。格式：FROM &lt;image&gt;或FROM &lt;image&gt;:&lt;tag&gt; MAINTAINER指定维护者的信息格式：MAINTAINER &lt;name&gt; RUN在shell终端中运行命令，即/bin/sh -c格式：RUN &lt;command&gt;使用exec执行命令，指定其他终端可以用这种方式实现格式：RUN [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello&quot;]每条RUN指令将在当前镜像基础上执行指定命令，并提交为新的镜像。当命令较长时可以用\来换行。 CMD支持三种形式 CMD [”executable&quot;,&quot;param1&quot;,&quot;param2&quot;]使用exec执行，推荐方式 CMD command param1 param2在/bin/bash中执行， CMD [&quot;param1&quot;,&quot;param2&quot;]提供给ENTRYPOINT的默认参数 指定启动容器时执行的命令，每个Dockerfile只能有一条CMD命令。如果指定了多条命令，只有最后一条会被执行。如果用户启动容器时制定了运行的命令，则会覆盖掉CMD指定的命令。 EXPOSE告诉Docker服务端容器暴露的端口号，供互联网使用。在启动容器时需要通过-P，Docker主机会自动分配一个端口转发到指定的端口；使用-p，则可以指定哪个本地端口映射过来。格式：EXPOSE &lt;port&gt; [&lt;port&gt;...] ENV指定一个环境变量，会被后续RUN指令使用，并在容器运行时保持。格式：ENV &lt;key&gt; &lt;value&gt;1234ENV PG_MAJOR 9.3ENV PG_VERSIOIN 9.3.4RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; ...ENV PATH /usr/local/postgress-$PG_MAJOR/bin:$PATH ADD将复制指定的&lt;src&gt;到容器中的&lt;dest&gt;。其中&lt;src&gt;可以是Dockerfile所在目录的一个相对露冷静(文件或目录)；也可以是一个URL；还可以是一个tar文件(自动解压为目录)。格式：ADD &lt;src&gt; &lt;dest&gt; COPY复制指定的&lt;src&gt;(为Dockerfile所在目录的相对路径，文件或目录)为容器中的&lt;dest&gt;。目标路径不存在，会自动创建。使用本地目录为源目录时，推荐使用COPY格式：COPY &lt;src&gt; &lt;dest&gt; ENTRYPOINT配置容器启动后执行的命令，并且不可被docker run提供的参数覆盖。每个Dockerfile中只能有一个ENTRYPOINT，当指定多个ENTRYPOINT时，只有最后一个生效。格式：ENTRYPOINT [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]ENTRYPOINT command param1 param2(shell中执行) VOLUME创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。格式：VOLUME [&quot;/data&quot;] USER指定运行容器时的用户名或UID，后续的RUN也会使用指定用户。当服务不需要管理员权限时，可以通过该命令指定运行用户，并且可以在之前创建所需要的用户，例如：RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres。要临时获取管理员权限可以使用gosu，而不推荐sudo。格式：USER daemon WORKDIR为后续的RUN、CMD、ENTRYPOINT指令配置工作目录。可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。格式：WORKDIR /path/to/workdir 12345WORDDIR /aWORKDIR bWORKDIR cRUN pwd# 则最终路径为/a/b/c ONBUILD配置当所创建的镜像作为其他新创建镜像的基础镜像时所操作的指令。格式：ONBUILD [INSTRUCTION] Dockerfile创建镜像编写完成Dockerfile后，通过docker build命令来创建镜像。格式：docker build [option] path该命令将读取指定路径下(包括子目录)的Dockerfile，并将该路径下所有内容发给Docker服务端，由服务端来创建镜像。因此一般建议放置Dockerfile的目录为空目录。 通过.dockerignore文件(每行添加一条匹配模式)来让Docker忽略路径下的目录和文件。 通过-t选项可以指定镜像的标签信息。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络爬虫与信息提取]]></title>
    <url>%2F2018%2F07%2F01%2FPython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96%2F</url>
    <content type="text"><![CDATA[Python网络爬虫与信息提取 文本工具类IDE IDLE — 自带、默认、常用（适用于Python入门） Sublime Text — 第三方专用编程工具 集成工具类IDE PyCharm Anaconda &amp; Spyder Requests库入门Request库的安装终端运行下列命令 1$pip install requests 获得源码 1$git clone git://github.com/kennethreitz/requests.git 也可以下载tarball 1$curl -OL https://github.com/requests/requests/tarball/master 现在完成后，使用如下命令进行安装 12$cd requests$pip install . 简单使用 12345import requestsr = requests.get("http://www.baidu.com")print(r.status_code) # 200r.encoding = 'utf-8'print(r.text) # baidu的html源码 Requests库的7个主要方法 Requests库的get() 使用方法 1requests.get(url,params=None,**kwargs) url：拟获取页面的url链接 params：url中的额外参数，字典或字节流格式，可选 **kwargs：12个控制访问的参数 Response对象的属性 栗子： 12345678910111213&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get('https://www.baidu.com')&gt;&gt;&gt; r.encoding = 'utf-8'&gt;&gt;&gt; r.text'&lt;!DOCTYPE html&gt;\r\n&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt; ...... &lt;/head&gt; &lt;body&gt; ...... &lt;/body&gt;&lt;/html&gt; r.encoding：如果header中不存在charset，则认为编码为ISO-8859-1 Requests库的异常 状态响应码status_code 12345678910111213141516171819&gt;&gt;&gt; r = requests.get('https://www.baidu.com')&gt;&gt;&gt; r.status_code200# 为方便引用，Requests还有一个内置的状态码查询对象&gt;&gt;&gt; r.status_code == requests.codes.okTrue# 如果是一个错误请求，可以通过Response.raise_for_status()来抛出异常&gt;&gt;&gt; bad_r = requests.get('http://httpbin.org/status/404')&gt;&gt;&gt; bad_r.status_code404&gt;&gt;&gt; bad_r.raise_for_status()Traceback (most recent call last): File "requests/models.py", line 832, in raise_for_status raise http_errorrequests.exceptions.HTTPError: 404 Client Error# r.status == 200,当我们调用raise_for_status()时，得到的是&gt;&gt;&gt; r.raise_for_status()None 爬取网页的通用代码框架TTP 1234567891011121314import requestsdef getHTMLText(url): try: r = requests.get(url,time=30) r.raise_for_status() #如果状态不是200，将引发HTTPError异常 r.encoding = r.apparent_encoding return r.text except： return "产生异常"if __name__ = "__main__": url = 'https://www.baidu.com' print(getHTMLText(url)) HTTP协议 HTTP，Hypertext Transfer Protocol，超文本传输协议。 HTTP是一个基于“请求与响应”模式的、装状态的应用层协议。 HTTP协议采用URL作为定位网络资源的标识 URL格式 http://host[:port][path] host：合法的Internet主机域名或IP地址 port：端口号，缺省端口为80 path：请求资源的路径 HTTP协议对资源的操作 理解PATCH和PUT的区别 采用PATCHA，仅向URL提交局部更新的请求 采用PUT，必须将所有字段一并提交到URL，未提交字段被删除 Requests库的head()方法 12345&gt;&gt;&gt; r = requests.head('http://www.baidu.com')&gt;&gt;&gt; r.headers&#123;'Cache-Control': 'private, no-cache, no-store, proxy-revalidate, no-transform', 'Connection': 'Keep-Alive', 'Content-Encoding': 'gzip', 'Content-Type': 'text/html', 'Date': 'Sun, 01 Jul 2018 07:38:20 GMT', 'Last-Modified': 'Mon, 13 Jun 2016 02:50:26 GMT', 'Pragma': 'no-cache', 'Server': 'bfe/1.0.8.18'&#125;&gt;&gt;&gt; r.text'' Requests库的post()方法 1234567891011&gt;&gt;&gt; payload = &#123;'key1':'value1','key2':'value2'&#125;&gt;&gt;&gt; r = requests.post('http://www.baidu.com/post',data = payload)&gt;&gt;&gt; print(r.text)&#123; # 向URL POST一个字典，自动编码为form(表单) ... "form":&#123; "key2":"value2", "key1":"value2" &#125;, ...&#125; Requests库的put()方法 12345678910111213&gt;&gt;&gt; payload = &#123;'key1':'value1','key2':'value2'&#125;&gt;&gt;&gt; r = requests.put("http://www.baidu.com/put',data = payload")&gt;&gt;&gt; print(r.text)&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;405 Method Not Allowed&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Method Not Allowed&lt;/h1&gt; &lt;p&gt;The requested method PUT is not allowed for the URL /put',data=payload.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; Requests库主要方法解析 requests.request(method,url,**kwargs) method：请求方式，对应get/put/post等7种 r = requests.request(‘GET’,url,*kwargs) r = requests.request(‘HEAD’,url,*kwargs) r = requests.request(‘POST’,url,*kwargs) r = requests.request(‘PUT’,url,*kwargs) r = requests.request(‘PATCH’,url,*kwargs) r = requests.request(‘delete’,url,*kwargs) r = requests.request(‘OPTIONS’,url,*kwargs) url：获取页面的url链接 **kwargs：控制访问参数，共13个 params：字典或字节序列，作为参数增加到url种 1234&gt;&gt;&gt; kv = &#123;'key1':'value1','key2':'value2'&#125;&gt;&gt;&gt; r = requests.request('GET','http://www.baidu.com/s',params=kv)&gt;&gt;&gt; print(r.url)http://www.baidu.com/s?key1=value1&amp;key2=value2 data：字典、字节序列或文件对象，作为Request的内容，向服务器提交资源时使用 1234&gt;&gt;&gt; kv = &#123;'key1':'value1','key2':'value2'&#125;&gt;&gt;&gt; r = requests.request('POST','http://www.baidu.com/s',data=kv)&gt;&gt;&gt; body = '主体内容'&gt;&gt;&gt; r = requests.request('POST','http://www.baidu.com/s',data=body) json：JSON格式的数据，作为Request的内容 12&gt;&gt;&gt; kv = &#123;'key1':'value1'&#125;&gt;&gt;&gt; r = requests.request('POST','http://www.baidu.com/s',json=kv) headers：字典，HTTP定制头 12&gt;&gt;&gt; hd = &#123;'user-agent':'Chrome/10'&#125;&gt;&gt;&gt; r = requests.request('POST','http://python123.io/ws',headers=hd) cookies：字典或CookieJar，Request中的cookie auth：元组，支持HTTP认证功能 file：字典类型，传输文件 12&gt;&gt;&gt; fs = &#123;'file':open('data.xls','rb')&#125;&gt;&gt;&gt; r = requests.request('POST','http://python123.io/ws',files=fs) timeout：设定超时时间，秒为单位 1&gt;&gt;&gt; r = requests.request('GET','http://www.baidu.com',timeout=10) proxies：字典类型，设定访问代理服务器，可以增加登录认证 12&gt;&gt;&gt; pxs = &#123;'http':'http://user:pass@10.10.10.1:1234','https':'https://10.10.10.1:4321'&#125;&gt;&gt;&gt; r = requests.request('GET','http://www.baidu.com',proxies=pxs) allow_redirects：True/False，默认为True，重定向开关 stream：True/False，默认为True，获取内容立即下载开关 verify：True/False，默认为True，认证SSL证书开关 cert：本地SSL证书路径 网络爬虫的盗亦有道 网络爬虫的尺寸 网络爬虫的法律风险 服务器上的数据有产权归属 网络爬虫获取数据后牟利将带来法律风险 网络爬虫泄露数据 网络爬虫的限制 来源审查：判断User-Agent进行限制 检查来访HTTP协议头的User-Agent域，只响应浏览器或友好爬虫的访问 发布公告：Robots协议 告知所有爬虫网站的爬取策略，要求爬虫遵守 Robots协议（Robots Exclusion Standard 网络爬虫排除标准） 作用：网站告知网络爬虫哪些页面可以抓取，哪些不行 形式：在网站根目录下的robots.txt文件 https://www.jd.com/rboots.txt 123456789101112131415User-agent: * Disallow: /?* Disallow: /pop/*.html Disallow: /pinpai/*.html?* User-agent: EtaoSpider Disallow: / User-agent: HuihuiSpider Disallow: / User-agent: GwdangSpider Disallow: / User-agent: WochachaSpider Disallow: /# 注释 * 代表所有 /代表根目录User-agent: *Disallow: / 遵守方式 网络爬虫：自动或人工识别robots.txt，再进行内容爬取 约束性：Robots协议是建议但非约束性，网络爬虫可以不遵守，但存在法律风险 理解 Requests库爬取实例实例1：京东商品页面的爬取123456789import requestsurl = 'https://item.jd.com/2967929.html'try: r = requests.get(url) r.raise_for_status() r.encoding = r.apparent_encoding print(r.text[:1000])except: print('爬取失败') 实例2：亚马逊商品的爬取12345678910import requestsurl = "https://www.amazon.cn/dp/B00QJDOLIO/ref=lp_1536596071_1_1?s=amazon-devices&amp;ie=UTF8&amp;qid=1530439999&amp;sr=1-1"try: kv = &#123;'user-agent':'Mozilla/5.0'&#125; r = requests.get(url,headers=kv) r.raise_for_status() r.encoding = r.apparent_coding print(r.text[1000:2000])except: print("爬取失败") 实例3：百度和360搜索关键字提交 百度 12345678910import requestskeyword = "Python"try: kv = &#123;'wd':keyword&#125; r = requests.get("http://www.baidu.com/s",params=kv) print(r.request.url) r.raise_for_status() print(len(r.text))except: print("爬取失败") 360 12345678910import requestskeyword = "Python"try: kv = &#123;'q':keyword&#125; r = requests.get("http://www.so.com/s",params=kv) print(r.request.url) r.raise_for_status() print(len(r.text))except: print("爬取失败") 实例4：网络图片的爬取和存储123456789101112131415161718import requestsimport osroot = "/Users/entercoder/Documents/123.jpg"url = "https://ws2.sinaimg.cn/large/006tNc79gy1fsuinx4kc6j30np05wgmm.jpg"path = root + url.split('/')[-1]try: if not os.path.exists(root): os.mkdir(root) if not os.path.exists(path): r = requests.get(url) with open(path,'wb') as f: f.write(r.content) f.close() print("save successful") else: print("file already exists")except: print("download fail") 实例5：IP地址归属地自动查询123456789import requestsurl = "http://ip138.com/ips138.asp?ip="try: r = requests.get(url + '202.204.80.112') r.raise_for_status() r.encoding = r.apparent_encoding print(r.text[-500:])except: print("爬取失败") BeautifulSoup入门BeautifulSoup库的安装 使用pip安装 1$pip3 install BeautifulSoup4 源码安装 下载源码 通过setup.py安装 1$Python setup.py install 安装解析器 lxml 1$pip3 install lxml html5lib 1$pip3 install html5lib 主要解析器及使用方法 测试 12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get('https://python123.io/ws/demo.html')&gt;&gt;&gt; demo = r.text&gt;&gt;&gt; from bs4 import BeautifulSoup&gt;&gt;&gt; soup = BeautifulSoup(demo,'html.parser') # 需要解析的html格式的内容和解析器&gt;&gt;&gt; print(soup.prettify())&lt;html&gt; &lt;head&gt; &lt;title&gt; This is a python demo page &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class="title"&gt; &lt;b&gt; The demo python introduces several python courses. &lt;/b&gt; &lt;/p&gt; &lt;p class="course"&gt; Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses: &lt;a class="py1" href="http://www.icourse163.org/course/BIT-268001" id="link1"&gt; Basic Python &lt;/a&gt; and &lt;a class="py2" href="http://www.icourse163.org/course/BIT-1001870001" id="link2"&gt; Advanced Python &lt;/a&gt; . &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; BeautifulSoup库的基本元素 BeautifulSoup库是解析、遍历、维护“标签树”的功能库 BeautifulSoup类的基本元素 12345678910111213141516171819202122232425262728293031323334353637383940414243&gt;&gt;&gt; import requests&gt;&gt;&gt; from bs4 import BeautifulSoup&gt;&gt;&gt; r = requests.get("http://python123.io/ws/demo.html")&gt;&gt;&gt; demo = r.text&gt;&gt;&gt; soup = BeautifulSoup(demo,"html.parser")&gt;&gt;&gt; soup.title&lt;title&gt;This is a python demo page&lt;/title&gt;&gt;&gt;&gt; tag = soup.a&gt;&gt;&gt; tag&lt;a class="py1" href="http://www.icourse163.org/course/BIT-268001" id="link1"&gt;Basic Python&lt;/a&gt;&gt;&gt;&gt; soup.a.name'a'&gt;&gt;&gt; soup.a.parent.name'p'&gt;&gt;&gt; soup.a.parent.parent.name'body'&gt;&gt;&gt; tag.attrs&#123;'href': 'http://www.icourse163.org/course/BIT-268001', 'class': ['py1'], 'id': 'link1'&#125;&gt;&gt;&gt; tag.attrs['class']['py1']&gt;&gt;&gt; tag.attrs['href']'http://www.icourse163.org/course/BIT-268001'&gt;&gt;&gt; type(tag.attrs)&lt;class 'dict'&gt;&gt;&gt;&gt; type(tag)&lt;class 'bs4.element.Tag'&gt;&gt;&gt;&gt; soup.a.string'Basic Python'&gt;&gt;&gt; soup.p.string'The demo python introduces several python courses.'&gt;&gt;&gt; type(soup.p.string)&lt;class 'bs4.element.NavigableString'&gt;&gt;&gt;&gt; newsoup = BeautifulSoup("&lt;b&gt;&lt;!-- This is a comment --&gt;&lt;/b&gt;&lt;p&gt;This is not a comment&lt;/p&gt;","html.parser")# 不常用&gt;&gt;&gt; newsoup.b.string' This is a comment '&gt;&gt;&gt; type(newsoup.b.string)&lt;class 'bs4.element.Comment'&gt;&gt;&gt;&gt; newsoup.p.string'This is not a comment'&gt;&gt;&gt; type(newsoup.p.string)&lt;class 'bs4.element.NavigableString'&gt; 基于bs4库的HTML内容遍历方法 遍历方式 标签树的下行遍历 1234567891011121314151617181920&gt;&gt;&gt; from bs4 import BeautifulSoup&gt;&gt;&gt; soup = BeautifulSoup(demo,"html.parser")&gt;&gt;&gt; soup.head&lt;head&gt;&lt;title&gt;This is a python demo page&lt;/title&gt;&lt;/head&gt;&gt;&gt;&gt; soup.head.contents[&lt;title&gt;This is a python demo page&lt;/title&gt;]&gt;&gt;&gt; soup.body.contents['\n', &lt;p class="title"&gt;&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;&lt;/p&gt;, '\n', &lt;p class="course"&gt;Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses:&lt;a class="py1" href="http://www.icourse163.org/course/BIT-268001" id="link1"&gt;Basic Python&lt;/a&gt; and &lt;a class="py2" href="http://www.icourse163.org/course/BIT-1001870001" id="link2"&gt;Advanced Python&lt;/a&gt;.&lt;/p&gt;, '\n']&gt;&gt;&gt; len(soup.body.contents)5&gt;&gt;&gt; soup.body.contents[1]&lt;p class="title"&gt;&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;&lt;/p&gt;&gt;&gt;&gt; # 遍历儿子节点for child in soup.body.children: print(child)# 遍历子孙节点for child in soup.body.descendants: print(children) 标签树的上行遍历 123456789101112131415161718&gt;&gt;&gt; soup = BeautifulSoup(demo,"html.parser")&gt;&gt;&gt; soup.title.parent&lt;head&gt;&lt;title&gt;This is a python demo page&lt;/title&gt;&lt;/head&gt;&gt;&gt;&gt; soup.html.parent&lt;html&gt;&lt;head&gt;&lt;title&gt;This is a python demo page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class="title"&gt;&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;&lt;/p&gt;&lt;p class="course"&gt;Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses:&lt;a class="py1" href="http://www.icourse163.org/course/BIT-268001" id="link1"&gt;Basic Python&lt;/a&gt; and &lt;a class="py2" href="http://www.icourse163.org/course/BIT-1001870001" id="link2"&gt;Advanced Python&lt;/a&gt;.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&gt;&gt;&gt; soup.parent# 标签树的上行遍历&gt;&gt;&gt; soup = BeautifulSoup(demo,"html.parser")&gt;&gt;&gt; for parent in soup.a.parents: if parent is None: print(parent) else: print(parent.name) 标签树的平行遍历 12345678910111213141516&gt;&gt;&gt; soup = BeautifulSoup(demo,"html.parser")&gt;&gt;&gt; soup.a.next_sibling' and '&gt;&gt;&gt; soup.a.next_sibling.next_sibling&lt;a class="py2" href="http://www.icourse163.org/course/BIT-1001870001" id="link2"&gt;Advanced Python&lt;/a&gt;&gt;&gt;&gt; soup.a.previous_sibling'Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses:\r\n'&gt;&gt;&gt; soup.a.previous_sibling.previous_sibling# 标签树的平行遍历# 遍历后续节点for sibling in soup.a.next_siblings print(sibling)# 遍历前续节点for sibling in soup.a.previous_siblings: print(sibling) 总结 基于bs4库的HTML格式输出 prettify()方法可以格式化输出HTML文本 123&gt;&gt;&gt; soup = BeautifulSoup(demo,"html.parser")&gt;&gt;&gt; soup.prettify()&gt;&gt;&gt; print(soup.prettify()) 信息标记的三种形式 三种形式 XML – eXtensible Markup Language JSON – JavaScript Object Notation YAML – 三种信息标记形式的比较 信息提取的一般方法 基于bs4库的HTML内容查找方法 &lt;&gt;.find_all(name,attrs,recursive,string,**kwargs) 返回一个列表类型，存储查找结果 name：对标签名称的检索字符串 1234567891011121314151617181920&gt;&gt;&gt; soup.find_all('a')[&lt;a class="py1" href="http://www.icourse163.org/course/BIT-268001" id="link1"&gt;Basic Python&lt;/a&gt;, &lt;a class="py2" href="http://www.icourse163.org/course/BIT-1001870001" id="link2"&gt;Advanced Python&lt;/a&gt;]&gt;&gt;&gt; soup.find_all(['a','b'])[&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;, &lt;a class="py1" href="http://www.icourse163.org/course/BIT-268001" id="link1"&gt;Basic Python&lt;/a&gt;, &lt;a class="py2" href="http://www.icourse163.org/course/BIT-1001870001" id="link2"&gt;Advanced Python&lt;/a&gt;]&gt;&gt;&gt; for tag in soup.find_all(True): print(tag.name)htmlheadtitlebodypbpaa&gt;&gt;&gt; import re&gt;&gt;&gt; for tag in soup.find_all(re.compile('b')): print(tag.name)bodyb attrs：对标签属性值的检索字符窜，可标注属性检索 recursive：是否对子孙全部检索，默认True string：\&lt;&gt;…\&lt;/&gt;中字符串区域的检索字符串 \(…)等价于\.find_all(…) soup(…)等价于soup.find_all(…) 七个常用扩展方法 实例1：中国大学排名定向爬虫 功能描述 输入：大学排名URL连接 输出：大学排名信息的屏幕输出（排名，大学名称，总分） 技术路线：requests-bs4 定向爬去：仅对输入URL进行爬取，不扩展爬取 程序的结构设计 从网络上获取大学排名网页内容 – getHTMLText() 提取网页内容中信息到合适的数据结构 – fillUnivList() 利用数据结构展示并输出结果 – fillUnivList() 代码 123456789101112131415161718192021222324252627282930313233import requestsfrom bs4 import BeautifulSoupimport bs4def getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return "except"def fillUnivList(ulist, html): soup = BeautifulSoup(html, 'html.parser') for tr in soup.find('tbody').children: if isinstance(tr,bs4.element.Tag): tds = tr('td') ulist.append([tds[0].string, tds[1].string, tds[3].string])def printUnivList(ulist, num): tplt = "&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;" print(tplt.format("排名", "学校", "分数",chr(12288))) for i in range(num): u = ulist[i] print(tplt.format(u[0], u[1], u[2],chr(12288)))if __name__ == '__main__': uinfo = [] url = 'http://zuihaodaxue.com/zuihaodaxuepaiming2018.html' html = getHTMLText(url) fillUnivList(uinfo, html) printUnivList(uinfo, 100) 正则表达式正则表达式是用来简洁表达一组字符串的表达式。 编译：将符合正则表达式语法的字符串转换成正则表达式特征 语法 Re库的基本使用Re库是Python的标准库，主要用于字符串匹配，调用方式：import re 正则表达式的表示类型 raw string类型（原生字符串类型） string类型 Re库主要功能函数 re.search(pattern,string,flags=0) pattern：正则表达式的字符串或原生字符串表示 string：待匹配字符串 flags：正则表达式使用时的控制标记 123456&gt;&gt;&gt; import re&gt;&gt;&gt; match = re.search(r'[1-9]\d&#123;5&#125;','bit 100081')&gt;&gt;&gt; if match: print(match.group(0))100081 re.match(pattern,string,flags=0) pattern：正则表达式的字符串或原生字符串表示 string：待匹配字符串 flags：正则表达式使用时的控制标记 1match = re.match(r'[1-9]\d&#123;5&#125;','100081 bit') re.findall(pattern.string.flags=0) pattern：正则表达式的字符串或原生字符串表示 string：待匹配字符串 flags：正则表达式使用时的控制标记 123&gt;&gt;&gt; ls = re.findall(r'[1-9]\d&#123;5&#125;','bit100081 tsu 100084')&gt;&gt;&gt; ls['100081', '100084'] re.split(pattern,string,maxsplit=0,flags=0) pattern：正则表达式的字符串或原生字符串表示 string：待匹配字符串 maxsplit：最大分个数，剩余部分作为最后一个元素输出 flags：正则表达式使用时的控制标记 123&gt;&gt;&gt; ls = re.split(r'[1-9]\d&#123;5&#125;','bit100081 tsu100084',maxsplit=1)&gt;&gt;&gt; ls['bit', ' tsu100084'] re.finditer(pattern,string,flags=0) pattern：正则表达式的字符串或原生字符串表示 string：待匹配字符串 flags：正则表达式使用时的控制标记 123456&gt;&gt;&gt; for m in re.finditer(r'[1-9]\d&#123;5&#125;','bit100081 tsu100084'): if m: print(m.group(0))100081100084 re.sub(pattern,repl,string,count=0,flags=0) pattern：正则表达式的字符串或原生字符串表示 repl：替换匹配字符串的字符串 string：待匹配字符串 count：匹配的最大替换次数 flags：正则表达式使用时的控制标记 123&gt;&gt;&gt; re = re.sub(r'[123]','456','1237878712398798123',count=2)&gt;&gt;&gt; re'45645637878712398798123' Re库的另一种等价用法 函数式用法：一次性操作 1&gt;&gt;&gt; rst = re.search(r'[1-9]\d&#123;5&#125;','bit 100081') 面向对象用法：编译后多次操作 12&gt;&gt;&gt; pat = re.compile(r'[1-9]\d&#123;5&#125;')&gt;&gt;&gt; rst = pat.search('bit 100081') regex = re.compile(pattern,flags=0) – 将正则表达式的字符串形式编译成正则表达式对象 regex.search() regex.match() regex.findall() regex.split() regex.finditer() regex.sub() Re库的Match函数 Match对象的属性 Match对象的方法 Re库的贪婪匹配和最小匹配 贪婪匹配：Re库默认采用贪婪匹配，即输出匹配最长的子串 最小匹配 实例2 淘宝商品比价定向爬虫 功能描述 目标：获取淘宝搜索页面的信息，提取其中的商品名称和价格 理解：淘宝的搜索接口和翻页的处理 技术路线：requests-re 程序的设计结构 提交商品搜索请求，循环获取页面 对于每个商品，提取商品名称和价格信息 将信息输出到屏幕上 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import requestsimport redef getHTMLText(url): try: r = requests.get(url) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return ""def parsePage(ilt,html): try: plt = re.findall(r'"view_price":"[\d.]*"',html) tlt = re.findall(r'"raw_title":".*?"',html) for i in range(len(plt)): price = eval(plt[i].split(':')[1]) title = eval(tlt[i].split(':')[1]) ilt.append([price,title]) except: print("")def printGoodsList(ilt): tplt = "&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;" print(tplt.format("xuhao","jiage","shangpin name")) count = 0 for g in ilt: count = count + 1 print(tplt.format(count,g[0],g[1]))def main(): goods = 'shubao' depth = 2 start_url = 'https://s.taobao.com/search?q=%' + goods infoList = [] for i in range(depth): try: url = start_url + '&amp;s=' + str(44*i) html = getHTMLText(url) parsePage(infoList,html) except: continue printGoodsList(infoList)main() 实例3 股票数据定向爬虫 功能描述 目标：获取上交所和深交所所有股票的名称和交易信息 输出：保存到文件中 技术路线：requests-bs4-re 程序结构设计 从东方财富网选取股票列表 根据股票列表逐个到百度股票获取个股信息 将结果存储到文件 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import requestsfrom bs4 import BeautifulSoupimport tracebackimport redef getHTMLText(url,code='utf-8'): try: r = requests.get(url) r.raise_for_status() r.encoding = code return r.text except: return ""def getStockList(lst, stockURL): html = getHTMLText(stockURL) soup = BeautifulSoup(html, 'html.parser') a = soup.find_all('a') for i in a: try: href = i.attrs['href'] lst.append(re.findall(r"[s][hz]\d&#123;6&#125;", href)[0]) except: continuedef getStockInfo(lst, stockURL, fpath): count = 0 for stock in lst: url = stockURL + stock + ".html" html = getHTMLText(url) try: if html == "": continue infoDict = &#123;&#125; soup = BeautifulSoup(html, "html.parser") stockInfo = soup.find_all('div', attrs=&#123;'class': 'stock-bets'&#125;)[0] name = stockInfo.find(attrs=&#123;'class':'bets-name'&#125;)[0] infoDict.update(&#123;'stockname': name.text.split()[0]&#125;) keyList = stockInfo.find_all('dt') valueList = stockInfo.find_all('dd') for i in range(len(lst)): # if i == 20: # break key = keyList[i].text val = valueList[i].text infoDict[key] = val with open(fpath, 'a', encoding='utf-8') as f: f.write(str(infoDict) + '\n') count = count + 1 print('\r当前速度：&#123;:.2f&#125;%'.format(count*100/len(lst)), end='') except: count = count + 1 print('\r当前速度：&#123;:.2f&#125;%'.format(count*100/len(lst)),end='') # traceback.print_exc() continuedef main(): stock_list_url = "http://quote.eastmoney.com/stocklist.html" stock_info_url = "https://gupiao.baidu.com/stock/" output_file = "/Users/entercoder/Documents/stock.txt" slist = [] getStockList(slist, stock_list_url) getStockInfo(slist, stock_info_url, output_file)main()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Python</tag>
        <tag>Spider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript]]></title>
    <url>%2F2018%2F04%2F05%2FJavaScript%2F</url>
    <content type="text"><![CDATA[JavaScript，通常缩写为JS，是一种高级的，解释执行的编程语言。 JavaScript是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象编程，命令式编程，以及函数式编程。 它提供语法来操控文本、数组、日期以及正则表达式等，不支持I/O，比如网络、存储和图形等，但这些都可以由它的宿主环境提供支持。 JavaScript笔记(一)一、JavaScript简介 JavaScript和ECMAScript通常都被人们用来表达相同的含义，但JavaScript的含义却比ECMA-262中规定的要多的多。 完整的JavaScript实现由三个不同的部分组成 核心(ECMAScript) 文档对象模型(DOM) 浏览器对象模型(BOM) ECMAScript ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会）通过ECMA-262标准化的脚本程序设计语言。 这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMA-262标准的实现和扩展。 ECMA-262规定了ECMAScript语言的组成部分: 语法 类型 语句 关键字 保留字 操作符 对象 ECMAScript就是对实现该标准的各个方面内容的描述。JavaScript实现了ECMAScript，Adobe ActionScript同样也实现了ECMAScript。 什么是ECMAScript兼容文档对象模型(DOM)文档对象模型(DOM，Document Object Model)是针对XML但经过扩展用于HTML的应用程序编程接口(API,Application Progrmaming Interface)。DOM把整个页面映射为一个多层节点结构。HTML或XML页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据。 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Sample Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 通过DOM创建的这个表示文档的树形图，开发人员可以控制页面的内容和结构。借助DOM提供的API，可以对节点进行删除、添加、替换或修改。 浏览器对象模型浏览器对象模型(BOM，Browser Object Model)可以访问和操作浏览器窗口。开发人员使用BOM可以控制浏览器显示的页面的一部分。从根本上讲，BOM只处理浏览器窗口和框架；但习惯上吧所有针对浏览器的扩展算作是BOM的一部分。比如以下扩展： 弹出新浏览器窗口的功能； 移动、缩放和关闭浏览器的功能； 提供浏览器详细信息的navigator对象； 提供浏览器所加载页面的详细信息的location对象； 提供用户显示器分辨率详细信息的screen对象； 对cookies的支持 项XMLHttpRequest和IE的ActiveXObject这样的自定义对象。 二、在HTML中使用JavaScript&lt;script&gt;元素使用&lt;script&gt;元素可以向HTML页面中插入JavaScript。HTML4.01为&lt;script&gt;定义了6个属性： async：可选。表示应该立即下载脚本，但不妨碍页面中的其他操作。只对外部脚本文件有效。 charset：可选。通过src属性指定代码的字符集，大多数浏览器会忽略它的值。 defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。 language：已废弃。 src：可选。表示包含要执行代码的外部文件。 type：可选。可以看成是language的替代属性；表示编写代码使用的脚本语言的内容类型(也称为MIME类型。)) 使用&lt;script&gt;元素的两种方式：嵌入式和外本文件，在使用&lt;script&gt;元素嵌入JavaScript代码时，只须魏&lt;script&gt;指定type属性。 12345&lt;script type="text/javascript"&gt; function sayHi()&#123; alert("Hi!"); &#125;&lt;/script&gt; 包含在&lt;script&gt;元素的代码将从上至下依次解释。 通过&lt;script&gt;元素来包含外部JavaScript文件，必须包含src属性。这个属性的值指向外部JavaScript文件的链接。 1&lt;script type="text/javascript" src="example.js"&gt;&lt;/script&gt; 一般外部的JavaScript文件带有.js扩展名。但不是必须的，李兰器不会检查包含JavaScript文件的扩展名。因此，也可以使用JSP、PHP或其他服务器端语言动态生成JavaScript代码。 外部文件example.js将被加载到当前页面中。与解析嵌入式JavaScript代码一样，在解析外部JavaScript文件(包括下载该文件)时，页面的处理会暂时停止。如果是在XHTML文档中，可以省略&lt;/script&gt;标签。 带有src属性的&lt;script&gt;元素会忽略&lt;script&gt;和&lt;/script&gt;标签内的代码，scr属性也可以包含外部域的JavaScript文件。 1&lt;script type="text/javascript" src="http://www.somewhere.com/afile.js"&gt;&lt;/script&gt; 标签的位置&lt;script&gt;元素应该放在页面的&lt;head&gt;元素中 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Example HTML Page&lt;/title&gt; &lt;script type="text/javascript" src="example1.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="example2.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- content --&gt;&lt;/body&gt;&lt;/html&gt; 这样意味着必须等到全部的JavaScript代码都被下载、解析和执行完成后才开始呈现页面的内容。若JavaScript代码很多，这将会导致浏览器在呈现页面时出现明显的延迟，因此现代的Web应用程序一般把全部JavaScript引用放在&lt;body&gt;元素中页面内容的后面。 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Example HTML Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- content --&gt; &lt;script type="text/javascript" src="example1.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="example2.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 延迟脚本HTML4.01为&lt;script&gt;标签定义了defer属性。这个属性表明脚本在执行时不会影响页面的构造。即脚本会被延迟到整个页面都解析完毕后再运行。浏览器会立即下载，但延迟执行。 1&lt;script type="text/javascript" defer="defer" src="example2.js"&gt;&lt;/script&gt; 延迟脚本并不一定按照顺序执行，因此最好只包含一个延迟脚本。且defer属性只适用于外部脚本文件。HTML5的实现会默认忽略嵌入脚本设置的defer属性。 在XHTML文档中，要把defer属性设置为defer=”defer”。 异步脚本HTML5为&lt;script&gt;元素定义了async属性。async只适用于外部脚本文件，浏览器会立即下载文件，但标记为async的脚本并不保证按照指定它们的先后顺序执行。 12&lt;script type="text/javascript" async src="example1.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" async src="example2.js"&gt;&lt;/script&gt; 在以上代码中，第二个脚本可能会在第一个脚本执行前执行。因此要确保两者之间互不依赖。指定async属性目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。异步脚本不要再加载期间修改DOM。 在XHTML文档中，要把async属性设置为async=”async”。 在XHTML中的用法XHTML(Extensible HyperText Markup Language，可扩展超文本标记语言)是将HTML作为XML的应用重新定义的一个标准。XHTML代码的规则必HTML要严格得多，而且直接影响嵌入的JavaScript代码是否有效。 嵌入代码与外部文件使用外部文件引入JavaScript代码的优点： 可维护性：遍及不同HTML页面的JavaScript会造成维护问题。 可缓存：浏览器可以根据具体的设置换轮链接的所有外部JavaScript文件。 适应未来：HTML和XHTML包含外部文件的语法是相同的。 &lt;noscript&gt;元素若浏览器不支持JavaScript时，可以使用&lt;noscript&gt;元素显示替代的内容。这个元素可以出现在任何HTML元素(&lt;script&gt;元素除外)。包含在&lt;noscript&gt;元素的内容只在浏览器不支持脚本或脚本被禁用的情况下再回显示出来。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Example HTML Page&lt;/title&gt; &lt;script type="text/javascript" src="example1.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="example2.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- content --&gt; &lt;noscript&gt; &lt;p&gt;本页面需要浏览器支持(启用)JavaScript。 &lt;/noscript&gt;&lt;/body&gt;&lt;/html&gt; 三、基本概念语法 区分大小写 标识符： 第一个字符必须是字母、下划线(_)或美元符号($)。 其他字符可以使字母、下划线、美元符号或数字。 ECMAScript标识符采用驼峰大小写格式。 注释 //单行注释 / 多行注释 / 严格模式：在函数内部上方包含&quot;use strict&quot;;编译指示。 语句 语句结尾建议使用一个分号结尾。 始终在控制语句中使用代码块——即使代码块中只有一条语句。 不能把关键字、保留字、true、false和null用作标识符。 关键字和保留字关键字：用于表示语句的开始或结束，或者用于执行特定操作等。 保留字：保留字在JavaScript中还没有任何特定的用途，但他们有可能在将来被用作关键字。 变量ECMAScript的变量是松散类型的(可以用来保存任何类型的数据)。即每个变量仅仅是一个用于保存值得占位符。定义变量时使用var操作符。var message;,未经过初始化的变量会保存一个特殊的值——undefined。ECMAScript支持直接初始化变量var message = &quot;hi&quot;; 用var操作符定义的变量将成为定义该变量的作用域中的局部变量，该变量在函数退出后就会被销毁。 省略var操作符创建的变量为全局变量。 12345function test()&#123; message = "hi";&#125;test();alert(message); 可以使用一条语句定义多个变量 123var message = "hi", found = false, age = 29; 数据类型5中简单数据类型(基本数据类型)： Undefined Null Boolean Number String 复杂数据类型——Object(由一组无序的键值对组成) typeof操作符对值使用typeof操作符可能返回下列某个字符串： “undefined” —— 如果这个值未定义； “boolean” —— 如果这个值是布尔值； “string” —— 如果这个值是字符串； “number” —— 如果这个值是树脂； “object” —— 如果这个值是对象或null； “function” —— 如果这个值是函数。 Undefined类型Undefined类型只有一个值，即特殊的undefined。使用var声明变量但却未初始化，这个变量的值就是undefined。对未初始化和未声明的变量执行typeof操作符都可以返回undefined值。 Null类型Null类型也只有一个值，即特殊的null。null值表示一个空对象指针，使用typeof检测时返回”object”。若定义的变量用于保存对象，那么最好将变量初始化为null值而不是其他。 1alert(null == undefined); //true Boolean类型Number类型String类型Object类型操作符一院操作符位操作符布尔操作符乘兴操作符加性操作符关系操作符相等操作符条件操作符赋值操作符逗号操作符语句ifdo-whilewhileforfor-inlabelbreak和continuewithswitch函数参数没有重载####]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS层叠样式表]]></title>
    <url>%2F2018%2F03%2F31%2FCSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[层叠样式表 层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。 使用CSS样式的方式 内链样式表 123&lt;body style="background-color:green; margin:0; padding:0;"&gt;&lt;/body&gt; 嵌入式样式表 12345&lt;head&gt; &lt;style type="text/css"&gt; &lt;/style&gt;&lt;/head&gt; 引入式样式表 1&lt;link rel="stylesheet" type="text/css" href="style.css"&gt; 定义样式表定义方式 HTML标记定义 123456&lt;p&gt;...&lt;/p&gt;p&#123; 属性:属性值; 属性2:属性值2;&#125;//p可以叫选择器，定义那个标记中的内容执行其中的样式 class定义 12345&lt;p class="a"&gt;...&lt;/p&gt;.a &#123; 属性:属性值; 属性2:属性值2;&#125; id定义 12345&lt;p id="b"&gt;...&lt;/p&gt;#b &#123; 属性:属性值; 属性2:属性值2;&#125; 优先级问题 id&gt;class&gt;HTML标记 组合选择器 1234h1,h2,h3,.a,#b &#123; 属性:属性值; 属性2:属性值2;&#125; 伪元素选择器 a:link 正常连接的样式 a:hover 鼠标放上去的样式 a:active 选择链接时的样式 a:visited 已经访问过的链接的样式 常见属性颜色color属性定义文本的颜色 12345color:greencolor:#ff6600color:#f60 //简写式color:rgb(255,255,255)color:rgba(255,255,255,1) 字体font-size属性定义字体的大小font-size:14px font-family定义字体font-family:微软雅黑,serif;使用,隔开,以确保当字体不存在时直接使用下一个 font-family字体加粗normal|bold|bolder|lighter,也可以使用100|200|300~900,400=normal,700=bold 背景 背景颜色background-color 背景图片background-image:url(图片路径)|nore 背景重复background-repeat:repeat|repeat-x|repeat-y|no-repeat 背景位置background-position:横向(left,center,right)|纵向(top,center,bottom) 简写方式background:#f60 url(images/bg,jpt) no-repeat top center 文本横向排列text-align:left|center|right文本行高line-height:100%|20首行缩进text-indent:4字符间距letter-spacing:normal|10|inherit 边框 边框风格border-style 边框宽度border-width 边框颜色border-color 简写方式`border:solid 2px #f60 列表 标记类型list-style-type 123456789101112131415161718192021none 无标记。disc 默认。标记是实心圆。circle 标记是空心圆。square 标记是实心方块。decimal 标记是数字。decimal-leading-zero 0开头的数字标记。(01, 02, 03, 等。)lower-roman 小写罗马数字(i, ii, iii, iv, v, 等。)upper-roman 大写罗马数字(I, II, III, IV, V, 等。)lower-alpha 小写英文字母The marker is lower-alpha (a, b, c, d, e, 等。)upper-alpha 大写英文字母The marker is upper-alpha (A, B, C, D, E, 等。)lower-greek 小写希腊字母(alpha, beta, gamma, 等。)lower-latin 小写拉丁字母(a, b, c, d, e, 等。)upper-latin 大写拉丁字母(A, B, C, D, E, 等。)hebrew 传统的希伯来编号方式armenian 传统的亚美尼亚编号方式georgian 传统的乔治亚编号方式(an, ban, gan, 等。)cjk-ideographic 简单的表意数字hiragana 标记是：a, i, u, e, o, ka, ki, 等。（日文片假名）katakana 标记是：A, I, U, E, O, KA, KI, 等。（日文片假名）hiragana-iroha 标记是：i, ro, ha, ni, ho, he, to, 等。（日文片假名）katakana-iroha 标记是：I, RO, HA, NI, HO, HE, TO, 等。（日文片假名） 标记位置list-style-position 123inside 列表项目标记放置在文本以内，且环绕文本根据标记对齐。outside 默认值。保持标记位于文本的左侧。列表项目标记放置在文本以外，且环绕文本不根据标记对齐。inherit 规定应该从父元素继承 list-style-position 属性的值。 设置图像列表标记list-style-image 123URL 图像的路径。none 默认。无图形被显示。inherit 规定应该从父元素继承 list-style-image 属性的值。 简写方式list-style:square inside url(‘/user/hello.jpg’); DIV+CSS布局DIV和SPAN在整个HTML标记中，没有任何意义，他们的存在就是为了应用CSS样式,DIV和span的区别在与，span是内联元素，div是块级元素 盒模型 盒子外边距 margin 盒子内编剧 padding 盒子边框宽度 border 盒子宽度 width 盒子高度 height 布局相关属性 position定位方式 relative 正常定位 absolute 根据父元素定位 fixed 根据浏览器窗口定位 static 没有定位 inherit 继承 定位(离页面顶点的距离) left right top bottom z-index层覆盖先后顺序 display显示属性 none 层不显示 block 块状显示,在元素后面换行,显示下一块元素 内联显示,多个块可以显示在一行内 float属性 left 左浮动 right 右浮动 clear属性 clear:both 清除浮动 scroll无论内容是否超出层大小都添加滚动条 auto 超出时自动添加滚动条 overflow溢出处理 hidden隐藏超出层大小的内容 兼容问题及高效开发工具兼容性测试工具 IE Tester Multibrowser 常用浏览器 Chrome Firefox Opera 高效开发工具 轻量级 Notepad++ Sublime Text 重量级 WebStorm Dreamweaver 网页设计工具 fireworks photoshop]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML标记语言]]></title>
    <url>%2F2018%2F03%2F28%2FHTML%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[HTML标记语言基础 超文本标记语言(HTML)是一种用于创建网页的标准标记语言 特点 可以设置文本的格式，比如标题、字号、文本颜色、段落等等 可以创建列表 可以插入图像和媒体 可以建立表格 超链接，可以使用鼠标点击超链接来实现页面之间的跳转 HTML的语法HTML文档的保存格式 .html .htm xhtml 标记和被标记的内容构建出HTML文档,格式为&lt;标记&gt;内容&lt;/标记&gt; 标记的属性是用来控制内容(图像、文本等的)如何的显示，格式为 1&lt;标记 属性1=属性值 属性2=属性值 ......&gt;内容&lt;/标记&gt; 语法不区分字母大小写 代码注释使用”\“,代码格式使用空格和回车(在网页中不起作用)进行编排，以“TAB”键进行缩进。 字符实体 12345678910111213141516 ---------------------空格---------- &amp;nbsp; ----------&amp;#160;&lt;--------------------小于号---------- &amp;lt;---------- &amp;#60;&gt;--------------------大于号---------- &amp;gt;---------- &amp;#62;&amp;--------------------和号---------- &amp;amp;---------- &amp;#38;"--------------------引号---------- &amp;quot; ---------- &amp;#34;'--------------------撇号---------- &amp;apos; (IE不支持)---------- &amp;#39;￠--------------------分---------- &amp;cent;---------- &amp;#162;£--------------------镑---------- &amp;pound;---------- &amp;#163;¥--------------------日圆---------- &amp;yen;---------- &amp;#165;€--------------------欧元---------- &amp;euro;---------- &amp;#8364;§--------------------小节---------- &amp;sect;---------- &amp;#167;©--------------------版权----------&amp;copy;---------- &amp;#169;®--------------------注册商标---------- &amp;reg;---------- &amp;#174;™--------------------商标---------- &amp;trade;---------- &amp;#8482;×--------------------乘号---------- &amp;times;---------- &amp;#215;÷--------------------除号---------- &amp;divide;---------- &amp;#247; HTML的基本结构123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta name="keywords" content="hello world"&gt; &lt;meta charset="UTF-8"&gt; //页面的元信息，提供有关页面的元信息，针对搜索引擎和更新频度的描述和关键词 //必须的属性 content=some_text //常见属性 author keywords description others //meta标记必须放在head元素里面 &lt;/head&gt; &lt;body&gt; //网页的主体标记，可以包含段落、标题、回车、横线等标记 //常见属性 bgcolor text link vlink alink &lt;/body&gt;&lt;/html&gt; 文档设置标记格式标记&lt;br&gt; 换行标记&lt;p&gt; 段落标记&lt;center&gt; 居中标记&lt;pre&gt; 预格式化标记&lt;li&gt; 列表项目标记&lt;ul&gt; 无序列表标记&lt;ol&gt; 有序列表标记 1234567&lt;ol type="1"&gt; &lt;li type="A"&gt;&lt;/li&gt; &lt;li type="a"&gt;&lt;/li&gt; &lt;li type="a"&gt;&lt;/li&gt; &lt;li type="I"&gt;&lt;/li&gt; &lt;li type="i"&gt;&lt;/li&gt;&lt;/ol&gt; &lt;dl&gt;&lt;dt&gt;&lt;dd&gt; 定义型列表&lt;hr&gt; 水平分割线&lt;div&gt; 分区标记，也称为层标记 文本标记 hn 标题标记 font 字体设置标记 sub 下标字体标记 sup 上标字体标记 tt 打印机字体标记 cite 引用方式的字体，通常是斜体 b strong 粗体字体标记 i em 斜字体标记 small 小型字体标记 big 大型字体标记 u 下划线字体标记 图像标记使用方法 12345678&lt;img src="路径/文件名.图片格式 " width="属性值" height="属性值" border="属性值" alt="属性值"&gt;//src属性 指定我们要加载的图片的路径和图片的名称以及图片格式//width属性 指定图片的宽度，单位px、em、cm、mm//height属性 指定图片的高度，单位px、em、cm、mm//border属性 指定图标的边框宽度，单位px、em、cm、mm//alt属性 1.当网页上的图片被加载完成后，鼠标移动到上面去，会显示这个图片指定的属性文字 //2.如果图像没有下载或者加载失败，会用文字来代替图像显示 //3.搜索引擎可以通过这个属性的文字来抓取图片 注意 img为单标记，不需要使用\闭合 加载图片时，文件路径或者文件名文件格式错误，将无法加载图片 超链接的使用123456&lt;a href="" target="打开方式" name="页面锚点名称"&gt;链接文字或者图片&lt;/a&gt;//target属性 _blank 新窗口打开链接// _self() 当前窗口打开链接// _parent 父窗口打开链接// _top 顶层窗口打开链接//name属性 制定页面的锚点名称 表格table标记12345678910&lt;table width="" //px or % height="" //px or % border="" //外边框的宽度 align"" //left or center or right,default=left cellspacing="" //单元格之间的间距，默认是2px cellpadding="" //单元格内容与边框的现实距离 frame="" //控制表格边框最外层的四条线框 void above below hsides lhs rhs vsides box border rules="" //控制是否显示以及如何显示单元格之间的分割线 none all rows clos groups &gt;表格内容&lt;/table&gt; caption标记表格需要使用表格时，可以使用&lt;caption&gt;标记，caption属性位于table属性之后，tr属性之前。 属性值 top bottom left right tr标记定义表格的一行，每一行tr标记可以嵌套多个td或th标记 属性 bgcolor align 设置垂直方向对齐方式 bottom top middle valign 设置水平方向对齐方式 left right center td和th标记th是表头标记，通常 位于首行或首列，th中的文字默认会被加粗，而td不会 td是数据标记，表示该单元的具体数据 属性值 bgcolor align valign width height rowspan 设置单元格所占行数 colspan 设置单元格所占列数 HTML框架框架将浏览器划分成不同的部分，每一部分加载不同的网页，实现在同一浏览器窗口中加载多个页面的效果 frameset标记 12345&lt;frameset cols="*,* or px or %" frameborder="0 or 1" border="5px(default)"&gt; &lt;frame src="" name="" noresize="noresize" //表示不能调整框架的大小，没有设置时就可以调整 scrolling="auto or yes or no" frameborder="1 or 0"&gt; &lt;frame&gt;&lt;/frameset&gt; 表单设计表单标记123456&lt;from actoin="服务器端地址" method="post|get" enctype="" target=""&gt; //post:post方式提交时，将表单中的数据一并包含在表单主体中，一起传送到服务器中处理，没有数据大小限制 //get:get方式提交时，会将表单的内容附加在URL地址的后面，所以限制了提交的内容的长度，不超过8192个字符，且不具备保密性 //enctype 设置表单的资料的编码方式 //指定目标窗口打开方式&lt;/from&gt; 文本域和密码123456&lt;inputtype="" //text|passwordname=""value=""size=""maxlength=""&gt; 提交、重置和普通按钮12345&lt;input type="submit" type="reset" type="button"&gt; 单选框和复选框12345678&lt;input type="radio" //使用checked属性来设置默认选中项&gt;&lt;input type="checkbox" //使用checked属性来设置默认选中项&gt; 隐藏域当type为hidden时为隐藏表单域 多行文本域1234使用&lt;textarea&gt;标记可以实现一个能够输入多行文本的区域&lt;textarea name="" rows="" cols="" value=""&gt;&lt;/textarea&gt; 菜单下拉列表域12345&lt;select name="" size="" mulitple&gt; //设置多选 &lt;option value="" selected&gt;选项1&lt;/option&gt; //给选项赋值，指定传送到服务器上面的值，selected设置默认选中项 &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt;&lt;/select&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始学编程]]></title>
    <url>%2F2018%2F03%2F21%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[从零开始学编程 既然想成为一名优秀的开发者，就要一步一步，认认真真学习，直到成为一名优秀的开发者。 学习路径成为一名优秀的全栈工程师 Python HTML + CSS JavaScript Jquery Python Python Web Python常用扩展 Python进阶 JavaAndroidGitLinux网络算法数据结构学习平台系统主：macOS次：Windows 平台 慕课网 网易云课堂 百度云网盘资料 记录方式记录工具 印象笔记 MWeb Blog 记录模板 一级目录(学习技能名称) 思维导图(总) 书籍资料文件夹 SourceCode 1.文件夹(课程名称) 2.文件夹(代码) … Markdown笔记 编辑器 Sublime text3 VIM Pycharm IntelliJ]]></content>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python函数式编程]]></title>
    <url>%2F2017%2F11%2F23%2FPython%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Python高阶函数 函数式Python内建支持的一种封装，通过吧大段代码拆成函数，通过一层层调用，就可以把复杂的任务分解成简单的任务，这种分解称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！ 高阶函数变量可以指向函数函数本身可以赋给变量，即：变量可以指向函数。 12345f = absf&lt;built-in function abs&gt;f(-10)10 函数名也是变量当把abs指向10后，就无法调用abs函数了，因为abs这个变量已经不再指向求绝对值的函数而是指向一个整数。如果要恢复abs函数，只能重启Python交互环境。 123abs = 10abs(-10)Error 传入函数一个函数可以接收另一个函数作为参数，这种函数就称之为高阶函数。 1234def add(x,y,f): return f(x) + f(y)add(-5,6,abs)11 map()、reduce()、filter()和sorted()map()map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数一次作用到序列的每个元素，并把结果作为新的Iterator返回。 12345def f(x): return x * xr = map(f,[1,2,3,4,5,6,7,8,9])list(r)[1,4,9,16,25,36,49,64,81] reduce()reduce()把一个函数作用在一个序列[x1,x2,x3,…]上，reduce()必须接收两个函数，reduce把结果继续和序列的下一个元素做累积计算。 1234567#把序列转化为整数from functools import reducedef fn(x,y): return x * 10 + yreduce(fn,[1,3,5,7,9])13579 把str转换为int的函数 12345678910from functools import reducedef fn(x,y): return x * 10 + ydef char2num(s): return &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;[s]reduce(fn,map(char2num,'13579'))13579 整理成一个str2int的函数 12345678from functools import reducedef str2int(s): def fn(x,y): return x * 10 + y def char2num(s): return &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;[s] return reduce(fn,map(char2num,s)) 使用lambda函数简化 123456from functools import reducedef char2num(s): return &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;[s]def str2int(s): return reduce(lambda x,y:x * 10 + y,map(char2num,s)) filter()filter()用于过滤序列，filter()接收一个函数和一个序列两个参数，filter把传入的函数依次作用于每个元素，然后根据返回值是True或False决定保留或丢弃该元素。filter函数返回的是一个Iterator，需要用list()函数获得所有的结果并放回list。 在一个list钟，删除偶数保留基数 1234def is_odd(s): return n % 2 == 1list(filter(is_odd,[1,2,4,5,6,9,10,15])) 去掉序列中的空字符串 1234def not_empty(s): return s and s.strip()list(filter(not_empty,['a',' ','c',' '])) sorted()sorted()函数是一个高阶函数，可以接收一个key函数来实现自定义的排序。 12345sorted([-1,36,24,5,-20])[-20,-1.5,24,36]sorted([-1,36,24,5,-20],key=abs,reverse=True)[36, 24, -20, 5, -1] 返回函数函数作为返回值高阶函数除了可以接收函数作为参数外，还可以把函数作为结果值返回。 12345def calc_sum(*args): ax = 0 for n in args: ax = ax + n return ax 如果不需要立刻求和，而是在后面的代码中根据需要在计算，可以不返回求和的结果，而是返回求和的函数 1234567def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sum 闭包What在函数中定义函数，并且内部函数可以引用外部函数的参数和局部变量，当外函数返回内函数时，相关参数和变量都保存在返回的函数中，这种方式是称为“闭包”。 一般情况下，函数中的局部变量仅在函数的执行期间可用，一旦函数执行过后，局部变量将不再可用。闭包可以使得局部变量在函数外被访问编程可能。 12345678910def print_msg(): # print_msg是外围函数 msg = "The Zen of Python" def printer(): print(msg) return printeranother = print_msg()# 输出The Zen of Pythonanother() Why闭包避免使用全局变量，还能降函数与所操作的某些数据（环境）关联起来。一般来说，党对象中只有一个方法时，使用闭包时更好的选择。 12345678910def adder(x): def wrapper(y): return x + y return wrapperadder5 = adder(5)#输出15adder5(10)#输出6adder5(6) 匿名函数What匿名函数，就是没有名字的函数。关键字lambda可以创建匿名函数，匿名函数有一个限制，就是只能有一个表达式，不用写return，返回追就是该表达式的结果。 12345lambda 参数: 表达式add = lambda x,y : x + yadd(1,3)4 Whylambda函数一般适用于创建一些临时性的，小巧的函数。 1234def func(g,arr): return [g(x) for x in arr]arr = func(lambda x: x + 1,[1,2,3,4,5]) 装饰器希望增强函数的额功能，但是又不希望修改函数的定义，这种在代码运行期间动态的增加功能的方式，称之为“装饰器”，本质上，装饰器就是一个返回函数的高阶函数。 1234567def foo(): print('foo')def bar(func): func()bar(foo) 简单装饰器use_logging就是一个装饰器，它是一个普通的函数，把真正业务逻辑的函数func包裹在其中，use_logging返回的也是一个函数，这个函数的名字叫wrapper。 1234567891011 def use_logging(func): def wrapper(): print('%s is running' % func.__name__) return func() return wrapper()def foo(): print('i am foo')foo = use_logging(foo)foo() 语法糖@符号就是装饰器的语法糖，它放在函数开始定义的地方，这样就可以省略最后一步再次赋值的操作。 1234567891011 def use_logging(func): def wrapper(): print('%s is running' % func.__name__) return func() return wrapper()@use_loggingdef foo(): print('i am foo')foo() 偏函数partial函数可以固定函数参数，并返回一个新的函数，当函数的参数太多，需要固定某些参数时，可以使用functools.partial创建一个新的函数。 1functools.partial(func[,*args],[\*\*kwargs]) 转换二进制字符串 12def int2(x,base=2): return int(x,base) 使用functools.partial创建一个偏函数。 1234import functoolsint2 = functools.partial(int,base=2)int2('1000000')64 参考教程：廖雪峰的Python教程]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac常用快捷键]]></title>
    <url>%2F2017%2F11%2F22%2FMac%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Mac常用快捷键 熟练使用快捷键可以节约大量的时间，因此掌握系统和一些常用工具的快捷键可以提高工作效率，而且双手放在键盘上啪啪啪，不会中断思路，最重要的是还可以装逼哈。 系统常用一、通用 Command + X 剪切，可用于文本，文件 Command + C 复制，可用于文本，文件 Command + V 粘贴，可用于文本，文件 Command + A 全选，可用于文本，文件 Command + Z 撤销，可用于文本，文件 Command + S 保存 Command + Shift + S 另存为 Command + O 打开 Command + N 新建 Command + M 最小化 Command + H 隐藏窗口 Command + W 关闭 Command + Q 退出 Command + P 打印 Command + Space 打开Spotlight Control + Command + Space 打开emoji表情 二、文件管理器 Command + Tab 在应用程序切换 Command + ` 在应用程序中的窗口切换 Command + I 显示简介 Command + N 新建文件夹 Command + F 搜索，适用于文本，浏览器，文件 Command + 1/2/3/4 切换文件夹显示模式 Command + Backspace 三、截屏 Command + Shift + 3 截取整个屏幕并保存到桌面 Command + Shift + 4 截取选择区域并保存到桌面 Command + Shift + 4 + Space 截取选择窗口并保存到桌面 Control + Command + Shift + 3 截取整个屏幕并粘贴到剪贴板 Control + Command + Shift + 4 截取选择区域并粘贴到剪贴板 Control + Command + Shift + 4 + Space 截取选择窗口并粘贴到剪贴板 四、浏览器 Command + +/- 放大/缩小 Command + N 新建窗口 Command + T 新建一个标签 Command + R 刷新 Command + W 关闭当前标签 Command + D 添加到收藏夹 Command + L 光标移动到地址框 Space 下一页 Command + Shift + T 重新打开关闭页面 Command + Z Safari重新打开关闭页面 五、应用QQ Control + Command + A 微信/QQ截图 VIM常用一、编辑PyCharm常用一、编辑 Control + Space 基本的代码补全 Control + Shift + Space 智能代码补全 Command + / 注释/取消注释一行 Command + 展开当前 Command - 折叠当前 Shift + Command + 展开所有 Shift + Command - 折叠所有 Shift + Enter 下行另起一行 Control + Y 删除当前行 Control + D 复制所选区域或行到后面或下一行 Control + Alt + O 自动导入 Command + Alt + L 代码格式化 Control + Alt + I 自动缩进 Control + Q 快速查看文档 Command + F1 显示错误描述或警告信息 Control + J 快速查看文档 Control + O 覆盖方法 Control + I 实现方法 Command + Alt + T 包围代码（if else or try catch） Command + Shift + U 大小写转换 二、查找和替换三、编译和运行四、导航五、重构六、通用此文有待更新。]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>常用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac常用命令]]></title>
    <url>%2F2017%2F09%2F15%2FMac%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[macOS常用命令整理,此文记录了平常使用终端的一些基本命令，使用命令行进行操作还是很有成就感的，建议使用Mac的用户可以学习一下一些基本的命令。 man 1234$man command-nameeg:$man ls$man -k #search all command pwd cd ls 123$ls -la$pwd$cd cat less which file 123456789$cat #check test file$cat a.txt &gt;&gt; b.txt$less #high grade than cat #spacekey-&gt;paging #/ search #Q quit #v go to vi editor$whicch command-name$file filename #check file find &amp; mdfind edit file and directory 1234$mkdir -p a/b/c/d/e$cp -R &lt;file&gt; a/b/ file --&gt; b/$mv -R &lt;file&gt; a/b/ file --&gt; b/$rm -R directory/file vi and nano su and sudo open . control + c history control + l == clear]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基础教程]]></title>
    <url>%2F2017%2F09%2F12%2FGit%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Git基础教程Git学习笔记,此文记录一些常用Git命令，熟练使用Git应该是开发者必须要掌握的一门技术。 安装git和初始化安装1$brew install git 用户名和邮箱设置12$git config --global user.name "yourname"$git config --global user.email "email@example.com" 添加SSH到github 生成本地ssh-key 1$ssh-keygen -t rsa -code "youremail@example" 打开主目录中的id_rsa.pub文件 1$vim /User/用户名/.ssh/id_rsa.pub 添加ssh-key到github-settings-SSH and GPG keys 测试12$ssh -T git@github.comHi entercoder1993! You've successfully authenticated, but GitHub does not provide shell access. 创建版本库初始化12$git clone &lt;url&gt; #克隆远程版本库$git init #初始化版本库 把文件添加到仓库，可以添加一个或多个1$git add &lt;-A/--all&gt; 把文件提交到仓库，可以一次提交多个文件1git commit -m "message" 查看仓库的状态1git status 查看文件修改内容1$git diff 查看提交历史记录1$git log &lt;--pretty=oneline&gt; 在Git中，HEAD表示当前版本，上一个版本就是HEAD^，上上个版本就是HEAD^^使用git reflog可以记录每一次的命令工作区 本地目录 版本库 .git中包含index、master和指针HEAD 暂存区(index) git add –&gt;暂存区 master分支 git commit –&gt;master 查看工作区与版本库的区别1git diff HEAD -- &lt;file&gt; #如果修改之后没有git add到暂存区，使用git commit就不会将修改提交到master中 如果要丢弃工作区的修改，可以使用1git checkout -- &lt;file&gt; #即文件在工作区的修改全部撤销，撤销后文件会回到最后一次git commit或git add的状态 git reset HEAD &lt;file&gt;可以把暂存区的修改撤销，重新放回工作区删除一个文件1$git rm &lt;file&gt; 远程版本库登陆后再右上角找到Create a new repo，创建一个新的远程仓库，填入对应的仓库名称 123$git remote add origin git@github.com:&lt;name&gt;/&lt;reponame&gt;.git$git push -u origin master #第一次推送master分支的所有内容$git push origin master #后续使用此命令极客推送 分支管理创建与合并 查看分支 git branch 创建分支 git branch &lt;name&gt; 切换分支 git checkout &lt;name&gt; 创建+切换分支 git checkout -b &lt;name&gt; 合并某分支到当前分支 git merge &lt;name&gt; 删除分支 git branch -d &lt;name&gt; 解决冲突在分支中的修改与master中的修改冲突时，使用git merge合并时会存在冲突，可以使用git status查看冲突，并需要到修改的文件中解决冲突，解决完成后再进行add&amp;commit就可以解决分支中的冲突问题，解决完成后就可以使用git branch -d &lt;name&gt;删除冲突，也可以使用git log --graph查看分支的合并情况。 分支管理策略合并分支时，Git会使用Fast forward模式，这种模式，删除分支后，会丢掉分支信息，如果禁用Fast forwar模式，Git就会在merge时生成一个新的commmit，这样就可以在分支历史中看出分支信息。 1$git merge --no-ff -m "message" &lt;baranchname&gt; bug分支若master分支出现bug，需要及时修改，我们可以使用git stash把目前修改的分支储存起来，然后将分支切换到出现bug的分支，并创建bug分支，解决完成后，使用 1234$git stash list #查看分支存储信息$git stash apply #恢复储存信息，但stash的内容不删除$git stash drop #将储存信息删除$git stash pop #恢复的同事删除储存信息 Feature分支未被合并的分支，需要删除分支的，使用git branch -D &lt;branchname&gt; 多人协作使用git remote查看远程仓库的信息加上-v可以查看详细信息 推送分支将本地分支的所有提交提交到远程库，推送时要指定本地分支，这样git就会把该分支推送到远程库对应的分支上 12$git push origin master$git push origin dev 抓取分支 查看远程库信息，使用git remote -v 从本地推送分支，使用git push origin branchname 若推送失败，先用git pull抓取远程的新提交 在本地创建和远程分支对应的分支，使用git checkout -b branchname origin/branchname本地和远程分支的名称最好一致 建立本地分支与远程分支的关联，使用git branch --set-upstream branchnanme origin/branchname 从远程抓取分支，使用git pull，如果有冲突，要先才处理冲突 标签管理虽然可以使用commit id来退回版本，但是并不好找，所以使用tag标记为容易记住的有意义的名字，跟某个commit绑定在一起 创建标签git tag &lt;name&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit idgit tag -a &lt;tagname&gt; -m &quot;message&quot;可以指定标签信息git tag -s &lt;tagname&gt; -m &quot;message&quot;可以用PGP签名标签git tag可以查看所有标签 操作标签git push origin &lt;tagname&gt;可以推送一个本地标签git push origin --tags可以推送全部未推送过的本地标签git tag -d &lt;tagname&gt;可以删除一个本地标签git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac安装配置MySQL]]></title>
    <url>%2F2017%2F09%2F05%2FMac%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEMySQL%2F</url>
    <content type="text"><![CDATA[Mac下安装配置MySQLMac下MySQL的安装其实是很简单，用brew一行代码就解决了，但是安装完成后并不能直接开始用，会出现一些错误，此文可以解决安装后无法使用的问题。 安装使用命令行执行 1$brew install MySQL 即可安装完成 配置 命令行输入 1$sudo chown -R 'Mac用户名' /usr/local 连接 1$brew link --overwrite mysql 命令行输入 1234unset TMPDIR$bash mysql_install_db --verbose --user=root--basedir="$(brew --prefix mysql)"--datadir=/usr/local/var/mysql --tmpdir=/tmp 启动mysql 1$mysql.server start 关闭mysql 1$mysql.server stop 常用Mysql用法 待补充]]></content>
      <categories>
        <category>macOS</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Mac</tag>
        <tag>Setting</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的Mac小技巧]]></title>
    <url>%2F2017%2F09%2F05%2F%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Mac%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[Mac可以添加自定义功能 主要是利用Automator来添加快捷功能，例例如右键添加复制文件或文件夹路径等。 1.在Finder中打开应用程序 2.双击打开Automator.app 3.选择服务，点击选取 4.设置服务受到选定的文件或文件夹，位于Finder 5.在资源库中找到拷贝到剪贴板，拖动到右边窗口中 6.退出保存，将名称改为拷贝到剪贴板即可。 Mac下显示和隐藏文件打开终端，输入以下命令： 12345//此命令显示隐藏文件defaults write com.apple.finder AppleShowAllFiles -bool true//此命令关闭显示隐藏文件defaults write com.apple.finder AppleShowAllFiles -bool false 命令运行之后需要重新加载Finder：快捷键option+command+esc，选中Finder，重新启动即可 截屏 将屏幕图片存储为文件 Shift + Command + 3 将屏幕图片拷贝到剪贴板 Ctrl + Shift + Command + 3 将所选区域的图片存储为文件 Shift + Command + 4 将所选区域的图片拷贝到剪贴板 Ctrl + Shift + Command + 4 Split Screen分屏功能按住窗口的最大会绿色按钮不放，选择放置在左边或者右边，然后选择另一个应用即可进行分屏，可以拖动中间的分割线调整左右区域的大小 2018.09.05更新]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>常用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python高级特性]]></title>
    <url>%2F2017%2F09%2F02%2FPython%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Python高级特性 在Python中，代码不是越多越好，而是越少越好。代码不是越复杂越好，而是越简单越好 切片切片就是对字符串进行各种截取操作。 1234567891011121314151617&gt;&gt;&gt; l = list(range(1,10))&gt;&gt;&gt; l[1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; l[0:3] #0-3[1, 2, 3]&gt;&gt;&gt; l[:3] #0-3[1, 2, 3]&gt;&gt;&gt; l[-2:] #倒数切片[8, 9]&gt;&gt;&gt; l[::3] #每隔三个数[1, 4, 7]&gt;&gt;&gt; l[:][1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; (1,2,3,4,5,6)[:3] #tuple(1, 2, 3)&gt;&gt;&gt; 'abcdefg'[:3] #字符串切片'abc' 迭代通过for循环来遍历list或tuple 123456&gt;&gt;&gt; for ch in 'abc':... print(ch)...abc 默认情况下迭代value，可以用for value in d.value()同时迭代key和value，可以用for k,v in d.items可以用Iterable判断一个对象是否为可迭代对象 1234567&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance('abc',Iterable)True&gt;&gt;&gt; isinstance([1,2,3],Iterable)True&gt;&gt;&gt; isinstance(123,Iterable)False 通过enumerate可以把一个list变成索引-元素对 123456&gt;&gt;&gt; for i,value in enumerate(['a','b','c']):... print(i,value)...0 a1 b2 c 列表生成式1234567891011121314151617&gt;&gt;&gt; list(range(1,11))[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; [x * x for x in range(1,11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100]&gt;&gt;&gt; [x * x for x in range(1,11) if x % 2 == 0][4, 16, 36, 64, 100]&gt;&gt;&gt; [m + n for m in 'abc' for n in 'xyz']['ax', 'ay', 'az', 'bx', 'by', 'bz', 'cx', 'cy', 'cz']&gt;&gt;&gt; import os&gt;&gt;&gt; [d for d in os.listdir('.')]['.android', '.atom', '.bash_history']&gt;&gt;&gt; d = &#123;'x':'a','y':'b','z':'c'&#125;&gt;&gt;&gt; [k + '=' + v for k,v in d.items()]['x=a', 'y=b', 'z=c']&gt;&gt;&gt; l = ['Hello','Word','IBM','Apple']&gt;&gt;&gt; [s.lower() for s in l]['hello', 'word', 'ibm', 'apple'] 生成器一边循环一边计算的列表成为列表生成器 123456&gt;&gt;&gt; l = [x*x for x in range(10)]&gt;&gt;&gt; l[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x*x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x10eecc200&gt; l和g的区别仅在于最外层的[]和()，l是一个list，而g是一个generator，需要通过next()函数才能获得generator的下一个返回值 1234&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1 generator保存的是算法，每次调用next(g)，直到最后一个元素时就会抛出StopIteration的错误。可以使用for循环来迭代generator 12345678910111213141516171819&gt;&gt;&gt; def fib(max):... n,a,b=0,0,1... while n &lt; max:... yield b... a,b = b,a+b... n = n + 1... return 'done'...&gt;&gt;&gt; fib(6)&lt;generator object fib at 0x10eecc2b0&gt;&gt;&gt;&gt; for n in fib(6):... print(n)...112358 迭代器可以直接作用于for循环的数据类型： 集合数据类型，如list、tuple、dict、set、str等； generator，包括生成器和带yield的generator function。 这些可以直接作用于for循环的对象称为可迭代对象：Iterable，可以使用isinstance()判断一个对象是否是Iterable对象。生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator可以使用iter()函数把Iterable变成Iterator 123&gt;&gt;&gt; from collections import Iterator&gt;&gt;&gt; isinstance(iter('abc'),Iterator)True Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。 Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云服务器搭建流程]]></title>
    <url>%2F2017%2F08%2F31%2F%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[云服务器搭建流程 正好京东云搞服务，弄了一个月体验时间，这边文章是使用京东云的服务器体验云服务器整个搭建的流程。 登录京东云服务器后台浏览器输入http://www.jcloud.com输入京东账号密码进入京东云管理界面，创建系统版本为Ubuntu16.04 64位，创建完成后在云主机上就可以查看到公网/内网IP地址 使用ssh登录远程连接打开终端，在终端执行 1$ssh root@116.196.109.126 #该IP地址为公网IP地址 然后输入密码，密码会以短信形式发送到手机上，在/home目录下新建一个文件夹dzd，把相关文件都放在这个目录下 123$cd /home$mkdir dzd$cd dzd 下载安装jdk因为Tomact服务器是依赖jdk的，所以这里要先下载安装jdk下载jdk 12$wget --no-cookies --header "Cookie: oraclelicense=accept-securebackup-cookie" http://download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gztar -zxvf /home/dzd/jdk-8u144-linux-x64.tar.gz -C /usr/java/ 配置环境变量 12345678vi ~/.bashrc#在最下面添加java环境变量配置信息export JAVA_HOME=/usr/java/jdk1.8.0_144export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH#退出vi编辑器，输入下行命令使配置文件立即生效source ~/.bashrc 下载安装Tomact下载Tomact服务器 1$wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-7/v7.0.81/bin/apache-tomcat-7.0.81.tar.gz 解压 1$tar -zxf apache-tomcat-7.0.81.tar.gz 启动服务器1234#切换到bin目录下cd apache-tomcat-7.0.81.tar.gz/bin#运行startup.sh启动服务器./startup.sh 打开浏览器，输入http://116.196.109.126:8080/就可以看到服务器启动成功的页面 添加静态页面或json文件123$cd ..$cd webapps/ROOT/$vi hello.html 在浏览器输入116.196.109.126:8080/hello.html就可以访问到刚才创建的html静态页面了 遇到的问题 问题1：解压jdk压缩包错误，使用tar -zxvf 文件始终无法解压文件 使用file查看jdk压缩包发现是html文件格式，因此无法进行解压缩，删除文件后重新进行下载，若使用wget的话，一定要在后面加上这个参数–no-cookies –header “Cookie: oraclelicense=accept-securebackup-cookie” 1$wget --no-cookies --header "Cookie: oraclelicense=accept-securebackup-cookie" jdk下载链接 这样下载的jdk压缩包就可以进行解压缩了 问题2：创建静态文件后，使用vi编辑，输入中文乱码 打开vi的配置文件 123456$vi /etc/vim/vimrc#去掉#if has("autocmd") 及下面2行的注释#并在最下方加入set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936set termencoding=utf-8set encoding=utf-8]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac常用软件]]></title>
    <url>%2F2017%2F08%2F31%2FMac%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[记录自己使用Mac下载的软件及相关配置，备忘 Mac安装软件下载及配置AppStore安装 QQ 微信 迅雷 百度网盘 网易云 Alfred 有道词典 印象笔记 Dr. Clean Excel Word PowperPoint 搜狗输入法 IINA 坚果云 程序员必备 iTerm2 ohmyzsh autojump zsh-syntax-highlighting zsh-autosuggestions Dash Sublime Test3 Android Studio Python Git SpaceLauncher Spectacle PyCharm Parallels Eclipse Node.js npm cask Hexo 谷歌浏览器 SSR Go2shell Charles MacDown PDF Expert MindNote 实验楼 Focus chrome插件 1Player for 网易云音乐 AdBlock Bookmark Sidebar ChaZD Google Keep Google 翻译 Infinity新标签页 Octotree Save to Pocket search2 Stylish Vimium 印象笔记·剪藏 滴答清单 命令行工具 you-get musicbox HomeBrew BrewCask cmatrix 123$brew cask install software-name$brew install package-name update:2017.11.22]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Setting</tag>
        <tag>常用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础]]></title>
    <url>%2F2017%2F08%2F30%2FPython%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Python基础 Python是一种解释型、面向对象、动态数据类型的高级程序设计语言。目前，Python已经成为最受欢迎的语言之一。人生苦短，我用Python。 基本语法规则 以#开头的语句时注释 当语句以:号结尾时，缩进的语句视为代码块 缩进按照约定俗成的管理为4个空格 Python时大小写敏感的 数据类型和变量 整型：在程序中和数学上的写法一致，当使用十六进制表示整数时，用0x前缀和0～9，a～f表示 浮点数：浮点数也就是小数，对于很大或很小的浮点数，使用科学计数法表示，把10用e替代，1.23*e9表示1.23乘以10的九次方，0.000012可以写成1.2e-5 字符串：字符串以’或”括起来的任意文本，’’或””本身是一种表示方式，不是字符串的一部分，如果’或”也是字符的一部分，可以用””或’’括起来，若内部包含’和”，可以用\来表示，如果字符串有很多字符都需要转义，可以使用r’’…’’表示内部的字符默认不转义，如果字符串内部有很多换行，可以使用’’’…’’’表示多行内容（\n表示换行，\t表示制表符，\\表示\） 布尔值：布尔值只有True和False两种值（注意大小写），布尔值也可以用and、or和not运算 空值：空值是Python里的一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值 变量：变量在程序中用一个变量名表示，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，在Python中，可以把热议数据类型赋值个变量，同一个变量可以反复赋值，而且可以是不同类型的变量。这种变量类型不固定的语言称之为动态语言 常量：所谓常量就是不能变的变量，用全部大写的变量名表示出常量只是一个习惯上的用法。在Python中有两种除法，一种除法是/，/除法计算结果是浮点数，即使是两个整数恰好相除，结果也是浮点数，还有一种除法是//，称为地板除，两个整数的除法仍然是整数： 12345678&gt;&gt;&gt; 10 / 33.333333333333&gt;&gt;&gt; 6 / 33.0&gt;&gt;&gt; 10 // 33 字符串和编码字符编码因为计算机只能处理数字，如果要处理文本，需要先把文本转化为数字才能处理。中国汉字编码GB2312。Python中默认的编码模式是ASCII格式，需要在Python文件开头加入# -*- coding: UTF-8 -*-或#coding=utf-8即可 Python字符串 在Python中，字符串是以Unicode编码的，对于单个字符的编码Python提供了ord()函数获取字符的整数表示，char()函数把编码转换为对应的字符 1234&gt;&gt;&gt;ord('A')65&gt;&gt;&gt;chr(26460)'杜' 十六进制 12&gt;&gt;&gt;'\u4e2d\u6587''中文' 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。’ABC’是字符串 1234&gt;&gt;&gt;x = b'ABC'&gt;&gt;&gt;y = 'ABC'&gt;&gt;&gt;print(x == y)False 以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如： 12&gt;&gt;&gt; '中文'.encode('utf-8')b'\xe4\xb8\xad\xe6\x96\x87' 纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法： 1234&gt;&gt;&gt; b'ABC'.decode('ascii')'ABC'&gt;&gt;&gt; b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')'中文' len()函数可以用来要计算str包含的字符数也可以计算bytes的字节数 1234567&gt;&gt;&gt;len('ABC')3&gt;&gt;&gt;len('中文')2&gt;&gt;&gt;len(b'ABC')3&gt;&gt;&gt;len('中文'.encode('utf-8')) 1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。 12#!/usr/bin/env python3 #linux/OS X系统下为可执行程序# -*- coding: utf-8 -*- #按UTF-8读取源代码 格式化 在Python中格式化的方式和C一样使用%输出格式化字符 %运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%f表示用浮点数替换，%x表示用十六进制替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。 123456789#!/usr/bin/env python3# -*- coding: utf-8 -*-s1 = int(input('去年的成绩：'))s2 = int(input('今年的成绩：'))r = (s2 - s1) / s1 * 100if s1 &gt; s2: print('下降了：''%.1f %%' % r)else: print('提升了：''%.1f %%' % r) 使用list和tuplelistPython内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。索引从0开始，超出列表长度时会报错，最后一个元素的索引是len(list)-1，还以用len[-1]直接获取最后一个元素，list中元素类型可以不同。 12345678&gt;&gt;&gt;len(list) #可以获得list列表的长度&gt;&gt;&gt;list.appen() #追加元素到list的末尾&gt;&gt;&gt;list.insert(i) #插入元素到指定位置&gt;&gt;&gt;list.pop(i) #删除末尾的元素，用pop()，使用pop(i)删除指定位置的元素 #若要替换元素，则直接赋值给对应的索引位置&gt;&gt;&gt; list = []&gt;&gt;&gt; len(list)0 tuple另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改。定义tuple时，tuple的元素必须被确定下来 123456789&gt;&gt;&gt;t = (1,2)&gt;&gt;&gt;t(1,2)&gt;&gt;&gt;t = ()&gt;&gt;&gt;t()&gt;&gt;&gt;t = (1,)&gt;&gt;&gt;t(1,) 若tuple中包含list，则该tuple中的list元素可变，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 条件判断123456789101112#if语句的完整形式if &lt;条件判断1&gt;: &lt;执行1&gt;elif &lt;条件判断2&gt;: &lt;执行2&gt;elif &lt;条件判断3&gt;: &lt;执行3&gt;else: &lt;执行4&gt;if x: print("True") #只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False 循环 for循环 for x in ...循环就是把每个元素代入变量x，然后执行缩进块的语句。 range()函数可以生成一个整数序列，通过list()函数装换为list。 12list(range(5))[0,1,2,3,4,] while循环 while循环，只要条件满足，就不断循环，条件不满足时退出循环。 123while ... #条件 ... #条件满足时执行print() #条件不满足执行 break和continue 在循环中，在满足break语句前的if语句条件时执行，可以提前退出循环。 continue的作用是提前结束本轮循环，不会执行满足if条件时的语句，直接开始下一轮循环。 注意：不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。 使用dict和setdictdict在其他语言中也称为map，使用键-值存储，具有极快的查找速度，一个key只能对应一个value，多次对一个key放入value，后面的值会把前面的值替换掉。若key不存在，则dict报错，可以通过in或get方法判断key是否存在。dict的key必须是不可变对象。 12345&gt;&gt;&gt;'abc' in sFalse&gt;&gt;&gt;d.get('abc')&gt;&gt;&gt;d.get('abc',x)x 可以通过pop(key)方法删除对应的key，dict内部存放的顺序和key放入的顺序无关。list相比，dict特点： 查找和插入的速度快，不会是UI这key的增加而增加 占用大量内存，浪费内存 list相反： 查找和插入的时间随着元素的增加而增加 占用空间小，浪费内存少 setset和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。注意：传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。要创建一个set，需要提供一个list作为输入集合： 1234567891011121314151617&gt;&gt;&gt;s = set([1,2,3])&gt;&gt;&gt;s&#123;1,2,3&#125;&gt;&gt;&gt;x = set([1,1,2,2,3,3])&gt;&gt;&gt;x&#123;1,2,3&#125;&gt;&gt;&gt;s.add(4)&gt;&gt;&gt;s&#123;1,2,3,4&#125;&gt;&gt;&gt;x.remove(3)&gt;&gt;&gt;x&#123;1,2&#125;#set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等&gt;&gt;&gt;s &amp; x&#123;1,2&#125;&gt;&gt;&gt;s | x&#123;1,2,3,4&#125; 函数 函数是最基本的一种代码抽象的方式 调用函数官方文档 要调用函数首先要知道函数的名称和参数。 1234abs(100)100abs(-100)100 若传参个数或类型错误，都会报TypeError错误 数据类型转换Python内指定额常用函数还包括数据类型转寒函数 1234567891011121314&gt;&gt;&gt; int('123')123&gt;&gt;&gt; int(12.34)12&gt;&gt;&gt; float('12.34')12.34&gt;&gt;&gt; str(1.23)'1.23'&gt;&gt;&gt; str(100)'100'&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool('')False 函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”： 123&gt;&gt;&gt; a = abs # 变量a指向abs函数&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数1 定义函数在Python中，定义一个函数使用def语句def name(args): return 执行语句若没有return语句，则返回None。return None == returnfrom x import y用来导入x.py文件中定义的y函数。 空函数12345dep nop(): passif age &gt;= 18 pass pass语句什么也不做，但是可以用来作为占位符 参数检查内置函数会检查出参数错误，而我们定义的函数没有参数检查，两种同样的错误就会导致语句中出错的原因不同。可以用isinstance()做参数数据类型检查。 1234def people(name,age): if not isinstance(name,(str)): raise TypeError('bad operand type') return print(name,age) 返回多个值123456789101112131415import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print(x, y)151.96152422706632 70.0#返回值放在一个tuple中&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print(r)(151.96152422706632, 70.0) 函数的参数 位置参数 12dep power(x): return x * x 对于power(x)函数，参数x就是一个位置参数。当调用power函数时，必须传入有且仅有的一个参数x 递归函数参考教程：Python教程,廖雪峰的官方网站]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
</search>
