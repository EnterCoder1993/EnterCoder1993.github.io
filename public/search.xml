<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Learning-to-Code]]></title>
    <url>%2F2018%2F08%2F29%2FLearning-to-Code%2F</url>
    <content type="text"><![CDATA[Learning-to-Code 一些有用的心灵技巧解决你最内心的恐惧 我们来谈谈如何保持正轨。当你觉得有太多东西需要学习时，如何继续学习。当你感觉自己从未获得第一个编码工作时，如何继续前进。 你发现自己在想：“也许我不是因为它而被切断了？” 这就像跟着你，模糊和歪曲事实云，因此它可以呈现的状况是多么糟糕无望如果那样的话，并和怎么也没有办法，你可以做到这一点。 嗯，我不知道你，但对我来说，这种情况每4-5天发生一次。 自2014年11月以来，我一直在学习编码，慢慢沉浸在这个领域。我使用了各种资源：书籍，在线课程，在线挑战，博客文章，教程等。freeCodeCamp对我的学习产生了很大的影响，通过对编码进行积极的转变，以及一条前进的明确路径。 在那段时间里，我经常不得不打击我的思想，吓跑我。我几乎可以肯定你也会经常遇到这种情况。 史蒂芬普莱斯菲尔德埃斯塔力在他的书艺之战有句名言被称为“抵抗”。我强烈建议你“读这本书。我发现自己每天都在使用它的课程（有些日子甚至是小时）。 在这篇文章中，我将分享一些心理技巧，用于消除消极性“云” - 抵抗 - 这可能是如此难以击败。所有的建议都是基于我到目前为止所学到的，如果你有其他想法 - 请在这里分享！ 我将跳过最常见的激励建议（通常过于宽泛而无法采取行动），并专注于不寻常但有效的建议。我已经使用了这些技术并发现它们有效，我希望你也会这样做。 意识到每个人都经历过抵抗在学习新技能时，许多人认为如果事情没有顺利进行，那就不适合他们。我们总是幻想在我们的如何，对某些人来说，一切都自然地流淌思想，只是他们迅速向前滑行所有的表面上，而不会遇到在他们的旅程的任何问题和障碍。 这不可能是事实。他们可能难以克服我们可能甚至不知道的事情。他们可能会被拒绝，失望，他们可能会感到绝望。我们不知道。不要以你想象的另一个人的旅程的标准判断自己。 当然，有一点可能会吃他们更容易，这可能是编码，但我向你保证，还有其他的10件事情，他们都希望自己能做得更多，但仍然轻松挣扎。 （为了让你了解这个抵抗力量有多强大：我在2015年12月开始写这篇文章。是的，我知道。） 如何练习：不要再考虑困难，因为围绕着你建造的这些墙壁让你不能去你想去的地方。将它们视为实现目标的障碍 - 让您变得更强大的挑战。 不要让自己相信你经历这些情感这一事实意味着你不会因为编程而被裁掉。每个人在尝试学习新的东西时都会遇到同样不舒服的情绪。推动你的界限和你所谓的“限制”（嘘没有勺子）是痛苦的。 你觉得什么是抵抗。 它很自然，如果你用它作为你的指南针它可以成为你的朋友。这是一个告诉你正走在正确道路上的标志，也是个人成长的道路。 每天都在计算当看到已经在技术领域的人时，很容易（相信我这一点）变得气馁。如果你专注于拥有数千名粉丝的开发人员以及对主题的大量了解，那就更容易让人气馁。 问题在于，这些是您在Twitter上看到的人，或者是谷歌搜索视频，教程和编码文章的结果。 您很少看到了解该领域98％左右的常规开发人员。 我并不是说你的目标应该是成为98％中的一员。 （你应该比这更进一步）。我要说的是，它很容易自己吓到，以为是有隐喻的大峡谷，你和专业的开发人员之间。 所以，你已经花了几个月的学习代码，但它好像你还是那么远从正反那你想知道：怎么可以这么遥遥领先他们？我有什么希望能够达到这个水平吗？ 嗯，这是你的思想在你身上耍花招的地方。你不看专业的小提琴家，并认为对自己说：“哦，我一直在学习，现在打了一年小提琴，为什么我不能望其项背在执行自己的水平？” 但是通过编码，我们中的许多人每次都这样做。 你认为一个你认为是一个可靠的开发人员的人会忽略那个人的其他一切。你想：“这很简单。他们是一个伟大的程序员，我不是。就是这样。“ 你不考虑如何可能有一个人与编程或数学奋斗和努力克服这些困难，或有可能下班后花了试图理解卡住的错误消息，并且担心同样的事情，你是无数个夜晚。或者他们如何在全日制大学学习软件开发方面花了4年时间。 没人说这很容易。学会做好事需要时间。很多时间。抵抗基本上告诉你，他们在那个级别怎么样，你不是？怎么了？应该很容易，必须有快速的方法，快捷方式，秘密，东西！ 提醒自己，没有什么东西是无用的东西。关键是你应该知道你有可能到达那里。需要时间，是的，但那又怎么样？所有有价值的事情都需要时间。 如何练习：这是我学习编码和技术的主要难题之一。如果没有这个，我可能已经放弃了编码，就像我放弃了多年来我试图学习的许多其他东西。 在这里，它是：想象有多少人摆脱了那些已经开始了大致相同的一天编码上像你一样已经停止 - 或将退出今天 - 在同一诱惑让步停止的痛苦和学习的不适。 想想你在旅程中发展的力量（心理，情感）。每当你做出更进一步的决定时，你的意志和韧性就会增加，不要停留在你的位置，不要承认失败。您每天编码都是您赢得的那一天。 全力以赴因此，您已决定自学编码。什么阻止你在6个月没有看到你想看到的结果后退出？ 你需要一个目标来努力。一旦你的目标，这将是难以停止，而不是一个情况涉足如果您正在使用的代码，或不特定的，定义明确的目标，学习。 我最初的目标是找到一份编码工作。这花了我大约14个月的时间。我在当时的营销全职工作，所以整天晚上我无法代码，但我试图在尽可能多的时间去挤，因为我可以编码到每一天。 明确目标的另一个好处是，您可以更轻松地在想要学习的主题之间进行选择。我相信这将是主要的JavaScript技术我在在职使用，所以它更容易说不改道成Python，Ruby和其他语言。 重点关注你的努力。如果它们看起来像风玫瑰，将单个光线带入中心，您就会变成激光。你知道激光器的效果如何。有时，我们都需要收集试图向四面八方传播的光线，并将其重点放在我们的目标上。 一旦你决定了你的目标，全力以赴。花费尽可能多的时间来编码。 谁在乎您是否有所有日子或每天只有1小时？如果你没有它，你有多少时间或没有多少都没关系。 我读过的人照顾小孩和学习的代码时，他们有片刻的故事，但我没有看到的“一个故事，我怎么有我的天免费一年，我还是没能学会编码“。你知道为什么吗？这些人没有故事可讲。 使用您“不知道你有时间：在编码下载有声读物，听它，得到一本书，读它在地铁或公共汽车，如果你上班地点或其他地方。尝试使用多种类型的学习，但请确保您遵守相同的主题。 不要过头，成为气馁 - 如果你觉得你不能拿的JavaScript或Python（或任何其他受你关注）了，一天的休息放松，做别的事情。 我想传达的概念是，如果你担心你没有足够的时间去学习的代码，这可能只是你的担心是骗你的。这发生在我身上 - 我常常会想：它需要多长时间我学习ESTA而全职工作？我有没有机会坚持到底？ 请记住，你今天付出的努力越多（不打算明天投入），你到达那里的速度就越快。 如何练习：确定一个具体，切合实际的目标。一个定义明确的目标将是：“我想找到一份工作，前端Web开发的未来12个月内”或者说：‘我将创建3个单独的iOS应用在接下来的8个月里。’ 尽可能使用，并将所有精力集中在学习编码上。为什么呢？因为它是不容易的，时间越长你传播因为你的学习时间（除非你有具体时限的目标），你就越有可能会成为的“进展缓慢”的感觉气馁。 你足够聪明。我开始学习之旅时的另一个大恐惧是，我不够聪明，无法比较那些花时间解决数学，物理和编程问题的人。他们在3岁时开始编程，并在5岁时构建编译器。 我误以为编程中的每个人都是拥有博士学位的工程师。来自常春藤联盟大学，对我来说已经太晚了。 首先，我已经知道科技行业中有这么多人，他们有不同的编码途径。所以我可以开始相对较晚。 其次，更重要的是，我仍然担心“如果我不能在那里获得最好的软件工程工作怎么办？”就像Google和Facebook一样。起初我可能不会，但我会全力以赴达到这个水平。 我确信的事情是 - 如果一个人长时间保持编码并使练习刻意 - 他们将达到他们渴望的任何水平。 通过刻意练习，我的意思是： 检查代码中的错误和问题回到某些问题并试图以更好的方式解决它们阅读其他人的代码，看看他们是如何解决这些问题的重构你的旧代码简单地说：做返工而不是尝试新事物并一直切换主题。 如何练习：相信我，你足够聪明。相信你是，并且不要让“我不够好”的想法溜进来。它们本质上具有破坏性。 我将与您分享一个肯定，我不在乎您对肯定的看法： “我配得上生活中最好的一面，我可以做任何我梦寐以求的事情！” 如果你发现自己害怕自己不够聪明，那就重复一下这个肯定。每当恐惧得到你的想法，或者你需要的那一天多次，你可能想要重复它5次。你的思维就像粘土一样，你的工作就是训练它并将它塑造成你的朋友。 看看我们我们和你一样。所有人都渴望编码并变得更好。我们都有同样的恐惧。 如果你将它作为一个专业的开发人员，最终的因素不是你的智商或你的“代码才能”，而是你的弹性和勇气。 有一座山 - 珠穆朗玛峰，更高的机会，你会不会做它，你会吓跑你自己，因为出来的成功，而不是不被其他一些人一样聪明（你的项目或人在谁在你的心中非凡的光彩）。 如果您对自我形象感兴趣，以及它与成功的关系，我建议您阅读Maxwell Maltz的Psycho-Cyber​​netics。 不要浪费你的努力每当学习变得困难时 - 就像你在学习基础知识后开始学习中间部分一样 - 你会发现自己正在探索其他不那么密切相关的编程领域。 如果你专注于Ruby，你会突然开始发现Swift如此迷人和精彩，而且非常神奇。 那么如何保持正轨，同时也不会对同一主题过于厌倦？ 如何练习：首先，提醒自己你的目标。接下来，我的建议与您可能认为的相反。我说 - 去那个短暂的蜜月与那个新的令人兴奋的主题！ 我建议您在接下来的几天里探索引起您兴趣的新亮点。没关系。 我用Ruby做过。我用Python做到了。然后，在那个喘息之后，我会提醒自己我的目标 - 寻找编码工作。我想：探索这个和那个会很好，但是我真的想在这一点上做得更好，所以我最好再一次关注它！我会以新发现的能量和热情回到学习JavaScript。 如果你不允许自己这样的呼吸怎么办？长时间研究一个主题就像节食一样。你会做得很好，很好，很开心，直到有一天你休息，再也不能接受它。比如说，你从一个完全不同的主题开始这个为期6个月的学习之旅，结果却发现你还没有掌握你尝试过的许多主题。 另外，值得深思：你从来没有听过“我用Ruby，JS，Python，C ++和Java编写代码，然后开始我成功的编码生涯”的故事。 为了开始，你应该至少有一件令人惊奇（或至少是好的）的东西。选择它，追求它，只允许自己短暂的转移，以保持你的理智。 数量一致性当我们决定采取大的东西，喜欢学习的代码，我们通常会令“新年决议”的思想下星期一我们会下班后每天花费3-4小时学习代码的错误。 接下来发生什么？我们做了两天，然后我们被邀请参加一个朋友家吃饭，错过了一天，感觉太可怕了，我们只开始了几天后再次编码或更多已通过 - 如果我们回到它。 我们需要明白，缓慢但更加一致的进步总会胜过跳过几天的人的进步，然后试图通过塞满一整天，或者拉一个全能者来弥补它。 每天学习15到30分钟比周末学习10个小时要好。你会记得更多 - 并且学得更快 - 如果你每天都回来，而不是你想要记住你一周前所做的事情。 我知道这是常识，但是当我们从更快地获得更好的愿望中获得灵感时，我们常常会忘记这一切。 如何练习：制定明确的“亮线”规则，每天至少编码30分钟。如果你能做得更多，那就去做吧。但是，如果你已经完成了30分钟的工作，那就给自己一个当天感觉完成的许可。 因此，您的努力将变得更加一致，您将更快地实现目标。 不要欺骗自己相信你必须回到大学或支付训练营才能成为开发者。事实并非如此是的，有很多人通过回到大学获得第二学位或参加面对面的训练营来进入软件开发。但猜猜是什么？通过独立学习，有更多的人进入这个领域。所以不要让自己忘记这一点。 如何练习：不要再担心这一点了，并且知道可以在没有做任何这些事情的情况下获得编码工作。 如果你可以获得学位或通过编码训练营，你可以考虑这样做。如果你做不到，不要让你沮丧一点。 此外，你花时间为自己感到难过的时间（我知道我已经做了很多），你可以花时间编写代码和学习。 好消息是对优秀的开发人员有很大的需求，并且有大量的免费资源。freeCodeCamp是一个很好的起点。 寻找志同道合的人好的，这可能与您在每篇关于此主题的文章中找到的建议相同，但它很有意义。去黑客马拉松和其他技术活动。 首先，您将了解更多人并了解他们的故事。它将帮助您了解人们采用的数百万条不同的路径将它们带到现在的位置。 其次，您将会询问您所有的问题，并希望能够帮助解决您正在处理的项目遇到的任何问题。 虽然这些技术活动对初学者知识水平的人来说似乎有些吓人，但不要担心感到愚蠢或者不理解任何事情。大多数这些活动都欢迎初学者。 是什么让我意识到编码事件的重要性如下。 2014年底，我找到了freeCodeCamp。它的发展还处于早期阶段。该网站有一个城市列表，其中有一群人聚在一起学习编码，称为露营地。它还有关于在您所在城市建立露营地的说明，如果它还没有。 那时多伦多没有一个。我喜欢组织东西，所以我想：“哇，这是个什么样的机会！”我很快就创造了一个。 我很惊讶地看到人们开始加入新营地的速度有多快！随着团队的成长，我决定创建我们的第一个活动。 今天我们正在接近六月份的“周年纪念”聚会，这真是令人惊叹。该小组现在有800多名成员，我很享受我们的每一次会议。 最后，有一种社区感，不仅是我学会分享我的经历，我还遇到了我能在任何地方找到的最好的人。那些有兴趣发展自己，变得更好，做新事物，学习，并且通常会从生活中获得更多生活的人！ 我认识的一些人是我真正的好朋友，我喜欢和他们以及参加活动的人分享资源，挑战和想法。 如何练习：去编码活动，例如Free Code Camp的咖啡和代码活动，其中的重点不仅是编码，还关注社区意识。 我不知道你住的地方有哪些活动，但我很确定你会在你所在城市的freeCodeCamp露营地找到当地的咖啡和代码活动。 如果还没有，你知道该怎么做。 阅读其他人的编码起源故事阅读其他人学习编码的方式既有信息又有动力。您可以快速了解他们的情况以及他们使用的资源。 我花了一两个月阅读这些，同时试图决定我应该开始学习哪种编程语言。一旦我决定专注于JavaScript，新的问题是我应该如何学习它。以后教自己和找工作是否现实？ 我会诚实地说，其中一些故事 - 人们花费3个月到昂贵的训练营并在之后找到工作 - 对我来说并不鼓舞人心。我有工作和其他责任，我无法参加。但是，如果您正在考虑训练营，这些故事可能会对您产生不同的影响。 尽管如此，我还是读过一些单亲父母学习编码的故事，以及使用freeCodeCamp，课程，EdX和其他资源自学和成功的人。它帮助我获得了成功的勇气和信心。 如何练习：阅读人们的故事，我保证你会受到启发，你的很多恐惧都会消失。 好吧，阅读够了，去写一些代码:) 如果您有任何关于学习编码的问题，这些问题会在您脑海中迸发出一个漏洞，那么请您离开 - 我非常乐意为您提供帮助！ 如果您喜欢这篇文章，请告诉我 - 这将是我的一天！ 如果您有兴趣，可以在Medium或Twitter上关注我：@ ka11away，我一定会写更多文章分享我的经历！ 非常感谢您的阅读！ Learning to Code: When It Gets Dark]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Soup</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F08%2F29%2Flearning%20to%20Code%2F</url>
    <content type="text"><![CDATA[学习编码：当它变暗一些有用的心灵技巧解决你最内心的恐惧 我们来谈谈如何保持正轨。当你觉得有太多东西需要学习时，如何继续学习。当你感觉自己从未获得第一个编码工作时，如何继续前进。 你发现自己在想：“也许我不是因为它而被切断了？” 这就像跟着你，模糊和歪曲事实云，因此它可以呈现的状况是多么糟糕无望如果那样的话，并和怎么也没有办法，你可以做到这一点。 嗯，我不知道你，但对我来说，这种情况每4-5天发生一次。 自2014年11月以来，我一直在学习编码，慢慢沉浸在这个领域。我使用了各种资源：书籍，在线课程，在线挑战，博客文章，教程等。freeCodeCamp对我的学习产生了很大的影响，通过对编码进行积极的转变，以及一条前进的明确路径。 在那段时间里，我经常不得不打击我的思想，吓跑我。我几乎可以肯定你也会经常遇到这种情况。 史蒂芬普莱斯菲尔德埃斯塔力在他的书艺之战有句名言被称为“抵抗”。我强烈建议你“读这本书。我发现自己每天都在使用它的课程（有些日子甚至是小时）。 在这篇文章中，我将分享一些心理技巧，用于消除消极性“云” - 抵抗 - 这可能是如此难以击败。所有的建议都是基于我到目前为止所学到的，如果你有其他想法 - 请在这里分享！ 我将跳过最常见的激励建议（通常过于宽泛而无法采取行动），并专注于不寻常但有效的建议。我已经使用了这些技术并发现它们有效，我希望你也会这样做。 意识到每个人都经历过抵抗在学习新技能时，许多人认为如果事情没有顺利进行，那就不适合他们。我们总是幻想在我们的如何，对某些人来说，一切都自然地流淌思想，只是他们迅速向前滑行所有的表面上，而不会遇到在他们的旅程的任何问题和障碍。 这不可能是事实。他们可能难以克服我们可能甚至不知道的事情。他们可能会被拒绝，失望，他们可能会感到绝望。我们不知道。不要以你想象的另一个人的旅程的标准判断自己。 当然，有一点可能会吃他们更容易，这可能是编码，但我向你保证，还有其他的10件事情，他们都希望自己能做得更多，但仍然轻松挣扎。 （为了让你了解这个抵抗力量有多强大：我在2015年12月开始写这篇文章。是的，我知道。） 如何练习：不要再考虑困难，因为围绕着你建造的这些墙壁让你不能去你想去的地方。将它们视为实现目标的障碍 - 让您变得更强大的挑战。 不要让自己相信你经历这些情感这一事实意味着你不会因为编程而被裁掉。每个人在尝试学习新的东西时都会遇到同样不舒服的情绪。推动你的界限和你所谓的“限制”（嘘没有勺子）是痛苦的。 你觉得什么是抵抗。 它很自然，如果你用它作为你的指南针它可以成为你的朋友。这是一个告诉你正走在正确道路上的标志，也是个人成长的道路。 每天都在计算当看到已经在技术领域的人时，很容易（相信我这一点）变得气馁。如果你专注于拥有数千名粉丝的开发人员以及对主题的大量了解，那就更容易让人气馁。 问题在于，这些是您在Twitter上看到的人，或者是谷歌搜索视频，教程和编码文章的结果。 您很少看到了解该领域98％左右的常规开发人员。 我并不是说你的目标应该是成为98％中的一员。 （你应该比这更进一步）。我要说的是，它很容易自己吓到，以为是有隐喻的大峡谷，你和专业的开发人员之间。 所以，你已经花了几个月的学习代码，但它好像你还是那么远从正反那你想知道：怎么可以这么遥遥领先他们？我有什么希望能够达到这个水平吗？ 嗯，这是你的思想在你身上耍花招的地方。你不看专业的小提琴家，并认为对自己说：“哦，我一直在学习，现在打了一年小提琴，为什么我不能望其项背在执行自己的水平？” 但是通过编码，我们中的许多人每次都这样做。 你认为一个你认为是一个可靠的开发人员的人会忽略那个人的其他一切。你想：“这很简单。他们是一个伟大的程序员，我不是。就是这样。“ 你不考虑如何可能有一个人与编程或数学奋斗和努力克服这些困难，或有可能下班后花了试图理解卡住的错误消息，并且担心同样的事情，你是无数个夜晚。或者他们如何在全日制大学学习软件开发方面花了4年时间。 没人说这很容易。学会做好事需要时间。很多时间。抵抗基本上告诉你，他们在那个级别怎么样，你不是？怎么了？应该很容易，必须有快速的方法，快捷方式，秘密，东西！ 提醒自己，没有什么东西是无用的东西。关键是你应该知道你有可能到达那里。需要时间，是的，但那又怎么样？所有有价值的事情都需要时间。 如何练习：这是我学习编码和技术的主要难题之一。如果没有这个，我可能已经放弃了编码，就像我放弃了多年来我试图学习的许多其他东西。 在这里，它是：想象有多少人摆脱了那些已经开始了大致相同的一天编码上像你一样已经停止 - 或将退出今天 - 在同一诱惑让步停止的痛苦和学习的不适。 想想你在旅程中发展的力量（心理，情感）。每当你做出更进一步的决定时，你的意志和韧性就会增加，不要停留在你的位置，不要承认失败。您每天编码都是您赢得的那一天。 全力以赴因此，您已决定自学编码。什么阻止你在6个月没有看到你想看到的结果后退出？ 你需要一个目标来努力。一旦你的目标，这将是难以停止，而不是一个情况涉足如果您正在使用的代码，或不特定的，定义明确的目标，学习。 我最初的目标是找到一份编码工作。这花了我大约14个月的时间。我在当时的营销全职工作，所以整天晚上我无法代码，但我试图在尽可能多的时间去挤，因为我可以编码到每一天。 明确目标的另一个好处是，您可以更轻松地在想要学习的主题之间进行选择。我相信这将是主要的JavaScript技术我在在职使用，所以它更容易说不改道成Python，Ruby和其他语言。 重点关注你的努力。如果它们看起来像风玫瑰，将单个光线带入中心，您就会变成激光。你知道激光器的效果如何。有时，我们都需要收集试图向四面八方传播的光线，并将其重点放在我们的目标上。 一旦你决定了你的目标，全力以赴。花费尽可能多的时间来编码。 谁在乎您是否有所有日子或每天只有1小时？如果你没有它，你有多少时间或没有多少都没关系。 我读过的人照顾小孩和学习的代码时，他们有片刻的故事，但我没有看到的“一个故事，我怎么有我的天免费一年，我还是没能学会编码“。你知道为什么吗？这些人没有故事可讲。 使用您“不知道你有时间：在编码下载有声读物，听它，得到一本书，读它在地铁或公共汽车，如果你上班地点或其他地方。尝试使用多种类型的学习，但请确保您遵守相同的主题。 不要过头，成为气馁 - 如果你觉得你不能拿的JavaScript或Python（或任何其他受你关注）了，一天的休息放松，做别的事情。 我想传达的概念是，如果你担心你没有足够的时间去学习的代码，这可能只是你的担心是骗你的。这发生在我身上 - 我常常会想：它需要多长时间我学习ESTA而全职工作？我有没有机会坚持到底？ 请记住，你今天付出的努力越多（不打算明天投入），你到达那里的速度就越快。 如何练习：确定一个具体，切合实际的目标。一个定义明确的目标将是：“我想找到一份工作，前端Web开发的未来12个月内”或者说：‘我将创建3个单独的iOS应用在接下来的8个月里。’ 尽可能使用，并将所有精力集中在学习编码上。为什么呢？因为它是不容易的，时间越长你传播因为你的学习时间（除非你有具体时限的目标），你就越有可能会成为的“进展缓慢”的感觉气馁。 你足够聪明。我开始学习之旅时的另一个大恐惧是，我不够聪明，无法比较那些花时间解决数学，物理和编程问题的人。他们在3岁时开始编程，并在5岁时构建编译器。 我误以为编程中的每个人都是拥有博士学位的工程师。来自常春藤联盟大学，对我来说已经太晚了。 首先，我已经知道科技行业中有这么多人，他们有不同的编码途径。所以我可以开始相对较晚。 其次，更重要的是，我仍然担心“如果我不能在那里获得最好的软件工程工作怎么办？”就像Google和Facebook一样。起初我可能不会，但我会全力以赴达到这个水平。 我确信的事情是 - 如果一个人长时间保持编码并使练习刻意 - 他们将达到他们渴望的任何水平。 通过刻意练习，我的意思是： 检查代码中的错误和问题回到某些问题并试图以更好的方式解决它们阅读其他人的代码，看看他们是如何解决这些问题的重构你的旧代码简单地说：做返工而不是尝试新事物并一直切换主题。 如何练习：相信我，你足够聪明。相信你是，并且不要让“我不够好”的想法溜进来。它们本质上具有破坏性。 我将与您分享一个肯定，我不在乎您对肯定的看法： “我配得上生活中最好的一面，我可以做任何我梦寐以求的事情！” 如果你发现自己害怕自己不够聪明，那就重复一下这个肯定。每当恐惧得到你的想法，或者你需要的那一天多次，你可能想要重复它5次。你的思维就像粘土一样，你的工作就是训练它并将它塑造成你的朋友。 看看我们我们和你一样。所有人都渴望编码并变得更好。我们都有同样的恐惧。 如果你将它作为一个专业的开发人员，最终的因素不是你的智商或你的“代码才能”，而是你的弹性和勇气。 有一座山 - 珠穆朗玛峰，更高的机会，你会不会做它，你会吓跑你自己，因为出来的成功，而不是不被其他一些人一样聪明（你的项目或人在谁在你的心中非凡的光彩）。 如果您对自我形象感兴趣，以及它与成功的关系，我建议您阅读Maxwell Maltz的Psycho-Cyber​​netics。 不要浪费你的努力每当学习变得困难时 - 就像你在学习基础知识后开始学习中间部分一样 - 你会发现自己正在探索其他不那么密切相关的编程领域。 如果你专注于Ruby，你会突然开始发现Swift如此迷人和精彩，而且非常神奇。 那么如何保持正轨，同时也不会对同一主题过于厌倦？ 如何练习：首先，提醒自己你的目标。接下来，我的建议与您可能认为的相反。我说 - 去那个短暂的蜜月与那个新的令人兴奋的主题！ 我建议您在接下来的几天里探索引起您兴趣的新亮点。没关系。 我用Ruby做过。我用Python做到了。然后，在那个喘息之后，我会提醒自己我的目标 - 寻找编码工作。我想：探索这个和那个会很好，但是我真的想在这一点上做得更好，所以我最好再一次关注它！我会以新发现的能量和热情回到学习JavaScript。 如果你不允许自己这样的呼吸怎么办？长时间研究一个主题就像节食一样。你会做得很好，很好，很开心，直到有一天你休息，再也不能接受它。比如说，你从一个完全不同的主题开始这个为期6个月的学习之旅，结果却发现你还没有掌握你尝试过的许多主题。 另外，值得深思：你从来没有听过“我用Ruby，JS，Python，C ++和Java编写代码，然后开始我成功的编码生涯”的故事。 为了开始，你应该至少有一件令人惊奇（或至少是好的）的东西。选择它，追求它，只允许自己短暂的转移，以保持你的理智。 数量一致性当我们决定采取大的东西，喜欢学习的代码，我们通常会令“新年决议”的思想下星期一我们会下班后每天花费3-4小时学习代码的错误。 接下来发生什么？我们做了两天，然后我们被邀请参加一个朋友家吃饭，错过了一天，感觉太可怕了，我们只开始了几天后再次编码或更多已通过 - 如果我们回到它。 我们需要明白，缓慢但更加一致的进步总会胜过跳过几天的人的进步，然后试图通过塞满一整天，或者拉一个全能者来弥补它。 每天学习15到30分钟比周末学习10个小时要好。你会记得更多 - 并且学得更快 - 如果你每天都回来，而不是你想要记住你一周前所做的事情。 我知道这是常识，但是当我们从更快地获得更好的愿望中获得灵感时，我们常常会忘记这一切。 如何练习：制定明确的“亮线”规则，每天至少编码30分钟。如果你能做得更多，那就去做吧。但是，如果你已经完成了30分钟的工作，那就给自己一个当天感觉完成的许可。 因此，您的努力将变得更加一致，您将更快地实现目标。 不要欺骗自己相信你必须回到大学或支付训练营才能成为开发者。事实并非如此是的，有很多人通过回到大学获得第二学位或参加面对面的训练营来进入软件开发。但猜猜是什么？通过独立学习，有更多的人进入这个领域。所以不要让自己忘记这一点。 如何练习：不要再担心这一点了，并且知道可以在没有做任何这些事情的情况下获得编码工作。 如果你可以获得学位或通过编码训练营，你可以考虑这样做。如果你做不到，不要让你沮丧一点。 此外，你花时间为自己感到难过的时间（我知道我已经做了很多），你可以花时间编写代码和学习。 好消息是对优秀的开发人员有很大的需求，并且有大量的免费资源。freeCodeCamp是一个很好的起点。 寻找志同道合的人好的，这可能与您在每篇关于此主题的文章中找到的建议相同，但它很有意义。去黑客马拉松和其他技术活动。 首先，您将了解更多人并了解他们的故事。它将帮助您了解人们采用的数百万条不同的路径将它们带到现在的位置。 其次，您将会询问您所有的问题，并希望能够帮助解决您正在处理的项目遇到的任何问题。 虽然这些技术活动对初学者知识水平的人来说似乎有些吓人，但不要担心感到愚蠢或者不理解任何事情。大多数这些活动都欢迎初学者。 是什么让我意识到编码事件的重要性如下。 2014年底，我找到了freeCodeCamp。它的发展还处于早期阶段。该网站有一个城市列表，其中有一群人聚在一起学习编码，称为露营地。它还有关于在您所在城市建立露营地的说明，如果它还没有。 那时多伦多没有一个。我喜欢组织东西，所以我想：“哇，这是个什么样的机会！”我很快就创造了一个。 我很惊讶地看到人们开始加入新营地的速度有多快！随着团队的成长，我决定创建我们的第一个活动。 今天我们正在接近六月份的“周年纪念”聚会，这真是令人惊叹。该小组现在有800多名成员，我很享受我们的每一次会议。 最后，有一种社区感，不仅是我学会分享我的经历，我还遇到了我能在任何地方找到的最好的人。那些有兴趣发展自己，变得更好，做新事物，学习，并且通常会从生活中获得更多生活的人！ 我认识的一些人是我真正的好朋友，我喜欢和他们以及参加活动的人分享资源，挑战和想法。 如何练习：去编码活动，例如Free Code Camp的咖啡和代码活动，其中的重点不仅是编码，还关注社区意识。 我不知道你住的地方有哪些活动，但我很确定你会在你所在城市的freeCodeCamp露营地找到当地的咖啡和代码活动。 如果还没有，你知道该怎么做。 阅读其他人的编码起源故事阅读其他人学习编码的方式既有信息又有动力。您可以快速了解他们的情况以及他们使用的资源。 我花了一两个月阅读这些，同时试图决定我应该开始学习哪种编程语言。一旦我决定专注于JavaScript，新的问题是我应该如何学习它。以后教自己和找工作是否现实？ 我会诚实地说，其中一些故事 - 人们花费3个月到昂贵的训练营并在之后找到工作 - 对我来说并不鼓舞人心。我有工作和其他责任，我无法参加。但是，如果您正在考虑训练营，这些故事可能会对您产生不同的影响。 尽管如此，我还是读过一些单亲父母学习编码的故事，以及使用freeCodeCamp，课程，EdX和其他资源自学和成功的人。它帮助我获得了成功的勇气和信心。 如何练习：阅读人们的故事，我保证你会受到启发，你的很多恐惧都会消失。 好吧，阅读够了，去写一些代码:) 如果您有任何关于学习编码的问题，这些问题会在您脑海中迸发出一个漏洞，那么请您离开 - 我非常乐意为您提供帮助！ 如果您喜欢这篇文章，请告诉我 - 这将是我的一天！ 如果您有兴趣，可以在Medium或Twitter上关注我：@ ka11away，我一定会写更多文章分享我的经历！ 非常感谢您的阅读！]]></content>
  </entry>
  <entry>
    <title><![CDATA[GitPage+Hexo搭建个人博客及Next主题配置]]></title>
    <url>%2F2018%2F08%2F29%2FGitPage-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%8ANext%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[GitPage+Hexo搭建个人博客及Next主题配置GitPage搭建Hexo个人博客Next主题配置其他配置参考]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker入门]]></title>
    <url>%2F2018%2F08%2F27%2FDocker%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 Docker入门初识Docker什么是DockerDocker开源项目Docker是基于Go语言实现的云开源项目，诞生于2013年初，最初发起者为dotCloud公司。Docker项目目前已加入Linux基金会，遵循Apache2.0协议，全部开源代码均在https://github.com/docker/docker上进行维护。 Docker的主要目标是”Build,ship and Run Any App,Anywhere“，即通过对应用组件的封装、分发、部署、运行等生命周期的管理，达到应用级别的”一次封装，到处运行“。这里的应用组件，可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统或编译器。 Linux容器技术Docker引擎的基础是Linux容器(Linux Containers,LXC)技术（容器有效第将由单个操作系统管理的资源划分到孤立的组中，以便更好第在孤立的组之间平衡有冲突的资源使用需求。与虚拟化相比，这样既不需要指令级模拟，也不需要即时编译。容器可以在核心CPU本地运行指令，儿不需要任何专门的解释机制。此外，也避免了准虚拟化和系统调用替换中的复杂性。） 从Linux容器到Docker在Linux容器的基础上，Docker进一步优化了容器的使用体验。Docker提供了各种容器管理工具（如分发、版本、移植等)让用户无需关注底层的操作，可以简单明了地管理和使用容器。 可以简单地将Docker容器理解为一种沙盒。每个容器内运行一个应用，不同的容器相互隔离，容器之间也可以建立通信机制。容器的创建和停止都十分快速，容器自身对资源的需求也十分有限，远远低于虚拟机。很多时候，甚至直接把容器当作应用本身也没有任何问题。 为什么使用DockeDocker容器虚拟化的好处高效地构建应用 Docker在开发和运维中的优势 更快的交付和部署。使用Docker，开发人员可以使用镜像来快速构建一套标准的开发环境；测试和运维人员可以直接使用相同的开发环境来部署代码。Docker可以快速创建和删除容器，实现快速迭代，大量节约开发、测试、部署的时间。并且各个步骤都有明确的配置和操作，整个过程全程课件，使团队更容易理解应用的创建和工作过程。 更高效的资源利用。Docker容器的运行不需要额外的虚拟化管理程序支持，它是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低。 更轻松的迁移和扩展。Docker容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 更简单的更新管理。使用Dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作。并且所有修改都可以以增量的方式进行分发和更新，从而实现自动化并且高效的容器管理。 Dcoker与虚拟机比较 Docker容器很快，启动和停止可以在秒级实现。 Docker容器对系统资源需求很少，一台主机可以同时运行数千个Docker容器。 Docker通过类似Git的操作来方便用户获取、分发和更新应用镜像，指令简明，学习成本较低。 Docker通过Dockerfile配置文件来支持灵活的自动化创建和部署机制，提高工作效率。 特性 容器 虚拟机 启动速度 秒级 分钟级 硬盘使用 一般为MB 一般为GB 性能 接近原生 弱于 系统支持量 单机支持上千个容器 一般几十个 隔离性 安全隔离 完全隔离 虚拟化与Docker在计算领域，一般指的是计算虚拟化，或通常说的服务器虚拟化。（维基百科：在计算机技术中，虚拟化是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以用比原本的组态更好的方式来应用这些资源。） 虚拟化技术分类 基于硬件的虚拟化（不常见） 基于软件的虚拟化 应用虚拟化 平台虚拟化 完全虚拟化。虚拟机模拟完整的底层硬件环境和特权指令的执行过程，客户操作系统无需进行修改。 硬件辅助虚拟化：利用硬件辅助支持处理敏感指令来实现完全虚拟化的功能，客户操作系统无需进行修改。 部分虚拟化：只针对部分硬件资源进行虚拟化，客户操作系统需要进行修改。 超虚拟化：部分硬件接口以软件的形式提供给客户机操作系统，客户操作系统需要进行修改。 操作系统及虚拟化：内核通过创建多个虚拟的操作系统实例来隔离不同的进行。容器相关技术属于这个范畴。 Docker和传统虚拟机方式的不同之处 Docker的核心概念和安装 三大核心概念：镜像、容器、仓库 核心概念Docker镜像Docker镜像类似于虚拟机镜像，可以理解为一个面向Docker引擎的只读模板，包含了文件系统。 镜像是创建Docker容器的基础。通过版本管理和增量的文件系统，Docker提供了一套简单的机制来创建和更新现有的镜像，用户设置可以从网上下载一个已经做好的应用镜像，并通过简单的命令就可以直接使用。 Docker容器Docker容器类似于一个轻量级的沙箱，Docker利用容器来运行和隔离应用。容器是从镜像创建的应用运行实例，可以将其启动、开始、停止、删除，而这些容器都是互相隔离、不可见的。 容器可以看做一个简易版的Linux系统环境（包括root用户权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序打包成应用盒子。 镜像自身是只读的。容器从镜像启动的时候，Docker会在镜像的最上层创建一个可写层，镜像本身保持不变。 Docker仓库注册服务器是存放仓库的地方，不能将Docker仓库和注册服务器(Registry)混为一谈。 Docker仓库类似于代码仓库，是Docker集中存放镜像文件的场所。每个仓库放着某一类镜像，往往包括多个镜像文件，通过不同的标签(tag)来区分。根据所存储的镜像公开与否，Docker仓库可以分为公开仓库和私有仓库两种形式。目前最大的公开仓库是Docker Hub，存放了数量庞大的镜像供用户下载。国内的公开仓库包括Docker Pool等，可以提供稳定的国内访问。Docker也支持用户在本地网络创建一个只能自己访问的私有仓库。 安装Docker Ubuntu CentOS Windows Mac OS 1brew install docker 镜像 镜像是Docker的三大核心概念之一。Docker运行容器前需要本地存在对应的镜像，如果镜像不存在本地，Docker会尝试先从默认镜像仓库下载，用户也可以通过配置，使用自定义的镜像仓库。 获取镜像镜像是Docker运行容器的前提。使用docker pull命令从网络上下载镜像。 1docker pull NAME[:TAG] 若不显式地指定TAG，则默认会选择latest标签，即下载仓库的最新版本的镜像。 12345678910111213docker pull ubuntu# 指定TAGdocker pull ubuntu:14.04# 已下载Using default tag: latestlatest: Pulling from library/ubuntuc64513b74145: Already exists01b8b12bad90: Already existsc5d85cf7a05f: Already existsb6b268720157: Already existse12192999ff1: Already existsDigest: sha256:aade50db36e1ed96716662cfe748789e154c213a711931c66746c42ce34aa296Status: Downloaded newer image for ubuntu:latest 下载过程可以看出，镜像文件一般由若干层组成，行首的c64513b74145代表了各层的ID。下载过程中会获取病输出镜像的各层信息。层其实是AUFS(Advanced Union File System，一种联合文件系统)中的重要概念，是实现增量保存与更新的基础。 两条安装命令相当于：docker pull registry.hub.docker.com/ubuntu:latest，即从默认的注册服务器registry.hub.docker.com中的ubuntu仓库下载标记为latest的镜像。 指定完整的仓库注册服务器地址。例如从DockerPool社区的镜像源下载 1docker pull dl.dockerpool.com:5000/ubuntu 使用镜像创建容器并运行bash应用 1docker run -t -i ubuntu /bin/bash 查看镜像信息1234# 列出本地主机上已有的镜像docker images# 来源仓库 标签 镜像的ID号 创建时间 大小# REPOSITORY TAG IMAGE ID CREATED SIZE TAG信息用来标记来自同一个仓库的不同镜像。仓库中有多个镜像，通过TAG信息来区分发行版本。 12# 使用docker tag为本地镜像添加新的标签docker tag dl.dockerpool.com:5000/ubuntu:latest ubuntu:latest 不同标签的镜像的ID完全一致的，说明它们实际上指向了同一个镜像文件，只是别名不同。标签起到了引用或快捷方式的作用。 docker inspect可以获取镜像的详细信息，docker inspect命令返回的是一个JSON格式的消息，若只要其中一项内容，可以使用-f参数指定。 1234docker inspect 2cb0d9787c4d# 指定镜像ID时，通常使用该ID的前若干个字符组成的可区分字串来替代完整IDdocker inspect -f &#123;&#123;".Architecture"&#125;&#125; 550 搜寻镜像使用docker search命令可以搜索远端仓库中的共享的镜像，默认搜索Docker Hub官方仓库中的镜像。 支持的参数： –automated=false 仅显示自动创建的镜像 –no-trunc=false 输出信息不截断显示 -s,–starts=0 指定仅显示评价为指定星级以上的镜像 删除镜像使用docker rmi可以删除镜像 1234# IMAGE可以为标签或IDdocker rmi IMAGE# -f 参数强制执行docker rmi -f ubuntu 当一个镜像拥有多个标签时，docker rmi只是删除了该镜像多个标签中的指定标签而已，并不影响镜像文件。但当只剩下一个标签时，执行docker rmi命令会删除这个镜像文件的所有AUFS层。 当使用docker rmi命令后面跟上镜像ID(也可以是ID能进行区分的部分前缀串)时，会先尝试删除所有指定该镜像的标签，然后删除镜像文件本身。 当有镜像创建的容器存在时，镜像文件默认是无法被删除的1234# 删除依赖该镜像的所有容器docker rm ubuntu# 然后再删除镜像docker rmi ubuntu 创建镜像 三种方法：基于已有镜像的容器创建、基于本地模板导入、基于Dockerfile创建 基于已有镜像的容器创建使用docker commit命令，格式： 1docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] 主要选项包括： -a，–author=””作者信息 -m，–message=””提交信息 -p，–pause=true提交时暂停容器运行 123456789101112# 演示docker run -ti ubuntu /bin/bashroot@32fe63d85c53:/# touch testroot@32fe63d85c53:/# exitdocker commit -m "add a new file " 32fe63d85c53 testsha256:4ff6ec596961a2c5f25bcd31e912abd40cc108b7e7e35d53d239b1ef4ff13233# 使用docker images查看本地镜像列表docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtest latest 4ff6ec596961 6 seconds ago 83.5MB 基于本地模板导入使用OpenVZ提供的模板创建。OPENVZ模板的下载地址为https://download.openvz.org/template/precreated/导入命令 1cat ubuntu-14.04-x86_64-minimal.tar.gz | docker import - ubuntu:14.04 存出和载入镜像可以使用docker save和docker load命令来存出和载入镜像 存出镜像1docker save -o ubuntu_14.04.tar ubuntu:14.04 载入镜像123docker load --input ubuntu_14.04.tardocker load &lt; ubuntu_14.04.tar 上传镜像使用docker push命令上传镜像到仓库，默认上传到DockerHub官方仓库（需要登录），命令格式为docker push NAME[:NAME]，第一次使用时，会提示输入登录信息或进行注册。 容器 容器时Docker的另一个核心概念，容器就是镜像的一个运行实例，不同的是，它带有额外的可写文件层。 创建容器新建容器使用docker create命令新建一个容器 1234docker create -it ubuntu:latestfb461fbaa2ffe5ebab82548feb5898a1b35b7a3d678b52e1085d94db0f08c6e5docker ps -afb461fbaa2ff ubuntu:latest "/bin/bash" 23 seconds ago Up 5 seconds heuristic_lamport 使用docker create新建的容器处于停止状态，可以使用docker start启动。 新建并启动容器启动容器的方式有两种 基于镜像新建一个容器并启动 将在终止状态的容器重新启动 docker run = docker create + docker start 12# 使用如下命令输出一个‘hello world’，之后容器自动终止docker run ubuntu /bin/echo 'hello world' 当利用docker run创建并启动容器时，Docker在后台运行的标准操作： 检查本地是否存在指定的镜像，不存在就从共有仓库下载。 利用镜像创建并启动一个容器。 分配一个文件系统，并在只读的镜像层外挂载一层可读写层。 从宿主主机配置的网桥接口中桥接一个虚拟接口道容器中去。 从地址池配置一个IP地址给容器。 执行用户指定的应用程序。 执行完毕后容器被终止。 下面命令启动一个bash终端，允许用户进行交互 1docker run -t -i ubuntu:latest /bin/bash -t：让Docker分配一个伪终端并绑定到容器的标准输出上-i：让容器的标准输入保持打开 12345678910111213docker run -ti ubuntu /bin/bashroot@d3df425445cf:/# lsbin dev home lib64 mnt proc run srv tmp varboot etc lib media opt root sbin sys usrroot@d3df425445cf:/# pwd/root@d3df425445cf:/# ps PID TTY TIME CMD 1 pts/0 00:00:00 bash 11 pts/0 00:00:00 psroot@d3df425445cf:/# exitexit# 使用exit退出后，容器自动处于终止状态 守护态运行-d参数可以让Docker容器在后台以守护态形式运行 12345678➜ ~ docker run -d ubuntu /bin/bash -c "while true;do echo hello world;sleep 1;done"9c9db4515c703021cd2fc3e4583291cb62007ecafa28709f898cf2183eb914c1➜ ~ docker logs 9c9db4515c703hello worldhello world➜ ~ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES9c9db4515c70 ubuntu "/bin/bash -c 'while…" 41 seconds ago Up 40 seconds elastic_brattain 终止容器docker stop可以用来终止一个运行中的容器，命令格式docker stop [-t|--time[=10]]它会首先向容器发送SIGTERM信号，等待一段时间后（默认为10s），再发送SIGKILL信号终止容器，当Docker容器中指定的应用终结时，容器也自动终止。 处于终止状态的容器，可以通过docker start重新启动 docker restart可以重启一个运行中的容器。 进入容器attach命令123456789➜ ~ docker run -idt ubuntua9e625b70f57ec70c242e5baf5c9a4431515e0e4d239b81a4729fcc4c08a0eef➜ ~ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESa9e625b70f57 ubuntu "/bin/bash" 5 seconds ago Up 4 seconds hungry_brown➜ ~ docker attach hungry_brownroot@a9e625b70f57:/# lsbin dev home lib64 mnt proc run srv tmp varboot etc lib media opt root sbin sys usr 但是使用attach命令有时候并不方便。当多个窗口同时attach到同一个容器时，所有的窗口都会同步显示。当某个命令因命令阻塞时，其他窗口也无法执行操作。 exec命令Docker自1.3版本起，提供了exec工具，可以直接在容器内运行命令。 1docker exec -ti a9e625 /bin/bash nsenter工具nsenter工具在util-linux包2.33版本后包含。 删除容器docker rm可以删除处于终止状态的容器，命令格式为docker rm [OPTION] CONTAINER [CONTAINER...]支持的选项包括： -f，–force=false强行终止并删除一个运行中的容器 -l，–link=false删除容器的连接，但保留容器 -v，–volume=false删除容器挂载的数据卷 导入和导出容器导出容器导出容器是指导出一个已经创建的容器到一个文件，不管此时这个容器是否处于运行状态，可以使用docker export命令，命令格式为docker export CONTAINER。 1docker export ce4 &gt; test_for_run.tar 导入容器docker import可以导入文件成为镜像 1cat test_for_run.tar | docker import - test/ubuntu:v1.0 与docker load的区别：docker load命令导入镜像存储文件到本地的镜像库docker import命令导入一个容器快照到本地镜像库容器快照文件将丢弃所有的历史记录和元数据信息（仅保留容器当时的快照状态），而镜像存储文件保留完整记录，体积也更大。此外，从容器快照文件导入可以重新指定标签等元数据信息。 仓库 仓库是集中存放镜像的地方，注册服务器是存放仓库的具体服务器，每个服务器上可以有多个仓库，每个仓库下面有多个镜像。仓库地址dl.dockerpool.com/ubuntu，dl.dockerpool.com是注册服务器，ubuntu是仓库名。 Docker Hub基础操作 docker pull 下载镜像到本地 docker search 搜索公共仓库镜像 docker push 将本地奖项推动到Docker Hub 镜像资源分为两类 类似ubuntu这样的基础镜像，成为基础或根镜像。这些镜像由Docker公司创建、验证、支持、提供，这样的镜像往往使用单个单词作为名字 类似user/ubuntu这样的镜像，它是由DockerHub的用户user闯将并维护的，带有用户名称前缀， 查找时可以通过-s N参数指定仅显示评价为N星以上的镜像。 自动创建自动创建使用户通过Docker Hub指定跟踪一个目标网站（目前支持GitHub或BitBucket）上的项目，一旦项目发现新的提交，则自动执行创建。步骤： 创建并登陆Docker Hub，以及目标网站；*在目标网站中连接账户到Docker Hub 在Docker Hub中配置一个自动创建 选取一个目标网站中的项目（需要含Dockerfile）和分支 指定Dockerfile的位置，并提交创建。 之后可以在Docker Hub的“自动创建”页面中跟踪每次创建的动态。 创建和使用私有仓库使用registry镜像创建私有仓库通过官方的registry镜像简单搭建一套本地私有仓库环境： 1docker run -d -p 5000:5000 registry 数据管理 用户在使用Docker的过程中，需要能查看容器内应用产生的数据，或者需要把容器内的数据进行备份，甚至多个容器之间进行数据共享，必然涉及到容器内的数据管理操作。容器中管理数据的方式主要有两种方式：1.数据卷 2.数据卷容器 数据卷数据卷是一个可供容器使用的特殊目录，它绕过文件系统，提供很多有用的特性： 数据卷可以在容器之间共享和重用 对数据卷的修改会立马生效 对数据卷的更新，不会影响镜像 卷会一致存在，知道没有容器使用 数据卷的使用用，类似于Linux下对目录或文件进行mmount操作。 在容器内创建一个数据卷使用docker run命令的时候，使用-v编辑可以在容器内创建一个数据卷。多次会用-v标记可以创建多个数据卷。 使用training/webapp镜像创建一个Web容器，并创建一个数据卷挂载到容器的/web目录： 1docker run -d -P --name web -v /webapp training/webapp python app.py -P是允许外部访问容器需要暴露的端口 挂载一个本地主机文件作为数据卷-v标记也可以从主机上挂载单个文件到容器中作为数据卷： 1docker run --rm -it -v ~/.zshrc ubuntu /bin/bash 网络基础配置端口映射实现访问从外部访问容器应用可以通过-P或-p参数来指定端口映射。当使用-P标记时，Docker会随机映射一个49000~49900的端口至容器内部开放的网络端口。-p则可以指定要映射的端口，并且在一个指定端口上只可以绑定一个容器。支持的格式有：ip:hostport:containerPort | ip::containerPort | hostPort:containerPort 123docker run -d -P training/webapp python app.pydocker ps -ld5c545dc020f training/webapp "python app.py" 7 seconds ago Up 6 seconds 0.0.0.0:32774-&gt;5000/tcp infallible_varahamihira 映射所有的接口地址将本地的5000端口映射到容器的5000端口 1docker run -d -p 5000:5000 training/webapp python app.py 亦可以多次使用-p标记绑定多个端口 1docker run -d -p 5000:5000 -p 3000:80 training/webapp python app.py 映射到指定地址的指定端口1docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py 映射到指定地址的任意端口使用ip::containerPort绑定localhost的任意端口到容器的5000端口，本地主机会自动分配一个端口： 123docker run -d -p 127.0.0.1::5000 training/webapp python app.py# 使用ud标记来指定udp端口docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py 查看映射端口配置使用docker port查看当前映射的端口配置，也可以查看到绑定的地址 1docker port DOCKERNAME containerPort 容器有自己的内部网络和IP地址(docker inspert + 容器ID可以获取所有的变量值)。 容器互联实现容器间通信 容器的连接系统是除了端口映射外另一种可以与容器中应用进行交互的方式。它会在源和接收容器之间创建一个隧道，接收容器可以看到源容器指定的信息。 连接系统根据容器的名称来执行，因此需要先自定义一个好记的容器命名。使用--name标记可以为容器自定义命名 1docker run -d -P --name web training/webapp python app.py 八、使用Dockerfile创建镜像 Dockerfile是一个文本格式的配置文件，用户可以使用Dockerfile快速创建自定义的镜像。 基本结构Docker由一行行命令语句组成，并且支持以#开头的注释行。一般分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动执行指令。 123456789101112131415161718# This dockerfile uses the ubuntu image# VERSION 2 - EDITION 1# Author:docker_user# Command format: Instruction [arguments / command]...# 第一行必须指定基于的基础镜像From ubuntu# 维护者信息MAINTAINER entercoder entercoder1993@gmail.com# 镜像的操作指令RUN echo "deb http://archive.ubuntu.com/ubuntu/ raring main universe" &gt;&gt; /etc/apt/sources.listRUN apt-get update &amp;&amp; apt-get install -y nginxRun echo "\nadaemon off;;" &gt;&gt; /etc/nginx/nginx.conf# 容器启动时执行指令CMD /usr/sbin/nginx Example1 1234From ubuntuMAINTAINER entercoder entercoder1993@gmail.comRUN apt-get update &amp;&amp; apt-get install -y inotify-tools nginx apache2 openssh-server% Example2 基于ubuntu，安装firfox和vnc软件，启动后，用户可以通过5900端口通过vnc方式使用firefox 123456789FROM ubuntuRUN apt-get update &amp;&amp; apt-get install -y xllvnc xvfb firefoxRUN mkdir /.vncRUN xllvnc -storepasswd 1234 ~/.vnc/passwdRUN bash -c 'echo "firefox" &gt;&gt; /.bashrc'EXPOSE 5900CMD ["xllvnc,"-forever","-usepw","-create"] 指令指令的一般格式为INSTRUCTION arguments，指令包括FROM、MAINTAINER、RUN等 FROM第一条必须为FROM指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个FROM指令。格式：FROM &lt;image&gt;或FROM &lt;image&gt;:&lt;tag&gt; MAINTAINER指定维护者的信息格式：MAINTAINER &lt;name&gt; RUN在shell终端中运行命令，即/bin/sh -c格式：RUN &lt;command&gt;使用exec执行命令，指定其他终端可以用这种方式实现格式：RUN [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello&quot;]每条RUN指令将在当前镜像基础上执行指定命令，并提交为新的镜像。当命令较长时可以用\来换行。 CMD支持三种形式 CMD [”executable&quot;,&quot;param1&quot;,&quot;param2&quot;]使用exec执行，推荐方式 CMD command param1 param2在/bin/bash中执行， CMD [&quot;param1&quot;,&quot;param2&quot;]提供给ENTRYPOINT的默认参数 指定启动容器时执行的命令，每个Dockerfile只能有一条CMD命令。如果指定了多条命令，只有最后一条会被执行。如果用户启动容器时制定了运行的命令，则会覆盖掉CMD指定的命令。 EXPOSE告诉Docker服务端容器暴露的端口号，供互联网使用。在启动容器时需要通过-P，Docker主机会自动分配一个端口转发到指定的端口；使用-p，则可以指定哪个本地端口映射过来。格式：EXPOSE &lt;port&gt; [&lt;port&gt;...] ENV指定一个环境变量，会被后续RUN指令使用，并在容器运行时保持。格式：ENV &lt;key&gt; &lt;value&gt;1234ENV PG_MAJOR 9.3ENV PG_VERSIOIN 9.3.4RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; ...ENV PATH /usr/local/postgress-$PG_MAJOR/bin:$PATH ADD将复制指定的&lt;src&gt;到容器中的&lt;dest&gt;。其中&lt;src&gt;可以是Dockerfile所在目录的一个相对露冷静(文件或目录)；也可以是一个URL；还可以是一个tar文件(自动解压为目录)。格式：ADD &lt;src&gt; &lt;dest&gt; COPY复制指定的&lt;src&gt;(为Dockerfile所在目录的相对路径，文件或目录)为容器中的&lt;dest&gt;。目标路径不存在，会自动创建。使用本地目录为源目录时，推荐使用COPY格式：COPY &lt;src&gt; &lt;dest&gt; ENTRYPOINT配置容器启动后执行的命令，并且不可被docker run提供的参数覆盖。每个Dockerfile中只能有一个ENTRYPOINT，当指定多个ENTRYPOINT时，只有最后一个生效。格式：ENTRYPOINT [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]ENTRYPOINT command param1 param2(shell中执行) VOLUME创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。格式：VOLUME [&quot;/data&quot;] USER指定运行容器时的用户名或UID，后续的RUN也会使用指定用户。当服务不需要管理员权限时，可以通过该命令指定运行用户，并且可以在之前创建所需要的用户，例如：RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres。要临时获取管理员权限可以使用gosu，而不推荐sudo。格式：USER daemon WORKDIR为后续的RUN、CMD、ENTRYPOINT指令配置工作目录。可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。格式：WORKDIR /path/to/workdir 12345WORDDIR /aWORKDIR bWORKDIR cRUN pwd# 则最终路径为/a/b/c ONBUILD配置当所创建的镜像作为其他新创建镜像的基础镜像时所操作的指令。格式：ONBUILD [INSTRUCTION] Dockerfile创建镜像编写完成Dockerfile后，通过docker build命令来创建镜像。格式：docker build [option] path该命令将读取指定路径下(包括子目录)的Dockerfile，并将该路径下所有内容发给Docker服务端，由服务端来创建镜像。因此一般建议放置Dockerfile的目录为空目录。 通过.dockerignore文件(每行添加一条匹配模式)来让Docker忽略路径下的目录和文件。 通过-t选项可以指定镜像的标签信息。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络爬虫与信息提取]]></title>
    <url>%2F2018%2F07%2F01%2FPython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96%2F</url>
    <content type="text"><![CDATA[Python网络爬虫与信息提取 文本工具类IDE IDLE — 自带、默认、常用（适用于Python入门） Sublime Text — 第三方专用编程工具 集成工具类IDE PyCharm Anaconda &amp; Spyder Requests库入门Request库的安装终端运行下列命令 1$ pip install requests 获得源码 1$ git clone git://github.com/kennethreitz/requests.git 也可以下载tarball 1$ curl -OL https://github.com/requests/requests/tarball/master 现在完成后，使用如下命令进行安装 12$ cd requests$ pip install . 简单使用 12345import requestsr = requests.get("http://www.baidu.com")print(r.status_code) # 200r.encoding = 'utf-8'print(r.text) # baidu的html源码 Requests库的7个主要方法 Requests库的get() 使用方法 1requests.get(url,params=None,**kwargs) url：拟获取页面的url链接 params：url中的额外参数，字典或字节流格式，可选 **kwargs：12个控制访问的参数 Response对象的属性 栗子： 12345678910111213&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get('https://www.baidu.com')&gt;&gt;&gt; r.encoding = 'utf-8'&gt;&gt;&gt; r.text'&lt;!DOCTYPE html&gt;\r\n&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt; ...... &lt;/head&gt; &lt;body&gt; ...... &lt;/body&gt;&lt;/html&gt; r.encoding：如果header中不存在charset，则认为编码为ISO-8859-1 Requests库的异常 状态响应码status_code 12345678910111213141516171819&gt;&gt;&gt; r = requests.get('https://www.baidu.com')&gt;&gt;&gt; r.status_code200# 为方便引用，Requests还有一个内置的状态码查询对象&gt;&gt;&gt; r.status_code == requests.codes.okTrue# 如果是一个错误请求，可以通过Response.raise_for_status()来抛出异常&gt;&gt;&gt; bad_r = requests.get('http://httpbin.org/status/404')&gt;&gt;&gt; bad_r.status_code404&gt;&gt;&gt; bad_r.raise_for_status()Traceback (most recent call last): File "requests/models.py", line 832, in raise_for_status raise http_errorrequests.exceptions.HTTPError: 404 Client Error# r.status == 200,当我们调用raise_for_status()时，得到的是&gt;&gt;&gt; r.raise_for_status()None 爬取网页的通用代码框架TTP 1234567891011121314import requestsdef getHTMLText(url): try: r = requests.get(url,time=30) r.raise_for_status() #如果状态不是200，将引发HTTPError异常 r.encoding = r.apparent_encoding return r.text except： return "产生异常" if __name__ = "__main__": url = 'https://www.baidu.com' print(getHTMLText(url)) HTTP协议 HTTP，Hypertext Transfer Protocol，超文本传输协议。 HTTP是一个基于“请求与响应”模式的、装状态的应用层协议。 HTTP协议采用URL作为定位网络资源的标识 URL格式 http://host[:port][path] host：合法的Internet主机域名或IP地址 port：端口号，缺省端口为80 path：请求资源的路径 HTTP协议对资源的操作 理解PATCH和PUT的区别 采用PATCHA，仅向URL提交局部更新的请求 采用PUT，必须将所有字段一并提交到URL，未提交字段被删除 Requests库的head()方法 12345&gt;&gt;&gt; r = requests.head('http://www.baidu.com')&gt;&gt;&gt; r.headers&#123;'Cache-Control': 'private, no-cache, no-store, proxy-revalidate, no-transform', 'Connection': 'Keep-Alive', 'Content-Encoding': 'gzip', 'Content-Type': 'text/html', 'Date': 'Sun, 01 Jul 2018 07:38:20 GMT', 'Last-Modified': 'Mon, 13 Jun 2016 02:50:26 GMT', 'Pragma': 'no-cache', 'Server': 'bfe/1.0.8.18'&#125;&gt;&gt;&gt; r.text'' Requests库的post()方法 1234567891011&gt;&gt;&gt; payload = &#123;'key1':'value1','key2':'value2'&#125;&gt;&gt;&gt; r = requests.post('http://www.baidu.com/post',data = payload)&gt;&gt;&gt; print(r.text)&#123; # 向URL POST一个字典，自动编码为form(表单) ... "form":&#123; "key2":"value2", "key1":"value2" &#125;, ...&#125; Requests库的put()方法 12345678910111213&gt;&gt;&gt; payload = &#123;'key1':'value1','key2':'value2'&#125;&gt;&gt;&gt; r = requests.put("http://www.baidu.com/put',data = payload")&gt;&gt;&gt; print(r.text)&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;405 Method Not Allowed&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Method Not Allowed&lt;/h1&gt; &lt;p&gt;The requested method PUT is not allowed for the URL /put',data=payload.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; Requests库主要方法解析 requests.request(method,url,**kwargs) method：请求方式，对应get/put/post等7种 r = requests.request(‘GET’,url,*kwargs) r = requests.request(‘HEAD’,url,*kwargs) r = requests.request(‘POST’,url,*kwargs) r = requests.request(‘PUT’,url,*kwargs) r = requests.request(‘PATCH’,url,*kwargs) r = requests.request(‘delete’,url,*kwargs) r = requests.request(‘OPTIONS’,url,*kwargs) url：获取页面的url链接 **kwargs：控制访问参数，共13个 params：字典或字节序列，作为参数增加到url种 1234&gt;&gt;&gt; kv = &#123;'key1':'value1','key2':'value2'&#125;&gt;&gt;&gt; r = requests.request('GET','http://www.baidu.com/s',params=kv)&gt;&gt;&gt; print(r.url)http://www.baidu.com/s?key1=value1&amp;key2=value2 data：字典、字节序列或文件对象，作为Request的内容，向服务器提交资源时使用 1234&gt;&gt;&gt; kv = &#123;'key1':'value1','key2':'value2'&#125;&gt;&gt;&gt; r = requests.request('POST','http://www.baidu.com/s',data=kv)&gt;&gt;&gt; body = '主体内容'&gt;&gt;&gt; r = requests.request('POST','http://www.baidu.com/s',data=body) json：JSON格式的数据，作为Request的内容 12&gt;&gt;&gt; kv = &#123;'key1':'value1'&#125;&gt;&gt;&gt; r = requests.request('POST','http://www.baidu.com/s',json=kv) headers：字典，HTTP定制头 12&gt;&gt;&gt; hd = &#123;'user-agent':'Chrome/10'&#125;&gt;&gt;&gt; r = requests.request('POST','http://python123.io/ws',headers=hd) cookies：字典或CookieJar，Request中的cookie auth：元组，支持HTTP认证功能 file：字典类型，传输文件 12&gt;&gt;&gt; fs = &#123;'file':open('data.xls','rb')&#125;&gt;&gt;&gt; r = requests.request('POST','http://python123.io/ws',files=fs) timeout：设定超时时间，秒为单位 1&gt;&gt;&gt; r = requests.request('GET','http://www.baidu.com',timeout=10) proxies：字典类型，设定访问代理服务器，可以增加登录认证 12&gt;&gt;&gt; pxs = &#123;'http':'http://user:pass@10.10.10.1:1234','https':'https://10.10.10.1:4321'&#125;&gt;&gt;&gt; r = requests.request('GET','http://www.baidu.com',proxies=pxs) allow_redirects：True/False，默认为True，重定向开关 stream：True/False，默认为True，获取内容立即下载开关 verify：True/False，默认为True，认证SSL证书开关 cert：本地SSL证书路径 网络爬虫的盗亦有道 网络爬虫的尺寸 网络爬虫的法律风险 服务器上的数据有产权归属 网络爬虫获取数据后牟利将带来法律风险 网络爬虫泄露数据 网络爬虫的限制 来源审查：判断User-Agent进行限制 检查来访HTTP协议头的User-Agent域，只响应浏览器或友好爬虫的访问 发布公告：Robots协议 告知所有爬虫网站的爬取策略，要求爬虫遵守 Robots协议（Robots Exclusion Standard 网络爬虫排除标准） 作用：网站告知网络爬虫哪些页面可以抓取，哪些不行 形式：在网站根目录下的robots.txt文件 https://www.jd.com/rboots.txt 123456789101112131415User-agent: * Disallow: /?* Disallow: /pop/*.html Disallow: /pinpai/*.html?* User-agent: EtaoSpider Disallow: / User-agent: HuihuiSpider Disallow: / User-agent: GwdangSpider Disallow: / User-agent: WochachaSpider Disallow: /# 注释 * 代表所有 /代表根目录User-agent: *Disallow: / 遵守方式 网络爬虫：自动或人工识别robots.txt，再进行内容爬取 约束性：Robots协议是建议但非约束性，网络爬虫可以不遵守，但存在法律风险 理解 Requests库爬取实例实例1：京东商品页面的爬取123456789import requestsurl = 'https://item.jd.com/2967929.html'try: r = requests.get(url) r.raise_for_status() r.encoding = r.apparent_encoding print(r.text[:1000])except: print('爬取失败') 实例2：亚马逊商品的爬取12345678910import requestsurl = "https://www.amazon.cn/dp/B00QJDOLIO/ref=lp_1536596071_1_1?s=amazon-devices&amp;ie=UTF8&amp;qid=1530439999&amp;sr=1-1"try: kv = &#123;'user-agent':'Mozilla/5.0'&#125; r = requests.get(url,headers=kv) r.raise_for_status() r.encoding = r.apparent_coding print(r.text[1000:2000])except: print("爬取失败") 实例3：百度和360搜索关键字提交 百度 12345678910import requestskeyword = "Python"try: kv = &#123;'wd':keyword&#125; r = requests.get("http://www.baidu.com/s",params=kv) print(r.request.url) r.raise_for_status() print(len(r.text))except: print("爬取失败") 360 12345678910import requestskeyword = "Python"try: kv = &#123;'q':keyword&#125; r = requests.get("http://www.so.com/s",params=kv) print(r.request.url) r.raise_for_status() print(len(r.text))except: print("爬取失败") 实例4：网络图片的爬取和存储123456789101112131415161718import requestsimport osroot = "/Users/entercoder/Documents/123.jpg"url = "https://ws2.sinaimg.cn/large/006tNc79gy1fsuinx4kc6j30np05wgmm.jpg"path = root + url.split('/')[-1]try: if not os.path.exists(root): os.mkdir(root) if not os.path.exists(path): r = requests.get(url) with open(path,'wb') as f: f.write(r.content) f.close() print("save successful") else: print("file already exists")except: print("download fail") 实例5：IP地址归属地自动查询123456789import requestsurl = "http://ip138.com/ips138.asp?ip="try: r = requests.get(url + '202.204.80.112') r.raise_for_status() r.encoding = r.apparent_encoding print(r.text[-500:])except: print("爬取失败") BeautifulSoup入门BeautifulSoup库的安装 使用pip安装 1$ pip3 install BeautifulSoup4 源码安装 下载源码 通过setup.py安装 1$ Python setup.py install 安装解析器 lxml 1$ pip3 install lxml html5lib 1$ pip3 install html5lib 主要解析器及使用方法 测试 12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get('https://python123.io/ws/demo.html')&gt;&gt;&gt; demo = r.text&gt;&gt;&gt; from bs4 import BeautifulSoup&gt;&gt;&gt; soup = BeautifulSoup(demo,'html.parser') # 需要解析的html格式的内容和解析器&gt;&gt;&gt; print(soup.prettify())&lt;html&gt; &lt;head&gt; &lt;title&gt; This is a python demo page &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class="title"&gt; &lt;b&gt; The demo python introduces several python courses. &lt;/b&gt; &lt;/p&gt; &lt;p class="course"&gt; Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses: &lt;a class="py1" href="http://www.icourse163.org/course/BIT-268001" id="link1"&gt; Basic Python &lt;/a&gt; and &lt;a class="py2" href="http://www.icourse163.org/course/BIT-1001870001" id="link2"&gt; Advanced Python &lt;/a&gt; . &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; BeautifulSoup库的基本元素 BeautifulSoup库是解析、遍历、维护“标签树”的功能库 BeautifulSoup类的基本元素 12345678910111213141516171819202122232425262728293031323334353637383940414243&gt;&gt;&gt; import requests&gt;&gt;&gt; from bs4 import BeautifulSoup&gt;&gt;&gt; r = requests.get("http://python123.io/ws/demo.html")&gt;&gt;&gt; demo = r.text&gt;&gt;&gt; soup = BeautifulSoup(demo,"html.parser")&gt;&gt;&gt; soup.title&lt;title&gt;This is a python demo page&lt;/title&gt;&gt;&gt;&gt; tag = soup.a&gt;&gt;&gt; tag&lt;a class="py1" href="http://www.icourse163.org/course/BIT-268001" id="link1"&gt;Basic Python&lt;/a&gt;&gt;&gt;&gt; soup.a.name'a'&gt;&gt;&gt; soup.a.parent.name'p'&gt;&gt;&gt; soup.a.parent.parent.name'body'&gt;&gt;&gt; tag.attrs&#123;'href': 'http://www.icourse163.org/course/BIT-268001', 'class': ['py1'], 'id': 'link1'&#125;&gt;&gt;&gt; tag.attrs['class']['py1']&gt;&gt;&gt; tag.attrs['href']'http://www.icourse163.org/course/BIT-268001'&gt;&gt;&gt; type(tag.attrs)&lt;class 'dict'&gt;&gt;&gt;&gt; type(tag)&lt;class 'bs4.element.Tag'&gt;&gt;&gt;&gt; soup.a.string'Basic Python'&gt;&gt;&gt; soup.p.string'The demo python introduces several python courses.'&gt;&gt;&gt; type(soup.p.string)&lt;class 'bs4.element.NavigableString'&gt;&gt;&gt;&gt; newsoup = BeautifulSoup("&lt;b&gt;&lt;!-- This is a comment --&gt;&lt;/b&gt;&lt;p&gt;This is not a comment&lt;/p&gt;","html.parser")# 不常用&gt;&gt;&gt; newsoup.b.string' This is a comment '&gt;&gt;&gt; type(newsoup.b.string)&lt;class 'bs4.element.Comment'&gt;&gt;&gt;&gt; newsoup.p.string'This is not a comment'&gt;&gt;&gt; type(newsoup.p.string)&lt;class 'bs4.element.NavigableString'&gt; 基于bs4库的HTML内容遍历方法 遍历方式 标签树的下行遍历 1234567891011121314151617181920&gt;&gt;&gt; from bs4 import BeautifulSoup&gt;&gt;&gt; soup = BeautifulSoup(demo,"html.parser")&gt;&gt;&gt; soup.head&lt;head&gt;&lt;title&gt;This is a python demo page&lt;/title&gt;&lt;/head&gt;&gt;&gt;&gt; soup.head.contents[&lt;title&gt;This is a python demo page&lt;/title&gt;]&gt;&gt;&gt; soup.body.contents['\n', &lt;p class="title"&gt;&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;&lt;/p&gt;, '\n', &lt;p class="course"&gt;Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses:&lt;a class="py1" href="http://www.icourse163.org/course/BIT-268001" id="link1"&gt;Basic Python&lt;/a&gt; and &lt;a class="py2" href="http://www.icourse163.org/course/BIT-1001870001" id="link2"&gt;Advanced Python&lt;/a&gt;.&lt;/p&gt;, '\n']&gt;&gt;&gt; len(soup.body.contents)5&gt;&gt;&gt; soup.body.contents[1]&lt;p class="title"&gt;&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;&lt;/p&gt;&gt;&gt;&gt; # 遍历儿子节点for child in soup.body.children: print(child)# 遍历子孙节点for child in soup.body.descendants: print(children) 标签树的上行遍历 123456789101112131415161718&gt;&gt;&gt; soup = BeautifulSoup(demo,"html.parser")&gt;&gt;&gt; soup.title.parent&lt;head&gt;&lt;title&gt;This is a python demo page&lt;/title&gt;&lt;/head&gt;&gt;&gt;&gt; soup.html.parent&lt;html&gt;&lt;head&gt;&lt;title&gt;This is a python demo page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class="title"&gt;&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;&lt;/p&gt;&lt;p class="course"&gt;Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses:&lt;a class="py1" href="http://www.icourse163.org/course/BIT-268001" id="link1"&gt;Basic Python&lt;/a&gt; and &lt;a class="py2" href="http://www.icourse163.org/course/BIT-1001870001" id="link2"&gt;Advanced Python&lt;/a&gt;.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&gt;&gt;&gt; soup.parent# 标签树的上行遍历&gt;&gt;&gt; soup = BeautifulSoup(demo,"html.parser")&gt;&gt;&gt; for parent in soup.a.parents: if parent is None: print(parent) else: print(parent.name) 标签树的平行遍历 12345678910111213141516&gt;&gt;&gt; soup = BeautifulSoup(demo,"html.parser")&gt;&gt;&gt; soup.a.next_sibling' and '&gt;&gt;&gt; soup.a.next_sibling.next_sibling&lt;a class="py2" href="http://www.icourse163.org/course/BIT-1001870001" id="link2"&gt;Advanced Python&lt;/a&gt;&gt;&gt;&gt; soup.a.previous_sibling'Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses:\r\n'&gt;&gt;&gt; soup.a.previous_sibling.previous_sibling# 标签树的平行遍历# 遍历后续节点for sibling in soup.a.next_siblings print(sibling)# 遍历前续节点for sibling in soup.a.previous_siblings: print(sibling) 总结 基于bs4库的HTML格式输出 prettify()方法可以格式化输出HTML文本 123&gt;&gt;&gt; soup = BeautifulSoup(demo,"html.parser")&gt;&gt;&gt; soup.prettify()&gt;&gt;&gt; print(soup.prettify()) 信息标记的三种形式 三种形式 XML – eXtensible Markup Language JSON – JavaScript Object Notation YAML – 三种信息标记形式的比较 信息提取的一般方法 基于bs4库的HTML内容查找方法 &lt;&gt;.find_all(name,attrs,recursive,string,**kwargs) 返回一个列表类型，存储查找结果 name：对标签名称的检索字符串 1234567891011121314151617181920&gt;&gt;&gt; soup.find_all('a')[&lt;a class="py1" href="http://www.icourse163.org/course/BIT-268001" id="link1"&gt;Basic Python&lt;/a&gt;, &lt;a class="py2" href="http://www.icourse163.org/course/BIT-1001870001" id="link2"&gt;Advanced Python&lt;/a&gt;]&gt;&gt;&gt; soup.find_all(['a','b'])[&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;, &lt;a class="py1" href="http://www.icourse163.org/course/BIT-268001" id="link1"&gt;Basic Python&lt;/a&gt;, &lt;a class="py2" href="http://www.icourse163.org/course/BIT-1001870001" id="link2"&gt;Advanced Python&lt;/a&gt;]&gt;&gt;&gt; for tag in soup.find_all(True): print(tag.name)htmlheadtitlebodypbpaa&gt;&gt;&gt; import re&gt;&gt;&gt; for tag in soup.find_all(re.compile('b')): print(tag.name)bodyb attrs：对标签属性值的检索字符窜，可标注属性检索 recursive：是否对子孙全部检索，默认True string：\&lt;&gt;…\&lt;/&gt;中字符串区域的检索字符串 \(…)等价于\.find_all(…) soup(…)等价于soup.find_all(…) 七个常用扩展方法 实例1：中国大学排名定向爬虫 功能描述 输入：大学排名URL连接 输出：大学排名信息的屏幕输出（排名，大学名称，总分） 技术路线：requests-bs4 定向爬去：仅对输入URL进行爬取，不扩展爬取 程序的结构设计 从网络上获取大学排名网页内容 – getHTMLText() 提取网页内容中信息到合适的数据结构 – fillUnivList() 利用数据结构展示并输出结果 – fillUnivList() 代码 123456789101112131415161718192021222324252627282930313233import requestsfrom bs4 import BeautifulSoupimport bs4def getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return "except"def fillUnivList(ulist, html): soup = BeautifulSoup(html, 'html.parser') for tr in soup.find('tbody').children: if isinstance(tr,bs4.element.Tag): tds = tr('td') ulist.append([tds[0].string, tds[1].string, tds[3].string])def printUnivList(ulist, num): tplt = "&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;" print(tplt.format("排名", "学校", "分数",chr(12288))) for i in range(num): u = ulist[i] print(tplt.format(u[0], u[1], u[2],chr(12288)))if __name__ == '__main__': uinfo = [] url = 'http://zuihaodaxue.com/zuihaodaxuepaiming2018.html' html = getHTMLText(url) fillUnivList(uinfo, html) printUnivList(uinfo, 100) 正则表达式正则表达式是用来简洁表达一组字符串的表达式。 编译：将符合正则表达式语法的字符串转换成正则表达式特征 语法 Re库的基本使用Re库是Python的标准库，主要用于字符串匹配，调用方式：import re 正则表达式的表示类型 raw string类型（原生字符串类型） string类型 Re库主要功能函数 re.search(pattern,string,flags=0) pattern：正则表达式的字符串或原生字符串表示 string：待匹配字符串 flags：正则表达式使用时的控制标记 123456&gt;&gt;&gt; import re&gt;&gt;&gt; match = re.search(r'[1-9]\d&#123;5&#125;','bit 100081')&gt;&gt;&gt; if match: print(match.group(0))100081 re.match(pattern,string,flags=0) pattern：正则表达式的字符串或原生字符串表示 string：待匹配字符串 flags：正则表达式使用时的控制标记 1match = re.match(r'[1-9]\d&#123;5&#125;','100081 bit') re.findall(pattern.string.flags=0) pattern：正则表达式的字符串或原生字符串表示 string：待匹配字符串 flags：正则表达式使用时的控制标记 123&gt;&gt;&gt; ls = re.findall(r'[1-9]\d&#123;5&#125;','bit100081 tsu 100084')&gt;&gt;&gt; ls['100081', '100084'] re.split(pattern,string,maxsplit=0,flags=0) pattern：正则表达式的字符串或原生字符串表示 string：待匹配字符串 maxsplit：最大分个数，剩余部分作为最后一个元素输出 flags：正则表达式使用时的控制标记 123&gt;&gt;&gt; ls = re.split(r'[1-9]\d&#123;5&#125;','bit100081 tsu100084',maxsplit=1)&gt;&gt;&gt; ls['bit', ' tsu100084'] re.finditer(pattern,string,flags=0) pattern：正则表达式的字符串或原生字符串表示 string：待匹配字符串 flags：正则表达式使用时的控制标记 123456&gt;&gt;&gt; for m in re.finditer(r'[1-9]\d&#123;5&#125;','bit100081 tsu100084'): if m: print(m.group(0)) 100081100084 re.sub(pattern,repl,string,count=0,flags=0) pattern：正则表达式的字符串或原生字符串表示 repl：替换匹配字符串的字符串 string：待匹配字符串 count：匹配的最大替换次数 flags：正则表达式使用时的控制标记 123&gt;&gt;&gt; re = re.sub(r'[123]','456','1237878712398798123',count=2)&gt;&gt;&gt; re'45645637878712398798123' Re库的另一种等价用法 函数式用法：一次性操作 1&gt;&gt;&gt; rst = re.search(r'[1-9]\d&#123;5&#125;','bit 100081') 面向对象用法：编译后多次操作 12&gt;&gt;&gt; pat = re.compile(r'[1-9]\d&#123;5&#125;')&gt;&gt;&gt; rst = pat.search('bit 100081') regex = re.compile(pattern,flags=0) – 将正则表达式的字符串形式编译成正则表达式对象 regex.search() regex.match() regex.findall() regex.split() regex.finditer() regex.sub() Re库的Match函数 Match对象的属性 Match对象的方法 Re库的贪婪匹配和最小匹配 贪婪匹配：Re库默认采用贪婪匹配，即输出匹配最长的子串 最小匹配 实例2 淘宝商品比价定向爬虫 功能描述 目标：获取淘宝搜索页面的信息，提取其中的商品名称和价格 理解：淘宝的搜索接口和翻页的处理 技术路线：requests-re 程序的设计结构 提交商品搜索请求，循环获取页面 对于每个商品，提取商品名称和价格信息 将信息输出到屏幕上 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import requestsimport redef getHTMLText(url): try: r = requests.get(url) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return ""def parsePage(ilt,html): try: plt = re.findall(r'"view_price":"[\d.]*"',html) tlt = re.findall(r'"raw_title":".*?"',html) for i in range(len(plt)): price = eval(plt[i].split(':')[1]) title = eval(tlt[i].split(':')[1]) ilt.append([price,title]) except: print("")def printGoodsList(ilt): tplt = "&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;" print(tplt.format("xuhao","jiage","shangpin name")) count = 0 for g in ilt: count = count + 1 print(tplt.format(count,g[0],g[1])) def main(): goods = 'shubao' depth = 2 start_url = 'https://s.taobao.com/search?q=%' + goods infoList = [] for i in range(depth): try: url = start_url + '&amp;s=' + str(44*i) html = getHTMLText(url) parsePage(infoList,html) except: continue printGoodsList(infoList)main() 实例3 股票数据定向爬虫 功能描述 目标：获取上交所和深交所所有股票的名称和交易信息 输出：保存到文件中 技术路线：requests-bs4-re 程序结构设计 从东方财富网选取股票列表 根据股票列表逐个到百度股票获取个股信息 将结果存储到文件 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import requestsfrom bs4 import BeautifulSoupimport tracebackimport redef getHTMLText(url,code='utf-8'): try: r = requests.get(url) r.raise_for_status() r.encoding = code return r.text except: return ""def getStockList(lst, stockURL): html = getHTMLText(stockURL) soup = BeautifulSoup(html, 'html.parser') a = soup.find_all('a') for i in a: try: href = i.attrs['href'] lst.append(re.findall(r"[s][hz]\d&#123;6&#125;", href)[0]) except: continuedef getStockInfo(lst, stockURL, fpath): count = 0 for stock in lst: url = stockURL + stock + ".html" html = getHTMLText(url) try: if html == "": continue infoDict = &#123;&#125; soup = BeautifulSoup(html, "html.parser") stockInfo = soup.find_all('div', attrs=&#123;'class': 'stock-bets'&#125;)[0] name = stockInfo.find(attrs=&#123;'class':'bets-name'&#125;)[0] infoDict.update(&#123;'stockname': name.text.split()[0]&#125;) keyList = stockInfo.find_all('dt') valueList = stockInfo.find_all('dd') for i in range(len(lst)): # if i == 20: # break key = keyList[i].text val = valueList[i].text infoDict[key] = val with open(fpath, 'a', encoding='utf-8') as f: f.write(str(infoDict) + '\n') count = count + 1 print('\r当前速度：&#123;:.2f&#125;%'.format(count*100/len(lst)), end='') except: count = count + 1 print('\r当前速度：&#123;:.2f&#125;%'.format(count*100/len(lst)),end='') # traceback.print_exc() continuedef main(): stock_list_url = "http://quote.eastmoney.com/stocklist.html" stock_info_url = "https://gupiao.baidu.com/stock/" output_file = "/Users/entercoder/Documents/stock.txt" slist = [] getStockList(slist, stock_list_url) getStockInfo(slist, stock_info_url, output_file)main() ​ ​ ​ ​ ​]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Python</tag>
        <tag>Spider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript]]></title>
    <url>%2F2018%2F04%2F05%2FJavaScript%2F</url>
    <content type="text"><![CDATA[JavaScript，通常缩写为JS，是一种高级的，解释执行的编程语言。 JavaScript是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象编程，命令式编程，以及函数式编程。 它提供语法来操控文本、数组、日期以及正则表达式等，不支持I/O，比如网络、存储和图形等，但这些都可以由它的宿主环境提供支持。 JavaScript笔记(一)JavaScript简介 JavaScript和ECMAScript通常都被人们用来表达相同的含义，但JavaScript的含义却比ECMA-262中规定的要多的多。 完整的JavaScript实现由三个不同的部分组成 核心(ECMAScript) 文档对象模型(DOM) 浏览器对象模型(BOM) ECMAScript ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会）通过ECMA-262标准化的脚本程序设计语言。 这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMA-262标准的实现和扩展。 ECMA-262规定了ECMAScript语言的组成部分: 语法 类型 语句 关键字 保留字 操作符 对象 ECMAScript就是对实现该标准的各个方面内容的描述。JavaScript实现了ECMAScript，Adobe ActionScript同样也实现了ECMAScript。 什么是ECMAScript兼容文档对象模型(DOM)文档对象模型(DOM，Document Object Model)是针对XML但经过扩展用于HTML的应用程序编程接口(API,Application Progrmaming Interface)。DOM把整个页面映射为一个多层节点结构。HTML或XML页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据。 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Sample Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 通过DOM创建的这个表示文档的树形图，开发人员可以控制页面的内容和结构。借助DOM提供的API，可以对节点进行删除、添加、替换或修改。 浏览器对象模型浏览器对象模型(BOM，Browser Object Model)可以访问和操作浏览器窗口。开发人员使用BOM可以控制浏览器显示的页面的一部分。从根本上讲，BOM只处理浏览器窗口和框架；但习惯上吧所有针对浏览器的扩展算作是BOM的一部分。比如以下扩展： 弹出新浏览器窗口的功能； 移动、缩放和关闭浏览器的功能； 提供浏览器详细信息的navigator对象； 提供浏览器所加载页面的详细信息的location对象； 提供用户显示器分辨率详细信息的screen对象； 对cookies的支持 项XMLHttpRequest和IE的ActiveXObject这样的自定义对象。 在HTML中使用JavaScript&lt;script&gt;元素使用&lt;script&gt;元素可以向HTML页面中插入JavaScript。HTML4.01为&lt;script&gt;定义了6个属性： async：可选。表示应该立即下载脚本，但不妨碍页面中的其他操作。只对外部脚本文件有效。 charset：可选。通过src属性指定代码的字符集，大多数浏览器会忽略它的值。 defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。 language：已废弃。 src：可选。表示包含要执行代码的外部文件。 type：可选。可以看成是language的替代属性；表示编写代码使用的脚本语言的内容类型(也称为MIME类型。)) 使用&lt;script&gt;元素的两种方式：嵌入式和外本文件，在使用&lt;script&gt;元素嵌入JavaScript代码时，只须魏&lt;script&gt;指定type属性。 12345&lt;script type="text/javascript"&gt; function sayHi()&#123; alert("Hi!"); &#125;&lt;/script&gt; 包含在&lt;script&gt;元素的代码将从上至下依次解释。 通过&lt;script&gt;元素来包含外部JavaScript文件，必须包含src属性。这个属性的值指向外部JavaScript文件的链接。 1&lt;script type="text/javascript" src="example.js"&gt;&lt;/script&gt; 一般外部的JavaScript文件带有.js扩展名。但不是必须的，李兰器不会检查包含JavaScript文件的扩展名。因此，也可以使用JSP、PHP或其他服务器端语言动态生成JavaScript代码。 外部文件example.js将被加载到当前页面中。与解析嵌入式JavaScript代码一样，在解析外部JavaScript文件(包括下载该文件)时，页面的处理会暂时停止。如果是在XHTML文档中，可以省略&lt;/script&gt;标签。 带有src属性的&lt;script&gt;元素会忽略&lt;script&gt;和&lt;/script&gt;标签内的代码，scr属性也可以包含外部域的JavaScript文件。 1&lt;script type="text/javascript" src="http://www.somewhere.com/afile.js"&gt;&lt;/script&gt; 标签的位置&lt;script&gt;元素应该放在页面的&lt;head&gt;元素中 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Example HTML Page&lt;/title&gt; &lt;script type="text/javascript" src="example1.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="example2.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- content --&gt;&lt;/body&gt;&lt;/html&gt; 这样意味着必须等到全部的JavaScript代码都被下载、解析和执行完成后才开始呈现页面的内容。若JavaScript代码很多，这将会导致浏览器在呈现页面时出现明显的延迟，因此现代的Web应用程序一般把全部JavaScript引用放在&lt;body&gt;元素中页面内容的后面。 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Example HTML Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- content --&gt; &lt;script type="text/javascript" src="example1.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="example2.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 延迟脚本HTML4.01为&lt;script&gt;标签定义了defer属性。这个属性表明脚本在执行时不会影响页面的构造。即脚本会被延迟到整个页面都解析完毕后再运行。浏览器会立即下载，但延迟执行。 1&lt;script type="text/javascript" defer="defer" src="example2.js"&gt;&lt;/script&gt; 延迟脚本并不一定按照顺序执行，因此最好只包含一个延迟脚本。且defer属性只适用于外部脚本文件。HTML5的实现会默认忽略嵌入脚本设置的defer属性。 在XHTML文档中，要把defer属性设置为defer=”defer”。 异步脚本HTML5为&lt;script&gt;元素定义了async属性。async只适用于外部脚本文件，浏览器会立即下载文件，但标记为async的脚本并不保证按照指定它们的先后顺序执行。 12&lt;script type="text/javascript" async src="example1.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" async src="example2.js"&gt;&lt;/script&gt; 在以上代码中，第二个脚本可能会在第一个脚本执行前执行。因此要确保两者之间互不依赖。指定async属性目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。异步脚本不要再加载期间修改DOM。 在XHTML文档中，要把async属性设置为async=”async”。 在XHTML中的用法XHTML(Extensible HyperText Markup Language，可扩展超文本标记语言)是将HTML作为XML的应用重新定义的一个标准。XHTML代码的规则必HTML要严格得多，而且直接影响嵌入的JavaScript代码是否有效。 嵌入代码与外部文件使用外部文件引入JavaScript代码的优点： 可维护性：遍及不同HTML页面的JavaScript会造成维护问题。 可缓存：浏览器可以根据具体的设置换轮链接的所有外部JavaScript文件。 适应未来：HTML和XHTML包含外部文件的语法是相同的。 &lt;noscript&gt;元素若浏览器不支持JavaScript时，可以使用&lt;noscript&gt;元素显示替代的内容。这个元素可以出现在任何HTML元素(&lt;script&gt;元素除外)。包含在&lt;noscript&gt;元素的内容只在浏览器不支持脚本或脚本被禁用的情况下再回显示出来。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Example HTML Page&lt;/title&gt; &lt;script type="text/javascript" src="example1.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="example2.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- content --&gt; &lt;noscript&gt; &lt;p&gt;本页面需要浏览器支持(启用)JavaScript。 &lt;/noscript&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS层叠样式表]]></title>
    <url>%2F2018%2F03%2F31%2FCSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。 使用CSS样式的方式 内链样式表 123&lt;body style="background-color:green; margin:0; padding:0;"&gt;&lt;/body&gt; 嵌入式样式表 12345&lt;head&gt; &lt;style type="text/css"&gt; &lt;/style&gt;&lt;/head&gt; 引入式样式表 1&lt;link rel="stylesheet" type="text/css" href="style.css"&gt; 定义样式表定义方式 HTML标记定义 123456&lt;p&gt;...&lt;/p&gt;p&#123; 属性:属性值; 属性2:属性值2;&#125;//p可以叫选择器，定义那个标记中的内容执行其中的样式 class定义 12345&lt;p class="a"&gt;...&lt;/p&gt;.a &#123; 属性:属性值; 属性2:属性值2;&#125; id定义 12345&lt;p id="b"&gt;...&lt;/p&gt;#b &#123; 属性:属性值; 属性2:属性值2;&#125; 优先级问题 id&gt;class&gt;HTML标记 组合选择器 1234h1,h2,h3,.a,#b &#123; 属性:属性值; 属性2:属性值2;&#125; 伪元素选择器 a:link 正常连接的样式 a:hover 鼠标放上去的样式 a:active 选择链接时的样式 a:visited 已经访问过的链接的样式 常见属性颜色color属性定义文本的颜色 12345color:greencolor:#ff6600color:#f60 //简写式color:rgb(255,255,255)color:rgba(255,255,255,1) 字体font-size属性定义字体的大小font-size:14px font-family定义字体font-family:微软雅黑,serif;使用,隔开,以确保当字体不存在时直接使用下一个 font-family字体加粗normal|bold|bolder|lighter,也可以使用100|200|300~900,400=normal,700=bold 背景 背景颜色background-color 背景图片background-image:url(图片路径)|nore 背景重复background-repeat:repeat|repeat-x|repeat-y|no-repeat 背景位置background-position:横向(left,center,right)|纵向(top,center,bottom) 简写方式background:#f60 url(images/bg,jpt) no-repeat top center 文本横向排列text-align:left|center|right文本行高line-height:100%|20首行缩进text-indent:4字符间距letter-spacing:normal|10|inherit 边框 边框风格border-style 边框宽度border-width 边框颜色border-color 简写方式`border:solid 2px #f60 列表 标记类型list-style-type 123456789101112131415161718192021none 无标记。disc 默认。标记是实心圆。circle 标记是空心圆。square 标记是实心方块。decimal 标记是数字。decimal-leading-zero 0开头的数字标记。(01, 02, 03, 等。)lower-roman 小写罗马数字(i, ii, iii, iv, v, 等。)upper-roman 大写罗马数字(I, II, III, IV, V, 等。)lower-alpha 小写英文字母The marker is lower-alpha (a, b, c, d, e, 等。)upper-alpha 大写英文字母The marker is upper-alpha (A, B, C, D, E, 等。)lower-greek 小写希腊字母(alpha, beta, gamma, 等。)lower-latin 小写拉丁字母(a, b, c, d, e, 等。)upper-latin 大写拉丁字母(A, B, C, D, E, 等。)hebrew 传统的希伯来编号方式armenian 传统的亚美尼亚编号方式georgian 传统的乔治亚编号方式(an, ban, gan, 等。)cjk-ideographic 简单的表意数字hiragana 标记是：a, i, u, e, o, ka, ki, 等。（日文片假名）katakana 标记是：A, I, U, E, O, KA, KI, 等。（日文片假名）hiragana-iroha 标记是：i, ro, ha, ni, ho, he, to, 等。（日文片假名）katakana-iroha 标记是：I, RO, HA, NI, HO, HE, TO, 等。（日文片假名） 标记位置list-style-position 123inside 列表项目标记放置在文本以内，且环绕文本根据标记对齐。outside 默认值。保持标记位于文本的左侧。列表项目标记放置在文本以外，且环绕文本不根据标记对齐。inherit 规定应该从父元素继承 list-style-position 属性的值。 设置图像列表标记list-style-image 123URL 图像的路径。none 默认。无图形被显示。inherit 规定应该从父元素继承 list-style-image 属性的值。 简写方式list-style:square inside url(‘/user/hello.jpg’); DIV+CSS布局DIV和SPAN在整个HTML标记中，没有任何意义，他们的存在就是为了应用CSS样式,DIV和span的区别在与，span是内联元素，div是块级元素 盒模型 盒子外边距 margin 盒子内编剧 padding 盒子边框宽度 border 盒子宽度 width 盒子高度 height 布局相关属性 position定位方式 relative 正常定位 absolute 根据父元素定位 fixed 根据浏览器窗口定位 static 没有定位 inherit 继承 定位(离页面顶点的距离) left right top bottom z-index层覆盖先后顺序 display显示属性 none 层不显示 block 块状显示,在元素后面换行,显示下一块元素 内联显示,多个块可以显示在一行内 float属性 left 左浮动 right 右浮动 clear属性 clear:both 清除浮动 scroll无论内容是否超出层大小都添加滚动条 auto 超出时自动添加滚动条 overflow溢出处理 hidden隐藏超出层大小的内容 兼容问题及高效开发工具兼容性测试工具 IE Tester Multibrowser 常用浏览器 Chrome Firefox Opera 高效开发工具 轻量级 Notepad++ Sublime Text 重量级 WebStorm Dreamweaver 网页设计工具 fireworks photoshop]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML标记语言]]></title>
    <url>%2F2018%2F03%2F28%2FHTML%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[超文本标记语言(HTML)是一种用于创建网页的标准标记语言 特点 可以设置文本的格式，比如标题、字号、文本颜色、段落等等 可以创建列表 可以插入图像和媒体 可以建立表格 超链接，可以使用鼠标点击超链接来实现页面之间的跳转 HTML的语法HTML文档的保存格式 .html .htm xhtml 标记和被标记的内容构建出HTML文档,格式为&lt;标记&gt;内容&lt;/标记&gt; 标记的属性是用来控制内容(图像、文本等的)如何的显示，格式为 1&lt;标记 属性1=属性值 属性2=属性值 ......&gt;内容&lt;/标记&gt; 语法不区分字母大小写 代码注释使用”\“,代码格式使用空格和回车(在网页中不起作用)进行编排，以“TAB”键进行缩进。 字符实体 12345678910111213141516 ---------------------空格---------- &amp;nbsp; ----------&amp;#160;&lt;--------------------小于号---------- &amp;lt;---------- &amp;#60;&gt;--------------------大于号---------- &amp;gt;---------- &amp;#62;&amp;--------------------和号---------- &amp;amp;---------- &amp;#38;"--------------------引号---------- &amp;quot; ---------- &amp;#34;'--------------------撇号---------- &amp;apos; (IE不支持)---------- &amp;#39;￠--------------------分---------- &amp;cent;---------- &amp;#162;£--------------------镑---------- &amp;pound;---------- &amp;#163;¥--------------------日圆---------- &amp;yen;---------- &amp;#165;€--------------------欧元---------- &amp;euro;---------- &amp;#8364;§--------------------小节---------- &amp;sect;---------- &amp;#167;©--------------------版权----------&amp;copy;---------- &amp;#169;®--------------------注册商标---------- &amp;reg;---------- &amp;#174;™--------------------商标---------- &amp;trade;---------- &amp;#8482;×--------------------乘号---------- &amp;times;---------- &amp;#215;÷--------------------除号---------- &amp;divide;---------- &amp;#247; HTML的基本结构12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta name="keywords" content="hello world"&gt; &lt;meta charset="UTF-8"&gt; //页面的元信息，提供有关页面的元信息，针对搜索引擎和更新频度的描述和关键词 //必须的属性 content=some_text //常见属性 author keywords description others //meta标记必须放在head元素里面 &lt;/head&gt; &lt;body&gt; //网页的主体标记，可以包含段落、标题、回车、横线等标记 //常见属性 bgcolor text link vlink alink &lt;/body&gt;&lt;/html&gt; 文档设置标记格式标记&lt;br&gt; 换行标记&lt;p&gt; 段落标记&lt;center&gt; 居中标记&lt;pre&gt; 预格式化标记&lt;li&gt; 列表项目标记&lt;ul&gt; 无序列表标记&lt;ol&gt; 有序列表标记 1234567&lt;ol type="1"&gt; &lt;li type="A"&gt;&lt;/li&gt; &lt;li type="a"&gt;&lt;/li&gt; &lt;li type="a"&gt;&lt;/li&gt; &lt;li type="I"&gt;&lt;/li&gt; &lt;li type="i"&gt;&lt;/li&gt;&lt;/ol&gt; &lt;dl&gt;&lt;dt&gt;&lt;dd&gt; 定义型列表&lt;hr&gt; 水平分割线&lt;div&gt; 分区标记，也称为层标记 文本标记 hn 标题标记 font 字体设置标记 sub 下标字体标记 sup 上标字体标记 tt 打印机字体标记 cite 引用方式的字体，通常是斜体 b strong 粗体字体标记 i em 斜字体标记 small 小型字体标记 big 大型字体标记 u 下划线字体标记 图像标记使用方法 12345678&lt;img src="路径/文件名.图片格式 " width="属性值" height="属性值" border="属性值" alt="属性值"&gt;//src属性 指定我们要加载的图片的路径和图片的名称以及图片格式//width属性 指定图片的宽度，单位px、em、cm、mm//height属性 指定图片的高度，单位px、em、cm、mm//border属性 指定图标的边框宽度，单位px、em、cm、mm//alt属性 1.当网页上的图片被加载完成后，鼠标移动到上面去，会显示这个图片指定的属性文字 //2.如果图像没有下载或者加载失败，会用文字来代替图像显示 //3.搜索引擎可以通过这个属性的文字来抓取图片 注意 img为单标记，不需要使用\闭合 加载图片时，文件路径或者文件名文件格式错误，将无法加载图片 超链接的使用123456&lt;a href="" target="打开方式" name="页面锚点名称"&gt;链接文字或者图片&lt;/a&gt;//target属性 _blank 新窗口打开链接// _self() 当前窗口打开链接// _parent 父窗口打开链接// _top 顶层窗口打开链接//name属性 制定页面的锚点名称 表格table标记12345678910&lt;table width="" //px or % height="" //px or % border="" //外边框的宽度 align"" //left or center or right,default=left cellspacing="" //单元格之间的间距，默认是2px cellpadding="" //单元格内容与边框的现实距离 frame="" //控制表格边框最外层的四条线框 void above below hsides lhs rhs vsides box border rules="" //控制是否显示以及如何显示单元格之间的分割线 none all rows clos groups &gt;表格内容&lt;/table&gt; caption标记表格需要使用表格时，可以使用&lt;caption&gt;标记，caption属性位于table属性之后，tr属性之前。 属性值 top bottom left right tr标记定义表格的一行，每一行tr标记可以嵌套多个td或th标记 属性 bgcolor align 设置垂直方向对齐方式 bottom top middle valign 设置水平方向对齐方式 left right center td和th标记th是表头标记，通常 位于首行或首列，th中的文字默认会被加粗，而td不会 td是数据标记，表示该单元的具体数据 属性值 bgcolor align valign width height rowspan 设置单元格所占行数 colspan 设置单元格所占列数 HTML框架框架将浏览器划分成不同的部分，每一部分加载不同的网页，实现在同一浏览器窗口中加载多个页面的效果 frameset标记 12345&lt;frameset cols="*,* or px or %" frameborder="0 or 1" border="5px(default)"&gt; &lt;frame src="" name="" noresize="noresize" //表示不能调整框架的大小，没有设置时就可以调整 scrolling="auto or yes or no" frameborder="1 or 0"&gt; &lt;frame&gt;&lt;/frameset&gt; 表单设计表单标记123456&lt;from actoin="服务器端地址" method="post|get" enctype="" target=""&gt; //post:post方式提交时，将表单中的数据一并包含在表单主体中，一起传送到服务器中处理，没有数据大小限制 //get:get方式提交时，会将表单的内容附加在URL地址的后面，所以限制了提交的内容的长度，不超过8192个字符，且不具备保密性 //enctype 设置表单的资料的编码方式 //指定目标窗口打开方式&lt;/from&gt; 文本域和密码123456&lt;input type="" //text|passwordname="" value="" size="" maxlength=""&gt; 提交、重置和普通按钮12345&lt;input type="submit" type="reset" type="button"&gt; 单选框和复选框12345678&lt;input type="radio" //使用checked属性来设置默认选中项&gt;&lt;input type="checkbox" //使用checked属性来设置默认选中项&gt; 隐藏域当type为hidden时为隐藏表单域 多行文本域1234使用&lt;textarea&gt;标记可以实现一个能够输入多行文本的区域&lt;textarea name="" rows="" cols="" value=""&gt; &lt;/textarea&gt; 菜单下拉列表域12345&lt;select name="" size="" mulitple&gt; //设置多选 &lt;option value="" selected&gt;选项1&lt;/option&gt; //给选项赋值，指定传送到服务器上面的值，selected设置默认选中项 &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt;&lt;/select&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始学编程]]></title>
    <url>%2F2018%2F03%2F21%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[既然想成为一名优秀的开发者，就要一步一步，认认真真学习，直到成为一名优秀的开发者。 学习路径成为一名优秀的全栈工程师 Python HTML + CSS JavaScript Jquery Python Python Web Python常用扩展 Python进阶 JavaAndroidGitLinux网络算法数据结构学习平台系统主：macOS次：Windows 平台 慕课网 网易云课堂 百度云网盘资料 记录方式记录工具 印象笔记 MWeb Blog 记录模板 一级目录(学习技能名称) 思维导图(总) 书籍资料文件夹 SourceCode 1.文件夹(课程名称) 2.文件夹(代码) … Markdown笔记 编辑器 Sublime text3 VIM Pycharm IntelliJ]]></content>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主机规划与磁盘分区]]></title>
    <url>%2F2018%2F03%2F15%2F%E4%B8%BB%E6%9C%BA%E8%A7%84%E5%88%92%E4%B8%8E%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[主机规划与磁盘分区 在Linux中，所有的设备都被当成一个文件来对待。 常见的设备与其在Linux当中的文件名见下表：]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python高阶函数]]></title>
    <url>%2F2017%2F11%2F23%2FPython%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数式Python内建支持的一种封装，通过吧大段代码拆成函数，通过一层层调用，就可以把复杂的任务分解成简单的任务，这种分解称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！ 高阶函数变量可以指向函数函数本身可以赋给变量，即：变量可以指向函数。 12345f = absf&lt;built-in function abs&gt;f(-10)10 函数名也是变量当把abs指向10后，就无法调用abs函数了，因为abs这个变量已经不再指向求绝对值的函数而是指向一个整数。如果要恢复abs函数，只能重启Python交互环境。 123abs = 10abs(-10)Error 传入函数一个函数可以接收另一个函数作为参数，这种函数就称之为高阶函数。 12345def add(x,y,f): return f(x) + f(y) add(-5,6,abs)11 map()、reduce()、filter()和sorted()map()map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数一次作用到序列的每个元素，并把结果作为新的Iterator返回。 12345def f(x): return x * xr = map(f,[1,2,3,4,5,6,7,8,9])list(r)[1,4,9,16,25,36,49,64,81] reduce()reduce()把一个函数作用在一个序列[x1,x2,x3,…]上，reduce()必须接收两个函数，reduce把结果继续和序列的下一个元素做累积计算。 1234567#把序列转化为整数from functools import reducedef fn(x,y): return x * 10 + yreduce(fn,[1,3,5,7,9])13579 把str转换为int的函数 12345678910from functools import reducedef fn(x,y): return x * 10 + y def char2num(s): return &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;[s] reduce(fn,map(char2num,'13579'))13579 整理成一个str2int的函数 12345678from functools import reducedef str2int(s): def fn(x,y): return x * 10 + y def char2num(s): return &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;[s] return reduce(fn,map(char2num,s)) 使用lambda函数简化 123456from functools import reducedef char2num(s): return &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;[s]def str2int(s): return reduce(lambda x,y:x * 10 + y,map(char2num,s)) filter()filter()用于过滤序列，filter()接收一个函数和一个序列两个参数，filter把传入的函数依次作用于每个元素，然后根据返回值是True或False决定保留或丢弃该元素。filter函数返回的是一个Iterator，需要用list()函数获得所有的结果并放回list。 在一个list钟，删除偶数保留基数 1234def is_odd(s): return n % 2 == 1 list(filter(is_odd,[1,2,4,5,6,9,10,15])) 去掉序列中的空字符串 1234def not_empty(s): return s and s.strip() list(filter(not_empty,['a',' ','c',' '])) sorted()sorted()函数是一个高阶函数，可以接收一个key函数来实现自定义的排序。 12345sorted([-1,36,24,5,-20])[-20,-1.5,24,36]sorted([-1,36,24,5,-20],key=abs,reverse=True)[36, 24, -20, 5, -1] 返回函数函数作为返回值高阶函数除了可以接收函数作为参数外，还可以把函数作为结果值返回。 12345def calc_sum(*args): ax = 0 for n in args: ax = ax + n return ax 如果不需要立刻求和，而是在后面的代码中根据需要在计算，可以不返回求和的结果，而是返回求和的函数 1234567def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sum 闭包What在函数中定义函数，并且内部函数可以引用外部函数的参数和局部变量，当外函数返回内函数时，相关参数和变量都保存在返回的函数中，这种方式是称为“闭包”。 一般情况下，函数中的局部变量仅在函数的执行期间可用，一旦函数执行过后，局部变量将不再可用。闭包可以使得局部变量在函数外被访问编程可能。 12345678910def print_msg(): # print_msg是外围函数 msg = "The Zen of Python" def printer(): print(msg) return printer another = print_msg()# 输出The Zen of Pythonanother() Why闭包避免使用全局变量，还能降函数与所操作的某些数据（环境）关联起来。一般来说，党对象中只有一个方法时，使用闭包时更好的选择。 12345678910def adder(x): def wrapper(y): return x + y return wrapperadder5 = adder(5)#输出15adder5(10)#输出6adder5(6) 匿名函数What匿名函数，就是没有名字的函数。关键字lambda可以创建匿名函数，匿名函数有一个限制，就是只能有一个表达式，不用写return，返回追就是该表达式的结果。 12345lambda 参数: 表达式add = lambda x,y : x + yadd(1,3)4 Whylambda函数一般适用于创建一些临时性的，小巧的函数。 1234def func(g,arr): return [g(x) for x in arr]arr = func(lambda x: x + 1,[1,2,3,4,5]) 装饰器希望增强函数的额功能，但是又不希望修改函数的定义，这种在代码运行期间动态的增加功能的方式，称之为“装饰器”，本质上，装饰器就是一个返回函数的高阶函数。 1234567def foo(): print('foo') def bar(func): func() bar(foo) 简单装饰器use_logging就是一个装饰器，它是一个普通的函数，把真正业务逻辑的函数func包裹在其中，use_logging返回的也是一个函数，这个函数的名字叫wrapper。 1234567891011 def use_logging(func): def wrapper(): print('%s is running' % func.__name__) return func() return wrapper() def foo(): print('i am foo') foo = use_logging(foo)foo() 语法糖@符号就是装饰器的语法糖，它放在函数开始定义的地方，这样就可以省略最后一步再次赋值的操作。 1234567891011 def use_logging(func): def wrapper(): print('%s is running' % func.__name__) return func() return wrapper() @use_loggingdef foo(): print('i am foo') foo() 偏函数partial函数可以固定函数参数，并返回一个新的函数，当函数的参数太多，需要固定某些参数时，可以使用functools.partial创建一个新的函数。 1functools.partial(func[,*args][,\*\*kwargs] 转换二进制字符串 12def int2(x,base=2): return int(x,base) 使用functools.partial创建一个偏函数。 1234import functoolsint2 = functools.partial(int,base=2)int2('1000000')64 参考教程：廖雪峰的Python教程]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac常用快捷键]]></title>
    <url>%2F2017%2F11%2F22%2FMac%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[熟练使用快捷键可以节约大量的时间，因此掌握系统和一些常用工具的快捷键可以提高工作效率，而且双手放在键盘上啪啪啪，不会中断思路，最重要的是还可以装逼哈。 系统常用一、通用 Command + X 剪切，可用于文本，文件 Command + C 复制，可用于文本，文件 Command + V 粘贴，可用于文本，文件 Command + A 全选，可用于文本，文件 Command + Z 撤销，可用于文本，文件 Command + S 保存 Command + Shift + S 另存为 Command + O 打开 Command + N 新建 Command + M 最小化 Command + H 隐藏窗口 Command + W 关闭 Command + Q 退出 Command + P 打印 Command + Space 打开Spotlight Control + Command + Space 打开emoji表情 二、文件管理器 Command + Tab 在应用程序切换 Command + ` 在应用程序中的窗口切换 Command + I 显示简介 Command + N 新建文件夹 Command + F 搜索，适用于文本，浏览器，文件 Command + 1/2/3/4 切换文件夹显示模式 Command + Backspace 三、截屏 Command + Shift + 3 截取整个屏幕并保存到桌面 Command + Shift + 4 截取选择区域并保存到桌面 Command + Shift + 4 + Space 截取选择窗口并保存到桌面 Control + Command + Shift + 3 截取整个屏幕并粘贴到剪贴板 Control + Command + Shift + 4 截取选择区域并粘贴到剪贴板 Control + Command + Shift + 4 + Space 截取选择窗口并粘贴到剪贴板 四、浏览器 Command + +/- 放大/缩小 Command + N 新建窗口 Command + T 新建一个标签 Command + R 刷新 Command + W 关闭当前标签 Command + D 添加到收藏夹 Command + L 光标移动到地址框 Space 下一页 Command + Shift + T 重新打开关闭页面 Command + Z Safari重新打开关闭页面 五、应用QQ Control + Command + A 微信/QQ截图 VIM常用一、编辑PyCharm常用一、编辑 Control + Space 基本的代码补全 Control + Shift + Space 智能代码补全 Command + / 注释/取消注释一行 Command + 展开当前 Command - 折叠当前 Shift + Command + 展开所有 Shift + Command - 折叠所有 Shift + Enter 下行另起一行 Control + Y 删除当前行 Control + D 复制所选区域或行到后面或下一行 Control + Alt + O 自动导入 Command + Alt + L 代码格式化 Control + Alt + I 自动缩进 Control + Q 快速查看文档 Command + F1 显示错误描述或警告信息 Control + J 快速查看文档 Control + O 覆盖方法 Control + I 实现方法 Command + Alt + T 包围代码（if else or try catch） Command + Shift + U 大小写转换 二、查找和替换三、编译和运行四、导航五、重构六、通用此文有待更新。]]></content>
      <categories>
        <category>Mac技巧</category>
      </categories>
      <tags>
        <tag>常用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac常用命令]]></title>
    <url>%2F2017%2F09%2F15%2FMac%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[macOS常用命令整理,此文记录了平常使用终端的一些基本命令，使用命令行进行操作还是很有成就感的，建议使用Mac的用户可以学习一下一些基本的命令。 1.man1234man command-nameeg:man lsman -k #search all command 2.pwd cd ls123ls -lapwdcd 3.cat less which file123456789cat #check test filecat a.txt &gt;&gt; b.txtless #high grade than cat #spacekey-&gt;paging #/ search #Q quit #v go to vi editorwhicch command-namefile filename #check file 4.find &amp; mdfind 5.edit file and directory1234mkdir -p a/b/c/d/ecp -R &lt;file&gt; a/b/ file --&gt; b/mv -R &lt;file&gt; a/b/ file --&gt; b/rm -R directory/file 6.vi and nano 7.su and sudo 8.* open . control + c history control + l == clear]]></content>
      <categories>
        <category>Mac技巧</category>
      </categories>
      <tags>
        <tag>常用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基础教程]]></title>
    <url>%2F2017%2F09%2F12%2FGit%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Git学习笔记,此文记录一些常用Git命令，熟练使用Git应该是开发者必须要掌握的一门技术。 安装git和初始化安装1brew install git 用户名和邮箱设置12git config --global user.name "yourname"git config --global user.email "email@example.com" 添加SSH到github 生成本地ssh-key 1ssh-keygen -t rsa -code "youremail@example" 打开主目录中的id_rsa.pub文件 1vim /User/用户名/.ssh/id_rsa.pub 添加ssh-key到github-settings-SSH and GPG keys 测试12ssh -T git@github.comHi entercoder1993! You've successfully authenticated, but GitHub does not provide shell access. ## 创建版本库初始化12git clone &lt;url&gt; #克隆远程版本库git init #初始化版本库 把文件添加到仓库，可以添加一个或多个1git add &lt;-A/--all&gt; 把文件提交到仓库，可以一次提交多个文件1git commit -m "message" 查看仓库的状态1git status 查看文件修改内容1git diff 查看提交历史记录1git log &lt;--pretty=oneline&gt; 在Git中，HEAD表示当前版本，上一个版本就是HEAD^，上上个版本就是HEAD^^使用git reflog可以记录每一次的命令工作区 本地目录 版本库 .git中包含index、master和指针HEAD 暂存区(index) git add –&gt;暂存区 master分支 git commit –&gt;master 查看工作区与版本库的区别1git diff HEAD -- &lt;file&gt; #如果修改之后没有git add到暂存区，使用git commit就不会将修改提交到master中 如果要丢弃工作区的修改，可以使用1git checkout -- &lt;file&gt; #即文件在工作区的修改全部撤销，撤销后文件会回到最后一次git commit或git add的状态 git reset HEAD &lt;file&gt;可以把暂存区的修改撤销，重新放回工作区删除一个文件git rm &lt;file&gt; 远程版本库登陆后再右上角找到Create a new repo，创建一个新的远程仓库，填入对应的仓库名称123git remote add origin git@github.com:&lt;name&gt;/&lt;reponame&gt;.gitgit push -u origin master #第一次推送master分支的所有内容git push origin master #后续使用此命令极客推送 分支管理创建与合并 查看分支 git branch 创建分支 git branch &lt;name&gt; 切换分支 git checkout &lt;name&gt; 创建+切换分支 git checkout -b &lt;name&gt; 合并某分支到当前分支 git merge &lt;name&gt; 删除分支 git branch -d &lt;name&gt; 解决冲突在分支中的修改与master中的修改冲突时，使用git merge合并时会存在冲突，可以使用git status查看冲突，并需要到修改的文件中解决冲突，解决完成后再进行add&amp;commit就可以解决分支中的冲突问题，解决完成后就可以使用git branch -d &lt;name&gt;删除冲突，也可以使用git log --graph查看分支的合并情况。 分支管理策略合并分支时，Git会使用Fast forward模式，这种模式，删除分支后，会丢掉分支信息，如果禁用Fast forwar模式，Git就会在merge时生成一个新的commmit，这样就可以在分支历史中看出分支信息。1git merge --no-ff -m "message" &lt;baranchname&gt; bug分支若master分支出现bug，需要及时修改，我们可以使用git stash把目前修改的分支储存起来，然后将分支切换到出现bug的分支，并创建bug分支，解决完成后，使用1234git stash list #查看分支存储信息git stash apply #恢复储存信息，但stash的内容不删除git stash drop #将储存信息删除git stash pop #恢复的同事删除储存信息 Feature分支未被合并的分支，需要删除分支的，使用git branch -D &lt;branchname&gt; 多人协作使用git remote查看远程仓库的信息加上-v可以查看详细信息 推送分支将本地分支的所有提交提交到远程库，推送时要指定本地分支，这样git就会把该分支推送到远程库对应的分支上12git push origin mastergit push origin dev 抓取分支 查看远程库信息，使用git remote -v 从本地推送分支，使用git push origin branchname 若推送失败，先用git pull抓取远程的新提交 在本地创建和远程分支对应的分支，使用git checkout -b branchname origin/branchname本地和远程分支的名称最好一致 建立本地分支与远程分支的关联，使用git branch --set-upstream branchnanme origin/branchname 从远程抓取分支，使用git pull，如果有冲突，要先才处理冲突 标签管理虽然可以使用commit id来退回版本，但是并不好找，所以使用tag标记为容易记住的有意义的名字，跟某个commit绑定在一起 创建标签git tag &lt;name&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit idgit tag -a &lt;tagname&gt; -m &quot;message&quot;可以指定标签信息git tag -s &lt;tagname&gt; -m &quot;message&quot;可以用PGP签名标签git tag可以查看所有标签 操作标签git push origin &lt;tagname&gt;可以推送一个本地标签git push origin --tags可以推送全部未推送过的本地标签git tag -d &lt;tagname&gt;可以删除一个本地标签git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac安装配置MySQL]]></title>
    <url>%2F2017%2F09%2F05%2FMac%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEMySQL%2F</url>
    <content type="text"><![CDATA[Mac下MySQL的安装其实是很简单，用brew一行代码就解决了，但是安装完成后并不能直接开始用，会出现一些错误，此文可以解决安装后无法使用的问题。 安装使用命令行执行1brew install MySQL 即可安装完成 配置 命令行输入 1sudo chown -R 'Mac用户名' /usr/local 连接 1brew link --overwrite mysql 命令行输入 1234unset TMPDIRbash mysql_install_db --verbose --user=root--basedir="$(brew --prefix mysql)"--datadir=/usr/local/var/mysql --tmpdir=/tmp 启动mysql 1mysql.server start 关闭mysql 1mysql.server stop 常用Mysql用法 待补充]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的Mac小技巧]]></title>
    <url>%2F2017%2F09%2F05%2F%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Mac%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[Mac可以添加自定义功能 主要是利用Automator来添加快捷功能，例例如右键添加复制文件或文件夹路径等。 1.在Finder中打开应用程序 2.双击打开Automator.app 3.选择服务，点击选取 4.设置服务受到选定的文件或文件夹，位于Finder 5.在资源库中找到拷贝到剪贴板，拖动到右边窗口中 6.退出保存，将名称改为拷贝到剪贴板即可。 2018.6.28更新 Mac下显示和隐藏文件打开终端，输入以下命令：12345//此命令显示隐藏文件defaults write com.apple.finder AppleShowAllFiles -bool true//此命令关闭显示隐藏文件defaults write com.apple.finder AppleShowAllFiles -bool false 命令运行之后需要重新加载Finder：快捷键option+command+esc，选中Finder，重新启动即可 截屏 将屏幕图片存储为文件 Shift + Command + 3 将屏幕图片拷贝到剪贴板 Ctrl + Shift + Command + 3 将所选区域的图片存储为文件 Shift + Command + 4 将所选区域的图片拷贝到剪贴板 Ctrl + Shift + Command + 4 Split Screen分屏功能按住窗口的最大会绿色按钮不放，选择放置在左边或者右边，然后选择另一个应用即可进行分屏，可以拖动中间的分割线调整左右区域的大小]]></content>
      <categories>
        <category>Mac技巧</category>
      </categories>
      <tags>
        <tag>常用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python高级特性]]></title>
    <url>%2F2017%2F09%2F02%2FPython%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[在Python中，代码不是越多越好，而是越少越好。代码不是越复杂越好，而是越简单越好 切片切片就是对字符串进行各种截取操作。 1234567891011121314151617&gt;&gt;&gt; l = list(range(1,10))&gt;&gt;&gt; l[1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; l[0:3] #0-3[1, 2, 3]&gt;&gt;&gt; l[:3] #0-3[1, 2, 3]&gt;&gt;&gt; l[-2:] #倒数切片[8, 9]&gt;&gt;&gt; l[::3] #每隔三个数[1, 4, 7]&gt;&gt;&gt; l[:][1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; (1,2,3,4,5,6)[:3] #tuple(1, 2, 3)&gt;&gt;&gt; 'abcdefg'[:3] #字符串切片'abc' 迭代通过for循环来遍历list或tuple 123456&gt;&gt;&gt; for ch in 'abc':... print(ch)...abc 默认情况下迭代value，可以用for value in d.value()同时迭代key和value，可以用for k,v in d.items可以用Iterable判断一个对象是否为可迭代对象 1234567&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance('abc',Iterable)True&gt;&gt;&gt; isinstance([1,2,3],Iterable)True&gt;&gt;&gt; isinstance(123,Iterable)False 通过enumerate可以把一个list变成索引-元素对 123456&gt;&gt;&gt; for i,value in enumerate(['a','b','c']):... print(i,value)...0 a1 b2 c 列表生成式1234567891011121314151617&gt;&gt;&gt; list(range(1,11))[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; [x * x for x in range(1,11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100]&gt;&gt;&gt; [x * x for x in range(1,11) if x % 2 == 0][4, 16, 36, 64, 100]&gt;&gt;&gt; [m + n for m in 'abc' for n in 'xyz']['ax', 'ay', 'az', 'bx', 'by', 'bz', 'cx', 'cy', 'cz']&gt;&gt;&gt; import os&gt;&gt;&gt; [d for d in os.listdir('.')]['.android', '.atom', '.bash_history']&gt;&gt;&gt; d = &#123;'x':'a','y':'b','z':'c'&#125;&gt;&gt;&gt; [k + '=' + v for k,v in d.items()]['x=a', 'y=b', 'z=c']&gt;&gt;&gt; l = ['Hello','Word','IBM','Apple']&gt;&gt;&gt; [s.lower() for s in l]['hello', 'word', 'ibm', 'apple'] 生成器一边循环一边计算的列表成为列表生成器123456&gt;&gt;&gt; l = [x*x for x in range(10)]&gt;&gt;&gt; l[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x*x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x10eecc200&gt; l和g的区别仅在于最外层的[]和()，l是一个list，而g是一个generator，需要通过next()函数才能获得generator的下一个返回值1234&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1 generator保存的是算法，每次调用next(g)，直到最后一个元素时就会抛出StopIteration的错误。可以使用for循环来迭代generator 12345678910111213141516171819&gt;&gt;&gt; def fib(max):... n,a,b=0,0,1... while n &lt; max:... yield b... a,b = b,a+b... n = n + 1... return 'done'...&gt;&gt;&gt; fib(6)&lt;generator object fib at 0x10eecc2b0&gt;&gt;&gt;&gt; for n in fib(6):... print(n)...112358 迭代器可以直接作用于for循环的数据类型： 集合数据类型，如list、tuple、dict、set、str等； generator，包括生成器和带yield的generator function。 这些可以直接作用于for循环的对象称为可迭代对象：Iterable，可以使用isinstance()判断一个对象是否是Iterable对象。生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator可以使用iter()函数把Iterable变成Iterator 123&gt;&gt;&gt; from collections import Iterator&gt;&gt;&gt; isinstance(iter('abc'),Iterator)True Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。 Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云服务器搭建流程]]></title>
    <url>%2F2017%2F08%2F31%2F%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[正好京东云搞服务，弄了一个月体验时间，这边文章是使用京东云的服务器体验云服务器整个搭建的流程。 登录京东云服务器后台浏览器输入http://www.jcloud.com输入京东账号密码进入京东云管理界面，创建系统版本为Ubuntu16.04 64位，创建完成后在云主机上就可以查看到公网/内网IP地址 使用ssh登录远程连接打开终端，在终端执行1ssh root@116.196.109.126 #该IP地址为公网IP地址 然后输入密码，密码会以短信形式发送到手机上，在/home目录下新建一个文件夹dzd，把相关文件都放在这个目录下123cd /homemkdir dzdcd dzd 下载安装jdk因为Tomact服务器是依赖jdk的，所以这里要先下载安装jdk下载jdk12wget --no-cookies --header "Cookie: oraclelicense=accept-securebackup-cookie" http://download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gztar -zxvf /home/dzd/jdk-8u144-linux-x64.tar.gz -C /usr/java/ 配置环境变量12345678vi ~/.bashrc#在最下面添加java环境变量配置信息export JAVA_HOME=/usr/java/jdk1.8.0_144export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH#退出vi编辑器，输入下行命令使配置文件立即生效source ~/.bashrc 下载安装Tomact下载Tomact服务器1wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-7/v7.0.81/bin/apache-tomcat-7.0.81.tar.gz 解压1tar -zxf apache-tomcat-7.0.81.tar.gz 启动服务器1234#切换到bin目录下cd apache-tomcat-7.0.81.tar.gz/bin#运行startup.sh启动服务器./startup.sh 打开浏览器，输入http://116.196.109.126:8080/就可以看到服务器启动成功的页面 添加静态页面或json文件123cd ..cd webapps/ROOT/vi hello.html 在浏览器输入116.196.109.126:8080/hello.html就可以访问到刚才创建的html静态页面了 遇到的问题 问题1：解压jdk压缩包错误，使用tar -zxvf 文件始终无法解压文件使用file查看jdk压缩包发现是html文件格式，因此无法进行解压缩，删除文件后重新进行下载，若使用wget的话，一定要在后面加上这个参数–no-cookies –header “Cookie: oraclelicense=accept-securebackup-cookie”1wget --no-cookies --header "Cookie: oraclelicense=accept-securebackup-cookie" jdk下载链接 这样下载的jdk压缩包就可以进行解压缩了 问题2：创建静态文件后，使用vi编辑，输入中文乱码打开vi的配置文件123456vi /etc/vim/vimrc#去掉#if has("autocmd") 及下面2行的注释#并在最下方加入set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936set termencoding=utf-8set encoding=utf-8]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac常用软件]]></title>
    <url>%2F2017%2F08%2F31%2FMac%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[记录自己使用Mac下载的软件及相关配置，备忘 Mac安装软件下载及配置AppStore安装 QQ 微信 迅雷 百度网盘 网易云 Alfred 有道词典 印象笔记 Dr. Clean Excel Word PowperPoint 搜狗输入法 IINA 坚果云 程序员必备 iTerm2 ohmyzsh autojump zsh-syntax-highlighting zsh-autosuggestions Dash Sublime Test3 Android Studio Python Git SpaceLauncher Spectacle PyCharm Parallels Eclipse Node.js npm cask Hexo 谷歌浏览器 SSR Go2shell Charles MacDown PDF Expert MindNote 实验楼 Focus chrome插件 1Player for 网易云音乐 AdBlock Bookmark Sidebar ChaZD Google Keep Google 翻译 Infinity新标签页 Octotree Save to Pocket search2 Stylish Vimium 印象笔记·剪藏 滴答清单 命令行工具 you-get musicbox HomeBrew BrewCask cmatrix 123brew cask install software-namebrew install package-name update:2017.11.22]]></content>
      <categories>
        <category>Mac技巧</category>
      </categories>
      <tags>
        <tag>常用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础]]></title>
    <url>%2F2017%2F08%2F30%2FPython%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Python是一种解释型、面向对象、动态数据类型的高级程序设计语言。目前，Python已经成为最受欢迎的语言之一。人生苦短，我用Python。 基本语法规则 以#开头的语句时注释 当语句以:号结尾时，缩进的语句视为代码块 缩进按照约定俗成的管理为4个空格 Python时大小写敏感的 数据类型和变量 整型：在程序中和数学上的写法一致，当使用十六进制表示整数时，用0x前缀和0～9，a～f表示 浮点数：浮点数也就是小数，对于很大或很小的浮点数，使用科学计数法表示，把10用e替代，1.23*e9表示1.23乘以10的九次方，0.000012可以写成1.2e-5 字符串：字符串以’或”括起来的任意文本，’’或””本身是一种表示方式，不是字符串的一部分，如果’或”也是字符的一部分，可以用””或’’括起来，若内部包含’和”，可以用\来表示，如果字符串有很多字符都需要转义，可以使用r’’…’’表示内部的字符默认不转义，如果字符串内部有很多换行，可以使用’’’…’’’表示多行内容（\n表示换行，\t表示制表符，\\表示\） 布尔值：布尔值只有True和False两种值（注意大小写），布尔值也可以用and、or和not运算 空值：空值是Python里的一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值 变量：变量在程序中用一个变量名表示，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，在Python中，可以把热议数据类型赋值个变量，同一个变量可以反复赋值，而且可以是不同类型的变量。这种变量类型不固定的语言称之为动态语言 常量：所谓常量就是不能变的变量，用全部大写的变量名表示出常量只是一个习惯上的用法。在Python中有两种除法，一种除法是/，/除法计算结果是浮点数，即使是两个整数恰好相除，结果也是浮点数，还有一种除法是//，称为地板除，两个整数的除法仍然是整数： 12345678&gt;&gt;&gt; 10 / 33.333333333333&gt;&gt;&gt; 6 / 33.0&gt;&gt;&gt; 10 // 33 字符串和编码字符编码因为计算机只能处理数字，如果要处理文本，需要先把文本转化为数字才能处理。中国汉字编码GB2312。Python中默认的编码模式是ASCII格式，需要在Python文件开头加入# -*- coding: UTF-8 -*-或#coding=utf-8即可 Python字符串 在Python中，字符串是以Unicode编码的，对于单个字符的编码Python提供了ord()函数获取字符的整数表示，char()函数把编码转换为对应的字符1234&gt;&gt;&gt;ord('A')65&gt;&gt;&gt;chr(26460)'杜' 十六进制12&gt;&gt;&gt;'\u4e2d\u6587''中文' 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。’ABC’是字符串 1234&gt;&gt;&gt;x = b'ABC'&gt;&gt;&gt;y = 'ABC'&gt;&gt;&gt;print(x == y)False 以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如： 12&gt;&gt;&gt; '中文'.encode('utf-8')b'\xe4\xb8\xad\xe6\x96\x87' 纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法： 1234&gt;&gt;&gt; b'ABC'.decode('ascii')'ABC'&gt;&gt;&gt; b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')'中文' len()函数可以用来要计算str包含的字符数也可以计算bytes的字节数 1234567&gt;&gt;&gt;len('ABC')3&gt;&gt;&gt;len('中文')2&gt;&gt;&gt;len(b'ABC')3&gt;&gt;&gt;len('中文'.encode('utf-8')) 1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。12#!/usr/bin/env python3 #linux/OS X系统下为可执行程序# -*- coding: utf-8 -*- #按UTF-8读取源代码 格式化在Python中格式化的方式和C一样使用%输出格式化字符%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%f表示用浮点数替换，%x表示用十六进制替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。 123456789#!/usr/bin/env python3# -*- coding: utf-8 -*-s1 = int(input('去年的成绩：'))s2 = int(input('今年的成绩：'))r = (s2 - s1) / s1 * 100if s1 &gt; s2: print('下降了：''%.1f %%' % r)else: print('提升了：''%.1f %%' % r) 使用list和tuplelistPython内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。索引从0开始，超出列表长度时会报错，最后一个元素的索引是len(list)-1，还以用len[-1]直接获取最后一个元素，list中元素类型可以不同，12345678&gt;&gt;&gt;len(list) #可以获得list列表的长度&gt;&gt;&gt;list.appen() #追加元素到list的末尾&gt;&gt;&gt;list.insert(i) #插入元素到指定位置&gt;&gt;&gt;list.pop(i) #删除末尾的元素，用pop()，使用pop(i)删除指定位置的元素 #若要替换元素，则直接赋值给对应的索引位置&gt;&gt;&gt; list = []&gt;&gt;&gt; len(list)0 tuple另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改。定义tuple时，tuple的元素必须被确定下来123456789&gt;&gt;&gt;t = (1,2)&gt;&gt;&gt;t(1,2)&gt;&gt;&gt;t = ()&gt;&gt;&gt;t()&gt;&gt;&gt;t = (1,)&gt;&gt;&gt;t(1,) 若tuple中包含list，则该tuple中的list元素可变，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 条件判断123456789101112#if语句的完整形式if &lt;条件判断1&gt;: &lt;执行1&gt;elif &lt;条件判断2&gt;: &lt;执行2&gt;elif &lt;条件判断3&gt;: &lt;执行3&gt;else: &lt;执行4&gt;if x: print("True") #只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False 循环 for循环for x in …循环就是把每个元素代入变量x，然后执行缩进块的语句。range()函数可以生成一个整数序列，通过list()函数装换为list。 12list(range(5))[0,1,2,3,4,] while循环while循环，只要条件满足，就不断循环，条件不满足时退出循环。 123while ... #条件 ... #条件满足时执行print() #条件不满足执行 break和continue在循环中，在满足break语句前的if语句条件时执行，可以提前退出循环。continue的作用是提前结束本轮循环，不会执行满足if条件时的语句，直接开始下一轮循环。注意：不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。 使用dict和setdictdict在其他语言中也称为map，使用键-值存储，具有极快的查找速度，一个key只能对应一个value，多次对一个key放入value，后面的值会把前面的值替换掉。若key不存在，则dict报错，可以通过in或get方法判断key是否存在。dict的key必须是不可变对象。12345&gt;&gt;&gt;'abc' in sFalse&gt;&gt;&gt;d.get('abc')&gt;&gt;&gt;d.get('abc',x)x 可以通过pop(key)方法删除对应的key，dict内部存放的顺序和key放入的顺序无关。list相比，dict特点： 查找和插入的速度快，不会是UI这key的增加而增加 占用大量内存，浪费内存list相反： 查找和插入的时间随着元素的增加而增加 占用空间小，浪费内存少 setset和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。注意：传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。要创建一个set，需要提供一个list作为输入集合：1234567891011121314151617&gt;&gt;&gt;s = set([1,2,3])&gt;&gt;&gt;s&#123;1,2,3&#125;&gt;&gt;&gt;x = set([1,1,2,2,3,3])&gt;&gt;&gt;x&#123;1,2,3&#125;&gt;&gt;&gt;s.add(4)&gt;&gt;&gt;s&#123;1,2,3,4&#125;&gt;&gt;&gt;x.remove(3)&gt;&gt;&gt;x&#123;1,2&#125;#set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等&gt;&gt;&gt;s &amp; x&#123;1,2&#125;&gt;&gt;&gt;s | x&#123;1,2,3,4&#125; 函数 函数是最基本的一种代码抽象的方式 调用函数[官方文档]{http://docs.python.org/3/library/functions.html}要调用函数首先要知道函数的名称和参数，1234abs(100)100abs(-100)100 若传参个数或类型错误，都会报TypeError错误 数据类型转换Python内指定额常用函数还包括数据类型转寒函数1234567891011121314&gt;&gt;&gt; int('123')123&gt;&gt;&gt; int(12.34)12&gt;&gt;&gt; float('12.34')12.34&gt;&gt;&gt; str(1.23)'1.23'&gt;&gt;&gt; str(100)'100'&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool('')False 函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：123&gt;&gt;&gt; a = abs # 变量a指向abs函数&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数1 定义函数在Python中，定义一个函数使用def语句def name(args): return 执行语句若没有return语句，则返回None。return None == returnfrom x import y用来导入x.py文件中定义的y函数。 空函数12345dep nop(): passif age &gt;= 18 pass pass语句什么也不做，但是可以用来作为占位符 参数检查内置函数会检查出参数错误，而我们定义的函数没有参数检查，两种同样的错误就会导致语句中出错的原因不同。可以用isinstance()做参数数据类型检查1234def people(name,age): if not isinstance(name,(str)): raise TypeError('bad operand type') return print(name,age) 返回多个值123456789101112131415import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print(x, y)151.96152422706632 70.0#返回值放在一个tuple中&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print(r)(151.96152422706632, 70.0) 函数的参数 位置参数12dep power(x): return x * x 对于power(x)函数，参数x就是一个位置参数。当调用power函数时，必须传入有且仅有的一个参数x 递归函数参考教程：Python教程,廖雪峰的官方网站]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
</search>
